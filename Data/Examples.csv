ID,Parent,Project,Type,Fowler_type,path_before,path_after,name,LongName,b_StartLine,b_StartColumn,b_EndLine,b_EndColumn,a_StartLine,a_StartColumn,a_EndLine,a_EndColumn,BeforeRefact,AfterRefact,
L10937,L8817,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,tool\src\org\antlr\v4\codegen\ParserFactory.java,tool\src\org\antlr\v4\codegen\ParserFactory.java,"List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert)",org.antlr.v4.codegen.ParserFactory.set(Lorg/antlr/v4/tool/ast/GrammarAST;Lorg/antlr/v4/tool/ast/GrammarAST;Z)Ljava/util/List;,,,,,178,2,199,3,"
	public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
		MatchSet matchOp;
		if ( invert ) matchOp = new MatchNotSet(this, setAST);
		else matchOp = new MatchSet(this, setAST);
		if ( labelAST!=null ) {
			String label = labelAST.getText();
			Decl d = getTokenLabelDecl(label);
			matchOp.labels.add(d);
			getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {
				TokenListDecl l = getTokenListLabelDecl(label);
				getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);
			}
		}
		if ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);
		AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);
		return list(matchOp, listLabelOp);
	}","public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
		MatchSet matchOp;
		if ( invert ) matchOp = new MatchNotSet(this, setAST);
		else matchOp = new MatchSet(this, setAST);
		if ( labelAST!=null ) {
			String label = labelAST.getText();
			RuleFunction rf = getCurrentRuleFunction();
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {
				defineImplicitLabel(setAST, matchOp);
				TokenListDecl l = getTokenListLabelDecl(label);
				rf.addContextDecl(setAST.getAltLabel(), l);
			}
			else {
				Decl d = getTokenLabelDecl(label);
				matchOp.labels.add(d);
				rf.addContextDecl(setAST.getAltLabel(), d);
			}
		}
		if ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);
		AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);
		return list(matchOp, listLabelOp);
	}",
L5343,L543,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\Parser.java,runtime\Java\src\org\antlr\v4\runtime\Parser.java,List<ParseTreeListener> getParseListeners(),org.antlr.v4.runtime.Parser.getParseListeners()Ljava/util/List;,,,,,298,2,305,3,"public List<ParseTreeListener> getParseListeners() {
        return _parseListeners;
    }","public List<ParseTreeListener> getParseListeners() {
		List<ParseTreeListener> listeners = _parseListeners;
		if (listeners == null) {
			return Collections.emptyList();
		}

		return listeners;
	}",
L3671,L3660,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,"void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)",org.antlr.v4.runtime.DiagnosticErrorListener.reportAmbiguity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,,,,,89,2,107,3," public void reportAmbiguity(@NotNull Parser recognizer,
								DFA dfa, int startIndex, int stopIndex,
								@NotNull BitSet ambigAlts,
								@NotNull ATNConfigSet configs)
    {
        recognizer.notifyErrorListeners(""reportAmbiguity d="" + dfa.decision +
			"": ambigAlts="" + ambigAlts + "", input='"" +
			recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + ""'"");
    }","public void reportAmbiguity(@NotNull Parser recognizer,
								DFA dfa,
								int startIndex,
								int stopIndex,
								boolean exact,
								@Nullable BitSet ambigAlts,
								@NotNull ATNConfigSet configs)
	{
		if (exactOnly && !exact) {
			return;
		}

		String format = ""reportAmbiguity d=%s: ambigAlts=%s, input='%s'"";
		String decision = getDecisionDescription(recognizer, dfa);
		BitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);
		String text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));
		String message = String.format(format, decision, conflictingAlts, text);
		recognizer.notifyErrorListeners(message);
	}",
L3692,L3660,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,"void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs)",org.antlr.v4.runtime.DiagnosticErrorListener.reportContextSensitivity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIILorg/antlr/v4/runtime/atn/ATNConfigSet;)V,,,,,125,2,137,3,"public void reportContextSensitivity(@NotNull Parser recognizer,
										 @NotNull DFA dfa,
                                         int startIndex, int stopIndex,
										 @NotNull ATNConfigSet configs)
    {
        recognizer.notifyErrorListeners(""reportContextSensitivity d="" +
			dfa.decision + "", input='"" +
			recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + ""'"");
    }
}","public void reportContextSensitivity(@NotNull Parser recognizer,
										 @NotNull DFA dfa,
										 int startIndex,
										 int stopIndex,
										 int prediction,
										 @NotNull ATNConfigSet configs)
	{
		String format = ""reportContextSensitivity d=%s, input='%s'"";
		String decision = getDecisionDescription(recognizer, dfa);
		String text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));
		String message = String.format(format, decision, text);
		recognizer.notifyErrorListeners(message);
	}",
L7413,L7392,antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,void processParser(),org.antlr.v4.analysis.AnalysisPipeline.processParser()V,,,,,82,2,101,3,"protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}","protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}

			assert s.decision + 1 >= g.decisionLOOK.size();
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}",
L10037,L10036,antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\codegen\model\LL1StarBlockSingleAlt.java,tool\src\org\antlr\v4\codegen\model\LL1StarBlockSingleAlt.java,"LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts)",org.antlr.v4.codegen.model.LL1StarBlockSingleAlt.<init>(Lorg/antlr/v4/codegen/OutputModelFactory;Lorg/antlr/v4/tool/ast/GrammarAST;Ljava/util/List;)V,,,,,42,2,53,3,"public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
		super(factory, starRoot, alts);

		StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;
		loopBackStateNumber = star.loopBackState.stateNumber;
		this.decision = star.decision;
		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
		IntervalSet enterLook = altLookSets[1];
		IntervalSet exitLook = altLookSets[2];
		loopExpr = addCodeForLoopLookaheadTempVar(enterLook);
	}","public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
		super(factory, starRoot, alts);

		StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;
		loopBackStateNumber = star.loopBackState.stateNumber;
		this.decision = star.decision;
		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
		assert altLookSets.length == 2;
		IntervalSet enterLook = altLookSets[0];
		IntervalSet exitLook = altLookSets[1];
		loopExpr = addCodeForLoopLookaheadTempVar(enterLook);
	}",
L3446,L3013,antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\DefaultErrorStrategy.java,runtime\Java\src\org\antlr\v4\runtime\DefaultErrorStrategy.java,"int execATN(@NotNull CharStream input, @NotNull DFAState ds0)",org.antlr.v4.runtime.atn.LexerATNSimulator. execATN(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;,340,,359,,536,2,554,3,"public Token singleTokenDeletion(Parser recognizer) {
		int nextTokenType = recognizer.getInputStream().LA(2);
		IntervalSet expecting = getExpectedTokens(recognizer);
		if ( expecting.contains(nextTokenType) ) {
			reportUnwantedToken(recognizer);
			/*
			System.err.println(""recoverFromMismatchedToken deleting ""+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   "" since ""+((TokenStream)recognizer.getInputStream()).LT(2)+
							   "" is what we want"");
			*/
			recognizer.consume(); // simply delete extra token
			// we want to return the token we're actually matching
			Token matchedSymbol = recognizer.getCurrentToken();
			endErrorCondition(recognizer);  // we know current token is correct
			return matchedSymbol;
		}
		return null;
	}","protected Token singleTokenDeletion(@NotNull Parser recognizer) {
		int nextTokenType = recognizer.getInputStream().LA(2);
		IntervalSet expecting = getExpectedTokens(recognizer);
		if ( expecting.contains(nextTokenType) ) {
			reportUnwantedToken(recognizer);
			/*
			System.err.println(""recoverFromMismatchedToken deleting ""+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   "" since ""+((TokenStream)recognizer.getInputStream()).LT(2)+
							   "" is what we want"");
			*/
			recognizer.consume(); // simply delete extra token
			// we want to return the token we're actually matching
			Token matchedSymbol = recognizer.getCurrentToken();
			reportMatch(recognizer);  // we know current token is correct
			return matchedSymbol;
		}
		return null;
	}

@Override
	public void reportMatch(Parser recognizer) {
		endErrorCondition(recognizer);
	}",
L1927,L1833,antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"int execATN(@NotNull CharStream input, @NotNull DFAState ds0)",org.antlr.v4.runtime.atn.LexerATNSimulator. execATN(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;,197,,282,,187,2,302,3,"protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {
		//System.out.println(""enter exec index ""+input.index()+"" from ""+ds0.configs);
		if ( debug ) {
			System.out.format(""start state closure=%s\n"", ds0.configs);
		}

		int t = input.LA(1);
		@NotNull
		DFAState s = ds0; // s is current/from DFA state

		while ( true ) { // while more work
			if ( debug ) {
				System.out.format(""execATN loop starting closure: %s\n"", s.configs);
			}

			// As we move src->trg, src->trg, we keep track of the previous trg to
			// avoid looking up the DFA state again, which is expensive.
			// If the previous target was already part of the DFA, we might
			// be able to avoid doing a reach operation upon t. If s!=null,
			// it means that semantic predicates didn't prevent us from
			// creating a DFA state. Once we know s!=null, we check to see if
			// the DFA state has an edge already for t. If so, we can just reuse
			// it's configuration set; there's no point in re-computing it.
			// This is kind of like doing DFA simulation within the ATN
			// simulation because DFA simulation is really just a way to avoid
			// computing reach/closure sets. Technically, once we know that
			// we have a previously added DFA state, we could jump over to
			// the DFA simulator. But, that would mean popping back and forth
			// a lot and making things more complicated algorithmically.
			// This optimization makes a lot of sense for loops within DFA.
			// A character will take us back to an existing DFA state
			// that already has lots of edges out of it. e.g., .* in comments.
			ATNConfigSet closure = s.configs;
			DFAState target = null;
			if ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {
				target = s.edges[t - MIN_DFA_EDGE];
				if (target == ERROR) {
					break;
				}

				if (debug && target != null) {
					System.out.println(""reuse state ""+s.stateNumber+
									   "" edge to ""+target.stateNumber);
				}
			}

			if (target == null) {
				ATNConfigSet reach = new OrderedATNConfigSet();

				// if we don't find an existing DFA state
				// Fill reach starting from closure, following t transitions
				getReachableConfigSet(input, closure, reach, t);

				if ( reach.isEmpty() ) { // we got nowhere on t from s
					// we reached state associated with closure for sure, so
					// make sure it's defined. worst case, we define s0 from
					// start state configs.
					@NotNull
					DFAState from = s != null ? s : addDFAState(closure);
					// we got nowhere on t, don't throw out this knowledge; it'd
					// cause a failover from DFA later.
					addDFAEdge(from, t, ERROR);
					break; // stop when we can't match any more char
				}

				// Add an edge from s to target DFA found/created for reach
				target = addDFAEdge(s, t, reach);
			}

			if (target.isAcceptState) {
				captureSimState(prevAccept, input, target);
				if (t == IntStream.EOF) {
					break;
				}
			}

			if (t != IntStream.EOF) {
				consume(input);
				t = input.LA(1);
			}

			s = target; // flip; current DFA target becomes new src/from state
		}

		return failOrAccept(prevAccept, input, s.configs, t);
	}","protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {
		//System.out.println(""enter exec index ""+input.index()+"" from ""+ds0.configs);
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""start state closure=%s\n"", ds0.configs);
		}

		int t = input.LA(1);
		@NotNull
		DFAState s = ds0; // s is current/from DFA state

		while ( true ) { // while more work
			if ( debug ) {
				System.out.format(Locale.getDefault(), ""execATN loop starting closure: %s\n"", s.configs);
			}

			// As we move src->trg, src->trg, we keep track of the previous trg to
			// avoid looking up the DFA state again, which is expensive.
			// If the previous target was already part of the DFA, we might
			// be able to avoid doing a reach operation upon t. If s!=null,
			// it means that semantic predicates didn't prevent us from
			// creating a DFA state. Once we know s!=null, we check to see if
			// the DFA state has an edge already for t. If so, we can just reuse
			// it's configuration set; there's no point in re-computing it.
			// This is kind of like doing DFA simulation within the ATN
			// simulation because DFA simulation is really just a way to avoid
			// computing reach/closure sets. Technically, once we know that
			// we have a previously added DFA state, we could jump over to
			// the DFA simulator. But, that would mean popping back and forth
			// a lot and making things more complicated algorithmically.
			// This optimization makes a lot of sense for loops within DFA.
			// A character will take us back to an existing DFA state
			// that already has lots of edges out of it. e.g., .* in comments.
			DFAState target = getExistingTargetState(s, t);
			if (target == null) {
				target = computeTargetState(input, s, t);
			}

			if (target == ERROR) {
				break;
			}

			if (target.isAcceptState) {
				captureSimState(prevAccept, input, target);
				if (t == IntStream.EOF) {
					break;
				}
			}

			if (t != IntStream.EOF) {
				consume(input);
				t = input.LA(1);
			}

			s = target; // flip; current DFA target becomes new src/from state
		}

		return failOrAccept(prevAccept, input, s.configs, t);
	}

	/**
	 * Get an existing target state for an edge in the DFA. If the target state
	 * for the edge has not yet been computed or is otherwise not available,
	 * this method returns {@code null}.
	 *
	 * @param s The current DFA state
	 * @param t The next input symbol
	 * @return The existing target DFA state for the given input symbol
	 * {@code t}, or {@code null} if the target state for this edge is not
	 * already cached
	 */
	@Nullable
	protected DFAState getExistingTargetState(@NotNull DFAState s, int t) {
		if (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {
			return null;
		}
		
		DFAState target = s.edges[t - MIN_DFA_EDGE];
		if (debug && target != null) {
			System.out.println(""reuse state ""+s.stateNumber+
							   "" edge to ""+target.stateNumber);
		}

		return target;
	}

	/**
	 * Compute a target state for an edge in the DFA, and attempt to add the
	 * computed state and corresponding edge to the DFA.
	 *
	 * @param input The input stream
	 * @param s The current DFA state
	 * @param t The next input symbol
	 *
	 * @return The computed target DFA state for the given input symbol
	 * {@code t}. If {@code t} does not lead to a valid DFA state, this method
	 * returns {@link #ERROR}.
	 */
	@NotNull
	protected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {
		ATNConfigSet reach = new OrderedATNConfigSet();

		// if we don't find an existing DFA state
		// Fill reach starting from closure, following t transitions
		getReachableConfigSet(input, s.configs, reach, t);

		if ( reach.isEmpty() ) { // we got nowhere on t from s
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			addDFAEdge(s, t, ERROR);
			// stop when we can't match any more char
			return ERROR;
		}

		// Add an edge from s to target DFA found/created for reach
		return addDFAEdge(s, t, reach);
	}",
L540,L515,antlr4,ADD_PARAMETER,Introduce Parameter Object,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,"void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)",org.antlr.v4.runtime.ANTLRErrorListener.reportAmbiguity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,92,,95,,112,2,118,39,"void reportAmbiguity(@NotNull Parser recognizer,
						 DFA dfa, int startIndex, int stopIndex,
						 @NotNull BitSet ambigAlts,
						 @NotNull ATNConfigSet configs);","void reportAmbiguity(@NotNull Parser recognizer,
						 @NotNull DFA dfa,
						 int startIndex,
						 int stopIndex,
						 boolean exact,
						 @NotNull BitSet ambigAlts,
						 @NotNull ATNConfigSet configs);",
L561,L515,antlr4,ADD_PARAMETER,Introduce Parameter Object,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,"void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs)",org.antlr.v4.runtime.ANTLRErrorListener.reportAttemptingFullContext(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IILjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,97,,100,,141,2,146,42,"void reportAttemptingFullContext(@NotNull Parser recognizer,
									 @NotNull DFA dfa,
									 int startIndex, int stopIndex,
									 @NotNull ATNConfigSet configs);","void reportAttemptingFullContext(@NotNull Parser recognizer,
									 @NotNull DFA dfa,
									 int startIndex,
									 int stopIndex,
									 @Nullable BitSet conflictingAlts,
									 @NotNull ATNConfigSet configs);",
L1114,L1049,antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\ATNConfig.java,runtime\Java\src\org\antlr\v4\runtime\misc/MurmurHash.java,int hashCode(),org.antlr.v4.runtime.atn.ATNConfig.hashCode()I,256,,262,,162,2,170,3,"public int hashCode(ATNConfig o) {
			int hashCode = 7;
			hashCode = 31 * hashCode + o.state.stateNumber;
			hashCode = 31 * hashCode + o.alt;
			hashCode = 31 * hashCode + o.semanticContext.hashCode();
	        return hashCode;
		}","public int hashCode() {
		int hashCode = MurmurHash.initialize(7);
		hashCode = MurmurHash.update(hashCode, state.stateNumber);
		hashCode = MurmurHash.update(hashCode, alt);
		hashCode = MurmurHash.update(hashCode, context);
		hashCode = MurmurHash.update(hashCode, semanticContext);
		hashCode = MurmurHash.finish(hashCode, 4);
		return hashCode;
	}","public static int update(int hash, int value) {
		final int c1 = 0xCC9E2D51;
		final int c2 = 0x1B873593;
		final int r1 = 15;
		final int r2 = 13;
		final int m = 5;
		final int n = 0xE6546B64;

		int k = value;
		k = k * c1;
		k = (k << r1) | (k >>> (32 - r1));
		k = k * c2;

		hash = hash ^ k;
		hash = (hash << r2) | (hash >>> (32 - r2));
		hash = hash * m + n;

		return hash;
	}

	/**
	 * Update the intermediate hash value for the next input {@code value}.
	 *
	 * @param hash the intermediate hash value
	 * @param value the value to add to the current hash
	 * @return the updated intermediate hash value
	 */
	public static int update(int hash, Object value) {
		return update(hash, value != null ? value.hashCode() : 0);
	}"
L4884,L4876,junit,INLINE_TEMP,Inline Variable,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,void addFailure(Throwable targetException),org.junit.internal.runners.model.EachTestNotifier.addFailure(Ljava/lang/Throwable;)V,22,,30,,21,2,33,3,"public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			MultipleFailureException mfe= (MultipleFailureException) targetException;
			for (Throwable each : mfe.getFailures())
				addFailure(each);
			return;
		}
		fNotifier.fireTestFailure(new Failure(fDescription, targetException));
	}","public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			addMultipleFailureException((MultipleFailureException) targetException);
		} else {
			fNotifier
					.fireTestFailure(new Failure(fDescription, targetException));
		}
	}

	private void addMultipleFailureException(MultipleFailureException mfe) {
		for (Throwable each : mfe.getFailures())
			addFailure(each);
	}",
L7126,L6751,junit,INTRODUCE_ASSERTION,Introduce Assertion,src\test\java\org\junit\tests\experimental\categories\CategoryTest.java,src\test\java\org\junit\tests\experimental\categories\CategoryTest.java,void testCountWithExplicitFilter(),org.junit.tests.experimental.categories.CategoryTest.testCountWithExplicitFilter()V,128,,133,,129,2,135,3,"public void testCountWithExplicitFilter() throws Throwable {

		CategoryFilter include= CategoryFilter.include(SlowTests.class);

		Request baseRequest= Request.aClass(TestSuiteWithNoCategories.class);

		Result result= new JUnitCore().run(baseRequest.filterWith(include));

		assertTrue(result.wasSuccessful());

	}","
public void testCountWithExplicitFilter() throws Throwable {

		CategoryFilter include= CategoryFilter.include(SlowTests.class);

		Request baseRequest= Request.aClass(TestSuiteWithNoCategories.class);

		Result result= new JUnitCore().run(baseRequest.filterWith(include));

		assertTrue(result.wasSuccessful());

		assertEquals(2, result.getRunCount());

	}",
