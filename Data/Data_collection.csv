ID,Parent,commitID_before,commitID_after,Project,Type,Fowler_type,path_before,path_after,name,LongName,b_StartLine,b_StartColumn,b_EndLine,b_EndColumn,a_StartLine,a_StartColumn,a_EndLine,a_EndColumn,BeforeRefact,AfterRefact,
L10937,L8817,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,tool\src\org\antlr\v4\codegen\ParserFactory.java,tool\src\org\antlr\v4\codegen\ParserFactory.java,"List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert)",org.antlr.v4.codegen.ParserFactory.set(Lorg/antlr/v4/tool/ast/GrammarAST;Lorg/antlr/v4/tool/ast/GrammarAST;Z)Ljava/util/List;,,,,,178,2,199,3,"
	public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
		MatchSet matchOp;
		if ( invert ) matchOp = new MatchNotSet(this, setAST);
		else matchOp = new MatchSet(this, setAST);
		if ( labelAST!=null ) {
			String label = labelAST.getText();
			Decl d = getTokenLabelDecl(label);
			matchOp.labels.add(d);
			getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {
				TokenListDecl l = getTokenListLabelDecl(label);
				getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);
			}
		}
		if ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);
		AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);
		return list(matchOp, listLabelOp);
	}","public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
		MatchSet matchOp;
		if ( invert ) matchOp = new MatchNotSet(this, setAST);
		else matchOp = new MatchSet(this, setAST);
		if ( labelAST!=null ) {
			String label = labelAST.getText();
			RuleFunction rf = getCurrentRuleFunction();
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {
				defineImplicitLabel(setAST, matchOp);
				TokenListDecl l = getTokenListLabelDecl(label);
				rf.addContextDecl(setAST.getAltLabel(), l);
			}
			else {
				Decl d = getTokenLabelDecl(label);
				matchOp.labels.add(d);
				rf.addContextDecl(setAST.getAltLabel(), d);
			}
		}
		if ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);
		AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);
		return list(matchOp, listLabelOp);
	}",
L5343,L543,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\Parser.java,runtime\Java\src\org\antlr\v4\runtime\Parser.java,List<ParseTreeListener> getParseListeners(),org.antlr.v4.runtime.Parser.getParseListeners()Ljava/util/List;,,,,,298,2,305,3,"public List<ParseTreeListener> getParseListeners() {
        return _parseListeners;
    }","public List<ParseTreeListener> getParseListeners() {
		List<ParseTreeListener> listeners = _parseListeners;
		if (listeners == null) {
			return Collections.emptyList();
		}

		return listeners;
	}",
L3671,L3660,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,"void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)",org.antlr.v4.runtime.DiagnosticErrorListener.reportAmbiguity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,,,,,89,2,107,3," public void reportAmbiguity(@NotNull Parser recognizer,
								DFA dfa, int startIndex, int stopIndex,
								@NotNull BitSet ambigAlts,
								@NotNull ATNConfigSet configs)
    {
        recognizer.notifyErrorListeners(""reportAmbiguity d="" + dfa.decision +
			"": ambigAlts="" + ambigAlts + "", input='"" +
			recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + ""'"");
    }","public void reportAmbiguity(@NotNull Parser recognizer,
								DFA dfa,
								int startIndex,
								int stopIndex,
								boolean exact,
								@Nullable BitSet ambigAlts,
								@NotNull ATNConfigSet configs)
	{
		if (exactOnly && !exact) {
			return;
		}

		String format = ""reportAmbiguity d=%s: ambigAlts=%s, input='%s'"";
		String decision = getDecisionDescription(recognizer, dfa);
		BitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);
		String text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));
		String message = String.format(format, decision, conflictingAlts, text);
		recognizer.notifyErrorListeners(message);
	}",
L3692,L3660,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,"void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs)",org.antlr.v4.runtime.DiagnosticErrorListener.reportContextSensitivity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIILorg/antlr/v4/runtime/atn/ATNConfigSet;)V,,,,,125,2,137,3,"public void reportContextSensitivity(@NotNull Parser recognizer,
										 @NotNull DFA dfa,
                                         int startIndex, int stopIndex,
										 @NotNull ATNConfigSet configs)
    {
        recognizer.notifyErrorListeners(""reportContextSensitivity d="" +
			dfa.decision + "", input='"" +
			recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + ""'"");
    }
}","public void reportContextSensitivity(@NotNull Parser recognizer,
										 @NotNull DFA dfa,
										 int startIndex,
										 int stopIndex,
										 int prediction,
										 @NotNull ATNConfigSet configs)
	{
		String format = ""reportContextSensitivity d=%s, input='%s'"";
		String decision = getDecisionDescription(recognizer, dfa);
		String text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));
		String message = String.format(format, decision, text);
		recognizer.notifyErrorListeners(message);
	}",
L7413,L7392,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,void processParser(),org.antlr.v4.analysis.AnalysisPipeline.processParser()V,,,,,82,2,101,3,"protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}","protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}

			assert s.decision + 1 >= g.decisionLOOK.size();
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}",
L10037,L10036,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\codegen\model\LL1StarBlockSingleAlt.java,tool\src\org\antlr\v4\codegen\model\LL1StarBlockSingleAlt.java,"LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts)",org.antlr.v4.codegen.model.LL1StarBlockSingleAlt.<init>(Lorg/antlr/v4/codegen/OutputModelFactory;Lorg/antlr/v4/tool/ast/GrammarAST;Ljava/util/List;)V,,,,,42,2,53,3,"public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
		super(factory, starRoot, alts);

		StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;
		loopBackStateNumber = star.loopBackState.stateNumber;
		this.decision = star.decision;
		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
		IntervalSet enterLook = altLookSets[1];
		IntervalSet exitLook = altLookSets[2];
		loopExpr = addCodeForLoopLookaheadTempVar(enterLook);
	}","public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
		super(factory, starRoot, alts);

		StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;
		loopBackStateNumber = star.loopBackState.stateNumber;
		this.decision = star.decision;
		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
		assert altLookSets.length == 2;
		IntervalSet enterLook = altLookSets[0];
		IntervalSet exitLook = altLookSets[1];
		loopExpr = addCodeForLoopLookaheadTempVar(enterLook);
	}",
L3446,L3013,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\DefaultErrorStrategy.java,runtime\Java\src\org\antlr\v4\runtime\DefaultErrorStrategy.java,"int execATN(@NotNull CharStream input, @NotNull DFAState ds0)",org.antlr.v4.runtime.atn.LexerATNSimulator. execATN(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;,340,,359,,536,2,554,3,"public Token singleTokenDeletion(Parser recognizer) {
		int nextTokenType = recognizer.getInputStream().LA(2);
		IntervalSet expecting = getExpectedTokens(recognizer);
		if ( expecting.contains(nextTokenType) ) {
			reportUnwantedToken(recognizer);
			/*
			System.err.println(""recoverFromMismatchedToken deleting ""+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   "" since ""+((TokenStream)recognizer.getInputStream()).LT(2)+
							   "" is what we want"");
			*/
			recognizer.consume(); // simply delete extra token
			// we want to return the token we're actually matching
			Token matchedSymbol = recognizer.getCurrentToken();
			endErrorCondition(recognizer);  // we know current token is correct
			return matchedSymbol;
		}
		return null;
	}","protected Token singleTokenDeletion(@NotNull Parser recognizer) {
		int nextTokenType = recognizer.getInputStream().LA(2);
		IntervalSet expecting = getExpectedTokens(recognizer);
		if ( expecting.contains(nextTokenType) ) {
			reportUnwantedToken(recognizer);
			/*
			System.err.println(""recoverFromMismatchedToken deleting ""+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   "" since ""+((TokenStream)recognizer.getInputStream()).LT(2)+
							   "" is what we want"");
			*/
			recognizer.consume(); // simply delete extra token
			// we want to return the token we're actually matching
			Token matchedSymbol = recognizer.getCurrentToken();
			reportMatch(recognizer);  // we know current token is correct
			return matchedSymbol;
		}
		return null;
	}

@Override
	public void reportMatch(Parser recognizer) {
		endErrorCondition(recognizer);
	}",
L1927,L1833,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"int execATN(@NotNull CharStream input, @NotNull DFAState ds0)",org.antlr.v4.runtime.atn.LexerATNSimulator. execATN(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;,197,,282,,187,2,302,3,"protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {
		//System.out.println(""enter exec index ""+input.index()+"" from ""+ds0.configs);
		if ( debug ) {
			System.out.format(""start state closure=%s\n"", ds0.configs);
		}

		int t = input.LA(1);
		@NotNull
		DFAState s = ds0; // s is current/from DFA state

		while ( true ) { // while more work
			if ( debug ) {
				System.out.format(""execATN loop starting closure: %s\n"", s.configs);
			}

			// As we move src->trg, src->trg, we keep track of the previous trg to
			// avoid looking up the DFA state again, which is expensive.
			// If the previous target was already part of the DFA, we might
			// be able to avoid doing a reach operation upon t. If s!=null,
			// it means that semantic predicates didn't prevent us from
			// creating a DFA state. Once we know s!=null, we check to see if
			// the DFA state has an edge already for t. If so, we can just reuse
			// it's configuration set; there's no point in re-computing it.
			// This is kind of like doing DFA simulation within the ATN
			// simulation because DFA simulation is really just a way to avoid
			// computing reach/closure sets. Technically, once we know that
			// we have a previously added DFA state, we could jump over to
			// the DFA simulator. But, that would mean popping back and forth
			// a lot and making things more complicated algorithmically.
			// This optimization makes a lot of sense for loops within DFA.
			// A character will take us back to an existing DFA state
			// that already has lots of edges out of it. e.g., .* in comments.
			ATNConfigSet closure = s.configs;
			DFAState target = null;
			if ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {
				target = s.edges[t - MIN_DFA_EDGE];
				if (target == ERROR) {
					break;
				}

				if (debug && target != null) {
					System.out.println(""reuse state ""+s.stateNumber+
									   "" edge to ""+target.stateNumber);
				}
			}

			if (target == null) {
				ATNConfigSet reach = new OrderedATNConfigSet();

				// if we don't find an existing DFA state
				// Fill reach starting from closure, following t transitions
				getReachableConfigSet(input, closure, reach, t);

				if ( reach.isEmpty() ) { // we got nowhere on t from s
					// we reached state associated with closure for sure, so
					// make sure it's defined. worst case, we define s0 from
					// start state configs.
					@NotNull
					DFAState from = s != null ? s : addDFAState(closure);
					// we got nowhere on t, don't throw out this knowledge; it'd
					// cause a failover from DFA later.
					addDFAEdge(from, t, ERROR);
					break; // stop when we can't match any more char
				}

				// Add an edge from s to target DFA found/created for reach
				target = addDFAEdge(s, t, reach);
			}

			if (target.isAcceptState) {
				captureSimState(prevAccept, input, target);
				if (t == IntStream.EOF) {
					break;
				}
			}

			if (t != IntStream.EOF) {
				consume(input);
				t = input.LA(1);
			}

			s = target; // flip; current DFA target becomes new src/from state
		}

		return failOrAccept(prevAccept, input, s.configs, t);
	}","protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {
		//System.out.println(""enter exec index ""+input.index()+"" from ""+ds0.configs);
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""start state closure=%s\n"", ds0.configs);
		}

		int t = input.LA(1);
		@NotNull
		DFAState s = ds0; // s is current/from DFA state

		while ( true ) { // while more work
			if ( debug ) {
				System.out.format(Locale.getDefault(), ""execATN loop starting closure: %s\n"", s.configs);
			}

			// As we move src->trg, src->trg, we keep track of the previous trg to
			// avoid looking up the DFA state again, which is expensive.
			// If the previous target was already part of the DFA, we might
			// be able to avoid doing a reach operation upon t. If s!=null,
			// it means that semantic predicates didn't prevent us from
			// creating a DFA state. Once we know s!=null, we check to see if
			// the DFA state has an edge already for t. If so, we can just reuse
			// it's configuration set; there's no point in re-computing it.
			// This is kind of like doing DFA simulation within the ATN
			// simulation because DFA simulation is really just a way to avoid
			// computing reach/closure sets. Technically, once we know that
			// we have a previously added DFA state, we could jump over to
			// the DFA simulator. But, that would mean popping back and forth
			// a lot and making things more complicated algorithmically.
			// This optimization makes a lot of sense for loops within DFA.
			// A character will take us back to an existing DFA state
			// that already has lots of edges out of it. e.g., .* in comments.
			DFAState target = getExistingTargetState(s, t);
			if (target == null) {
				target = computeTargetState(input, s, t);
			}

			if (target == ERROR) {
				break;
			}

			if (target.isAcceptState) {
				captureSimState(prevAccept, input, target);
				if (t == IntStream.EOF) {
					break;
				}
			}

			if (t != IntStream.EOF) {
				consume(input);
				t = input.LA(1);
			}

			s = target; // flip; current DFA target becomes new src/from state
		}

		return failOrAccept(prevAccept, input, s.configs, t);
	}

	/**
	 * Get an existing target state for an edge in the DFA. If the target state
	 * for the edge has not yet been computed or is otherwise not available,
	 * this method returns {@code null}.
	 *
	 * @param s The current DFA state
	 * @param t The next input symbol
	 * @return The existing target DFA state for the given input symbol
	 * {@code t}, or {@code null} if the target state for this edge is not
	 * already cached
	 */
	@Nullable
	protected DFAState getExistingTargetState(@NotNull DFAState s, int t) {
		if (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {
			return null;
		}
		
		DFAState target = s.edges[t - MIN_DFA_EDGE];
		if (debug && target != null) {
			System.out.println(""reuse state ""+s.stateNumber+
							   "" edge to ""+target.stateNumber);
		}

		return target;
	}

	/**
	 * Compute a target state for an edge in the DFA, and attempt to add the
	 * computed state and corresponding edge to the DFA.
	 *
	 * @param input The input stream
	 * @param s The current DFA state
	 * @param t The next input symbol
	 *
	 * @return The computed target DFA state for the given input symbol
	 * {@code t}. If {@code t} does not lead to a valid DFA state, this method
	 * returns {@link #ERROR}.
	 */
	@NotNull
	protected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {
		ATNConfigSet reach = new OrderedATNConfigSet();

		// if we don't find an existing DFA state
		// Fill reach starting from closure, following t transitions
		getReachableConfigSet(input, s.configs, reach, t);

		if ( reach.isEmpty() ) { // we got nowhere on t from s
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			addDFAEdge(s, t, ERROR);
			// stop when we can't match any more char
			return ERROR;
		}

		// Add an edge from s to target DFA found/created for reach
		return addDFAEdge(s, t, reach);
	}",
L540,L515,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,ADD_PARAMETER,Introduce Parameter Object,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,"void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)",org.antlr.v4.runtime.ANTLRErrorListener.reportAmbiguity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,92,,95,,112,2,118,39,"void reportAmbiguity(@NotNull Parser recognizer,
						 DFA dfa, int startIndex, int stopIndex,
						 @NotNull BitSet ambigAlts,
						 @NotNull ATNConfigSet configs);","void reportAmbiguity(@NotNull Parser recognizer,
						 @NotNull DFA dfa,
						 int startIndex,
						 int stopIndex,
						 boolean exact,
						 @NotNull BitSet ambigAlts,
						 @NotNull ATNConfigSet configs);",
L561,L515,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,ADD_PARAMETER,Introduce Parameter Object,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,"void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs)",org.antlr.v4.runtime.ANTLRErrorListener.reportAttemptingFullContext(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IILjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,97,,100,,141,2,146,42,"void reportAttemptingFullContext(@NotNull Parser recognizer,
									 @NotNull DFA dfa,
									 int startIndex, int stopIndex,
									 @NotNull ATNConfigSet configs);","void reportAttemptingFullContext(@NotNull Parser recognizer,
									 @NotNull DFA dfa,
									 int startIndex,
									 int stopIndex,
									 @Nullable BitSet conflictingAlts,
									 @NotNull ATNConfigSet configs);",
L1114,L1049,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\ATNConfig.java,runtime\Java\src\org\antlr\v4\runtime\misc/MurmurHash.java,int hashCode(),org.antlr.v4.runtime.atn.ATNConfig.hashCode()I,256,,262,,162,2,170,3,"public int hashCode(ATNConfig o) {
			int hashCode = 7;
			hashCode = 31 * hashCode + o.state.stateNumber;
			hashCode = 31 * hashCode + o.alt;
			hashCode = 31 * hashCode + o.semanticContext.hashCode();
	        return hashCode;
		}","public int hashCode() {
		int hashCode = MurmurHash.initialize(7);
		hashCode = MurmurHash.update(hashCode, state.stateNumber);
		hashCode = MurmurHash.update(hashCode, alt);
		hashCode = MurmurHash.update(hashCode, context);
		hashCode = MurmurHash.update(hashCode, semanticContext);
		hashCode = MurmurHash.finish(hashCode, 4);
		return hashCode;
	}","public static int update(int hash, int value) {
		final int c1 = 0xCC9E2D51;
		final int c2 = 0x1B873593;
		final int r1 = 15;
		final int r2 = 13;
		final int m = 5;
		final int n = 0xE6546B64;

		int k = value;
		k = k * c1;
		k = (k << r1) | (k >>> (32 - r1));
		k = k * c2;

		hash = hash ^ k;
		hash = (hash << r2) | (hash >>> (32 - r2));
		hash = hash * m + n;

		return hash;
	}

	/**
	 * Update the intermediate hash value for the next input {@code value}.
	 *
	 * @param hash the intermediate hash value
	 * @param value the value to add to the current hash
	 * @return the updated intermediate hash value
	 */
	public static int update(int hash, Object value) {
		return update(hash, value != null ? value.hashCode() : 0);
	}"
L4884,L4876,,,junit,INLINE_TEMP,Inline Variable,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,void addFailure(Throwable targetException),org.junit.internal.runners.model.EachTestNotifier.addFailure(Ljava/lang/Throwable;)V,22,,30,,21,2,33,3,"public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			MultipleFailureException mfe= (MultipleFailureException) targetException;
			for (Throwable each : mfe.getFailures())
				addFailure(each);
			return;
		}
		fNotifier.fireTestFailure(new Failure(fDescription, targetException));
	}","public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			addMultipleFailureException((MultipleFailureException) targetException);
		} else {
			fNotifier
					.fireTestFailure(new Failure(fDescription, targetException));
		}
	}

	private void addMultipleFailureException(MultipleFailureException mfe) {
		for (Throwable each : mfe.getFailures())
			addFailure(each);
	}",
L7126,L6751,,,junit,INTRODUCE_ASSERTION,Introduce Assertion,src\test\java\org\junit\tests\experimental\categories\CategoryTest.java,src\test\java\org\junit\tests\experimental\categories\CategoryTest.java,void testCountWithExplicitFilter(),org.junit.tests.experimental.categories.CategoryTest.testCountWithExplicitFilter()V,128,,133,,129,2,135,3,"public void testCountWithExplicitFilter() throws Throwable {

		CategoryFilter include= CategoryFilter.include(SlowTests.class);

		Request baseRequest= Request.aClass(TestSuiteWithNoCategories.class);

		Result result= new JUnitCore().run(baseRequest.filterWith(include));

		assertTrue(result.wasSuccessful());

	}","
public void testCountWithExplicitFilter() throws Throwable {

		CategoryFilter include= CategoryFilter.include(SlowTests.class);

		Request baseRequest= Request.aClass(TestSuiteWithNoCategories.class);

		Result result= new JUnitCore().run(baseRequest.filterWith(include));

		assertTrue(result.wasSuccessful());

		assertEquals(2, result.getRunCount());

	}",
L5431,L543,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\Parser.java,runtime\Java\src\org\antlr\v4\runtime\Parser.java,void unrollRecursionContexts(ParserRuleContext _parentctx),org.antlr.v4.runtime.Parser.unrollRecursionContexts(Lorg/antlr/v4/runtime/ParserRuleContext;)V,481,2,498,3,593,2,615,3,"public void unrollRecursionContexts(ParserRuleContext _parentctx) {
		_ctx.stop = _input.LT(-1);
		ParserRuleContext retctx = _ctx; // save current ctx (return value)

		// unroll so _ctx is as it was before call to recursive method
		if ( _parseListeners != null ) {
			while ( _ctx != _parentctx ) {
				triggerExitRuleEvent();
				_ctx = (ParserRuleContext)_ctx.parent;
			}
		}
		else {
			_ctx = _parentctx;
		}
		// hook into tree
		retctx.parent = _parentctx;
		if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree
	}","public void unrollRecursionContexts(ParserRuleContext _parentctx) {
		_ctx.stop = _input.LT(-1);
		ParserRuleContext retctx = _ctx; // save current ctx (return value)

		// unroll so _ctx is as it was before call to recursive method
		if ( _parseListeners != null ) {
			while ( _ctx != _parentctx ) {
				triggerExitRuleEvent();
				_ctx = (ParserRuleContext)_ctx.parent;
			}
		}
		else {
			_ctx = _parentctx;
		}

		// hook into tree
		retctx.parent = _parentctx;

		if (_buildParseTrees && _parentctx != null) {
			// add return ctx into invoking rule's tree
			_parentctx.addChild(retctx);
		}
	}",
L3844,L3806,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\BufferedTokenStream.java,runtime\Java\src\org\antlr\v4\runtime\BufferedTokenStream.java,void consume(),org.antlr.v4.runtime.BufferedTokenStream.consume()V,132,2,157,3,132,5,157,6,"public void consume() {
		boolean skipEofCheck;
		if (p >= 0) {
			if (fetchedEOF) {
				// the last token in tokens is EOF. skip check if p indexes any
				// fetched token except the last.
				skipEofCheck = p < tokens.size() - 1;
			}
			else {
				// no EOF token in tokens. skip check if p indexes a fetched token.
				skipEofCheck = p < tokens.size();
			}
		}
		else {
			// not yet initialized
			skipEofCheck = false;
		}

		if (!skipEofCheck && LA(1) == EOF) {
			throw new IllegalStateException(""cannot consume EOF"");
		}

		if (sync(p + 1)) {
			p = adjustSeekIndex(p + 1);
		}
    }"," public void consume() {
		boolean skipEofCheck;
		if (p >= 0) {
			if (fetchedEOF) {
				// the last token in tokens is EOF. skip check if p indexes any
				// fetched token except the last.
				skipEofCheck = p < tokens.size() - 1;
			}
			else {
				// no EOF token in tokens. skip check if p indexes a fetched token.
				skipEofCheck = p < tokens.size();
			}
		}
		else {
			// not yet initialized
			skipEofCheck = false;
		}

		if (!skipEofCheck && LA(1) == EOF) {
			throw new IllegalStateException(""cannot consume EOF"");
		}

		if (sync(p + 1)) {
			p = adjustSeekIndex(p + 1);
		}
    }",
L3168,L3038,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,"ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx)",org.antlr.v4.runtime.atn.ParserATNSimulator.computeReachSet(Lorg/antlr/v4/runtime/atn/ATNConfigSet;IZ)Lorg/antlr/v4/runtime/atn/ATNConfigSet;,785,2,912,3,798,2,926,3,"protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
										   boolean fullCtx)
	{
		if ( debug ) System.out.println(""in computeReachSet, starting closure: "" + closure);

		if (mergeCache == null) {
			mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();
		}

		ATNConfigSet intermediate = new ATNConfigSet(fullCtx);

		/* Configurations already in a rule stop state indicate reaching the end
		 * of the decision rule (local context) or end of the start rule (full
		 * context). Once reached, these configurations are never updated by a
		 * closure operation, so they are handled separately for the performance
		 * advantage of having a smaller intermediate set when calling closure.
		 *
		 * For full-context reach operations, separate handling is required to
		 * ensure that the alternative matching the longest overall sequence is
		 * chosen when multiple such configurations can match the input.
		 */
		List<ATNConfig> skippedStopStates = null;

		// First figure out where we can reach on input t
		for (ATNConfig c : closure) {
			if ( debug ) System.out.println(""testing ""+getTokenName(t)+"" at ""+c.toString());

			if (c.state instanceof RuleStopState) {
				assert c.context.isEmpty();
				if (fullCtx || t == IntStream.EOF) {
					if (skippedStopStates == null) {
						skippedStopStates = new ArrayList<ATNConfig>();
					}

					skippedStopStates.add(c);
				}

				continue;
			}

			int n = c.state.getNumberOfTransitions();
			for (int ti=0; ti<n; ti++) {               // for each transition
				Transition trans = c.state.transition(ti);
				ATNState target = getReachableTarget(trans, t);
				if ( target!=null ) {
					intermediate.add(new ATNConfig(c, target), mergeCache);
				}
			}
		}

		// Now figure out where the reach operation can take us...

		ATNConfigSet reach = null;

		/* This block optimizes the reach operation for intermediate sets which
		 * trivially indicate a termination state for the overall
		 * adaptivePredict operation.
		 *
		 * The conditions assume that intermediate
		 * contains all configurations relevant to the reach set, but this
		 * condition is not true when one or more configurations have been
		 * withheld in skippedStopStates.
		 */
		if (skippedStopStates == null) {
			if ( intermediate.size()==1 ) {
				// Don't pursue the closure if there is just one state.
				// It can only have one alternative; just add to result
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
			else if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
		}

		/* If the reach set could not be trivially determined, perform a closure
		 * operation on the intermediate set to compute its initial value.
		 */
		if (reach == null) {
			reach = new ATNConfigSet(fullCtx);
			Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();
			for (ATNConfig c : intermediate) {
				closure(c, reach, closureBusy, false, fullCtx);
			}
		}

		if (t == IntStream.EOF) {
			/* After consuming EOF no additional input is possible, so we are
			 * only interested in configurations which reached the end of the
			 * decision rule (local context) or end of the start rule (full
			 * context). Update reach to contain only these configurations. This
			 * handles both explicit EOF transitions in the grammar and implicit
			 * EOF transitions following the end of the decision or start rule.
			 *
			 * When reach==intermediate, no closure operation was performed. In
			 * this case, removeAllConfigsNotInRuleStopState needs to check for
			 * reachable rule stop states as well as configurations already in
			 * a rule stop state.
			 *
			 * This is handled before the configurations in skippedStopStates,
			 * because any configurations potentially added from that list are
			 * already guaranteed to meet this condition whether or not it's
			 * required.
			 */
			reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);
		}

		/* If skippedStopStates is not null, then it contains at least one
		 * configuration. For full-context reach operations, these
		 * configurations reached the end of the start rule, in which case we
		 * only add them back to reach if no configuration during the current
		 * closure operation reached such a state. This ensures adaptivePredict
		 * chooses an alternative matching the longest overall sequence when
		 * multiple alternatives are viable.
		 */
		if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
			assert !skippedStopStates.isEmpty();
			for (ATNConfig c : skippedStopStates) {
				reach.add(c, mergeCache);
			}
		}

		if ( reach.isEmpty() ) return null;
		return reach;
	}","protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
										   boolean fullCtx)
	{
		if ( debug ) System.out.println(""in computeReachSet, starting closure: "" + closure);

		if (mergeCache == null) {
			mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();
		}

		ATNConfigSet intermediate = new ATNConfigSet(fullCtx);

		/* Configurations already in a rule stop state indicate reaching the end
		 * of the decision rule (local context) or end of the start rule (full
		 * context). Once reached, these configurations are never updated by a
		 * closure operation, so they are handled separately for the performance
		 * advantage of having a smaller intermediate set when calling closure.
		 *
		 * For full-context reach operations, separate handling is required to
		 * ensure that the alternative matching the longest overall sequence is
		 * chosen when multiple such configurations can match the input.
		 */
		List<ATNConfig> skippedStopStates = null;

		// First figure out where we can reach on input t
		for (ATNConfig c : closure) {
			if ( debug ) System.out.println(""testing ""+getTokenName(t)+"" at ""+c.toString());

			if (c.state instanceof RuleStopState) {
				assert c.context.isEmpty();
				if (fullCtx || t == IntStream.EOF) {
					if (skippedStopStates == null) {
						skippedStopStates = new ArrayList<ATNConfig>();
					}

					skippedStopStates.add(c);
				}

				continue;
			}

			int n = c.state.getNumberOfTransitions();
			for (int ti=0; ti<n; ti++) {               // for each transition
				Transition trans = c.state.transition(ti);
				ATNState target = getReachableTarget(trans, t);
				if ( target!=null ) {
					intermediate.add(new ATNConfig(c, target), mergeCache);
				}
			}
		}

		// Now figure out where the reach operation can take us...

		ATNConfigSet reach = null;

		/* This block optimizes the reach operation for intermediate sets which
		 * trivially indicate a termination state for the overall
		 * adaptivePredict operation.
		 *
		 * The conditions assume that intermediate
		 * contains all configurations relevant to the reach set, but this
		 * condition is not true when one or more configurations have been
		 * withheld in skippedStopStates, or when the current symbol is EOF.
		 */
		if (skippedStopStates == null && t != Token.EOF) {
			if ( intermediate.size()==1 ) {
				// Don't pursue the closure if there is just one state.
				// It can only have one alternative; just add to result
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
			else if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
		}

		/* If the reach set could not be trivially determined, perform a closure
		 * operation on the intermediate set to compute its initial value.
		 */
		if (reach == null) {
			reach = new ATNConfigSet(fullCtx);
			Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();
			boolean treatEofAsEpsilon = t == Token.EOF;
			for (ATNConfig c : intermediate) {
				closure(c, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
			}
		}

		if (t == IntStream.EOF) {
			/* After consuming EOF no additional input is possible, so we are
			 * only interested in configurations which reached the end of the
			 * decision rule (local context) or end of the start rule (full
			 * context). Update reach to contain only these configurations. This
			 * handles both explicit EOF transitions in the grammar and implicit
			 * EOF transitions following the end of the decision or start rule.
			 *
			 * When reach==intermediate, no closure operation was performed. In
			 * this case, removeAllConfigsNotInRuleStopState needs to check for
			 * reachable rule stop states as well as configurations already in
			 * a rule stop state.
			 *
			 * This is handled before the configurations in skippedStopStates,
			 * because any configurations potentially added from that list are
			 * already guaranteed to meet this condition whether or not it's
			 * required.
			 */
			reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);
		}

		/* If skippedStopStates is not null, then it contains at least one
		 * configuration. For full-context reach operations, these
		 * configurations reached the end of the start rule, in which case we
		 * only add them back to reach if no configuration during the current
		 * closure operation reached such a state. This ensures adaptivePredict
		 * chooses an alternative matching the longest overall sequence when
		 * multiple alternatives are viable.
		 */
		if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
			assert !skippedStopStates.isEmpty();
			for (ATNConfig c : skippedStopStates) {
				reach.add(c, mergeCache);
			}
		}

		if ( reach.isEmpty() ) return null;
		return reach;
	}",
L10263,L10252,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,tool\src\org\antlr\v4\automata\ATNPrinter.java,tool\src\org\antlr\v4\automata\ATNPrinter.java,String asString(),org.antlr.v4.automata.ATNPrinter.asString()Ljava/lang/String;,69,2,123,3,69,2,123,3,"public String asString() {
		if ( start==null ) return null;
		marked = new HashSet<ATNState>();

		work = new ArrayList<ATNState>();
		work.add(start);

		StringBuilder buf = new StringBuilder();
		ATNState s;

		while ( !work.isEmpty() ) {
			s = work.remove(0);
			if ( marked.contains(s) ) continue;
			int n = s.getNumberOfTransitions();
//			System.out.println(""visit ""+s+""; edges=""+n);
			marked.add(s);
			for (int i=0; i<n; i++) {
				Transition t = s.transition(i);
				if ( !(s instanceof RuleStopState) ) { // don't add follow states to work
					if ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);
					else work.add( t.target );
				}
				buf.append(getStateString(s));
				if ( t instanceof EpsilonTransition ) {
					buf.append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof RuleTransition ) {
					buf.append(""-"").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof ActionTransition ) {
					ActionTransition a = (ActionTransition)t;
					buf.append(""-"").append(a.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof SetTransition ) {
					SetTransition st = (SetTransition)t;
					boolean not = st instanceof NotSetTransition;
					if ( g.isLexer() ) {
						buf.append(""-"").append(not?""~"":"""").append(st.toString()).append(""->"").append(getStateString(t.target)).append('\n');
					}
					else {
						buf.append(""-"").append(not?""~"":"""").append(st.label().toString(g.getTokenNames())).append(""->"").append(getStateString(t.target)).append('\n');
					}
				}
				else if ( t instanceof AtomTransition ) {
					AtomTransition a = (AtomTransition)t;
					String label = g.getTokenDisplayName(a.label);
					buf.append(""-"").append(label).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else {
					buf.append(""-"").append(t.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
			}
		}
		return buf.toString();
	}","public String asString() {
		if ( start==null ) return null;
		marked = new HashSet<ATNState>();

		work = new ArrayList<ATNState>();
		work.add(start);

		StringBuilder buf = new StringBuilder();
		ATNState s;

		while ( !work.isEmpty() ) {
			s = work.remove(0);
			if ( marked.contains(s) ) continue;
			int n = s.getNumberOfTransitions();
//			System.out.println(""visit ""+s+""; edges=""+n);
			marked.add(s);
			for (int i=0; i<n; i++) {
				Transition t = s.transition(i);
				if ( !(s instanceof RuleStopState) ) { // don't add follow states to work
					if ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);
					else work.add( t.target );
				}
				buf.append(getStateString(s));
				if ( t instanceof EpsilonTransition ) {
					buf.append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof RuleTransition ) {
					buf.append(""-"").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof ActionTransition ) {
					ActionTransition a = (ActionTransition)t;
					buf.append(""-"").append(a.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof SetTransition ) {
					SetTransition st = (SetTransition)t;
					boolean not = st instanceof NotSetTransition;
					if ( g.isLexer() ) {
						buf.append(""-"").append(not?""~"":"""").append(st.toString()).append(""->"").append(getStateString(t.target)).append('\n');
					}
					else {
						buf.append(""-"").append(not?""~"":"""").append(st.label().toString(g.getTokenDisplayNames())).append(""->"").append(getStateString(t.target)).append('\n');
					}
				}
				else if ( t instanceof AtomTransition ) {
					AtomTransition a = (AtomTransition)t;
					String label = g.getTokenDisplayName(a.label);
					buf.append(""-"").append(label).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else {
					buf.append(""-"").append(t.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
			}
		}
		return buf.toString();
	}",
L10263,L10252,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,tool\src\org\antlr\v4\automata\ATNPrinter.java,tool\src\org\antlr\v4\automata\ATNPrinter.java,String getStateString(ATNState s),org.antlr.v4.automata.ATNPrinter.getStateString()Ljava/lang/String;,125,2,138,3,125,2,138,3,"String getStateString(ATNState s) {
		int n = s.stateNumber;
		String stateStr = ""s""+n;
		if ( s instanceof StarBlockStartState ) stateStr = ""StarBlockStart_""+n;
		else if ( s instanceof PlusBlockStartState ) stateStr = ""PlusBlockStart_""+n;
		else if ( s instanceof BlockStartState) stateStr = ""BlockStart_""+n;
		else if ( s instanceof BlockEndState ) stateStr = ""BlockEnd_""+n;
		else if ( s instanceof RuleStartState) stateStr = ""RuleStart_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof RuleStopState ) stateStr = ""RuleStop_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof PlusLoopbackState) stateStr = ""PlusLoopBack_""+n;
		else if ( s instanceof StarLoopbackState) stateStr = ""StarLoopBack_""+n;
		else if ( s instanceof StarLoopEntryState) stateStr = ""StarLoopEntry_""+n;
		return stateStr;
	}","String getStateString(ATNState s) {
		int n = s.stateNumber;
		String stateStr = ""s""+n;
		if ( s instanceof StarBlockStartState ) stateStr = ""StarBlockStart_""+n;
		else if ( s instanceof PlusBlockStartState ) stateStr = ""PlusBlockStart_""+n;
		else if ( s instanceof BlockStartState) stateStr = ""BlockStart_""+n;
		else if ( s instanceof BlockEndState ) stateStr = ""BlockEnd_""+n;
		else if ( s instanceof RuleStartState) stateStr = ""RuleStart_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof RuleStopState ) stateStr = ""RuleStop_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof PlusLoopbackState) stateStr = ""PlusLoopBack_""+n;
		else if ( s instanceof StarLoopbackState) stateStr = ""StarLoopBack_""+n;
		else if ( s instanceof StarLoopEntryState) stateStr = ""StarLoopEntry_""+n;
		return stateStr;
	}",
L15668,L14958,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,tool\src\org\antlr\v4\tool\DOTGenerator.java,tool\src\org\antlr\v4\tool\DOTGenerator.java,"String getDOT(DFA dfa, boolean isLexer)",org.antlr.v4.tool.DOTGenerator.getDOT(Lorg/antlr/v4/runtime/dfa/DFA;Z)Ljava/lang/String;,83,2,132,3,83,2,132,3,"public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}","public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}",
L15668,L14958,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,tool\src\org\antlr\v4\tool\DOTGenerator.java,tool\src\org\antlr\v4\tool\DOTGenerator.java,"String getDOT(DFA dfa, boolean isLexer)",org.antlr.v4.tool.DOTGenerator.getDOT(Lorg/antlr/v4/runtime/dfa/DFA;Z)Ljava/lang/String;,83,2,132,3,83,2,132,3,"public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}","public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}",
L3347,L3055,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,e1e12f0b419461c4fc63461a2776024ad9f4fd54,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,"void closure_(ATNConfig config, ATNConfigSet configs, Set<ATNConfig> closureBusy, boolean collectPredicates, boolean fullCtx, int depth, boolean treatEofAsEpsilon)",org.antlr.v4.runtime.atn.ParserATNSimulator.closure_(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/Set;ZZIZ)V,1436,2,1496,3,1550,2,1617,3,"protected void closure_(@NotNull ATNConfig config,
							@NotNull ATNConfigSet configs,
							@NotNull Set<ATNConfig> closureBusy,
							boolean collectPredicates,
							boolean fullCtx,
							int depth,
							boolean treatEofAsEpsilon)
	{
		ATNState p = config.state;
		// optimization
		if ( !p.onlyHasEpsilonTransitions() ) {
            configs.add(config, mergeCache);
			// make sure to not return here, because EOF transitions can act as
			// both epsilon transitions and non-epsilon transitions.
//            if ( debug ) System.out.println(""added config ""+configs);
        }

		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			boolean continueCollecting =
				!(t instanceof ActionTransition) && collectPredicates;
			ATNConfig c = getEpsilonTarget(config, t, continueCollecting,
										   depth == 0, fullCtx, treatEofAsEpsilon);
			if ( c!=null ) {
				if (!t.isEpsilon() && !closureBusy.add(c)) {
					// avoid infinite recursion for EOF* and EOF+
					continue;
				}

				int newDepth = depth;
				if ( config.state instanceof RuleStopState) {
					assert !fullCtx;
					// target fell off end of rule; mark resulting c as having dipped into outer context
					// We can't get here if incoming config was rule stop and we had context
					// track how far we dip into outer context.  Might
					// come in handy and we avoid evaluating context dependent
					// preds if this is > 0.

					if (!closureBusy.add(c)) {
						// avoid infinite recursion for right-recursive rules
						continue;
					}

					c.reachesIntoOuterContext++;
					configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
					assert newDepth > Integer.MIN_VALUE;
					newDepth--;
					if ( debug ) System.out.println(""dips into outer ctx: ""+c);
				}
				else if (t instanceof RuleTransition) {
					// latch when newDepth goes negative - once we step out of the entry context we can't return
					if (newDepth >= 0) {
						newDepth++;
					}
				}

				closureCheckingStopState(c, configs, closureBusy, continueCollecting,
										 fullCtx, newDepth, treatEofAsEpsilon);
			}
		}
	}","protected void closure_(ATNConfig config,
							ATNConfigSet configs,
							Set<ATNConfig> closureBusy,
							boolean collectPredicates,
							boolean fullCtx,
							int depth,
							boolean treatEofAsEpsilon)
	{
		ATNState p = config.state;
		// optimization
		if ( !p.onlyHasEpsilonTransitions() ) {
            configs.add(config, mergeCache);
			// make sure to not return here, because EOF transitions can act as
			// both epsilon transitions and non-epsilon transitions.
//            if ( debug ) System.out.println(""added config ""+configs);
        }

		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			boolean continueCollecting =
				!(t instanceof ActionTransition) && collectPredicates;
			ATNConfig c = getEpsilonTarget(config, t, continueCollecting,
										   depth == 0, fullCtx, treatEofAsEpsilon);
			if ( c!=null ) {
				if (!t.isEpsilon() && !closureBusy.add(c)) {
					// avoid infinite recursion for EOF* and EOF+
					continue;
				}

				int newDepth = depth;
				if ( config.state instanceof RuleStopState) {
					assert !fullCtx;
					// target fell off end of rule; mark resulting c as having dipped into outer context
					// We can't get here if incoming config was rule stop and we had context
					// track how far we dip into outer context.  Might
					// come in handy and we avoid evaluating context dependent
					// preds if this is > 0.

					if (!closureBusy.add(c)) {
						// avoid infinite recursion for right-recursive rules
						continue;
					}

					if (_dfa != null && _dfa.isPrecedenceDfa()) {
						int outermostPrecedenceReturn = ((EpsilonTransition)t).outermostPrecedenceReturn();
						if (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {
							c.setPrecedenceFilterSuppressed(true);
						}
					}

					c.reachesIntoOuterContext++;
					configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
					assert newDepth > Integer.MIN_VALUE;
					newDepth--;
					if ( debug ) System.out.println(""dips into outer ctx: ""+c);
				}
				else if (t instanceof RuleTransition) {
					// latch when newDepth goes negative - once we step out of the entry context we can't return
					if (newDepth >= 0) {
						newDepth++;
					}
				}

				closureCheckingStopState(c, configs, closureBusy, continueCollecting,
										 fullCtx, newDepth, treatEofAsEpsilon);
			}
		}
	}",
L2755,L1039,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,"void _LOOK(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, Set<ATNConfig> lookBusy, BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF)",org.antlr.v4.runtime.atn.LL1Analyzer._LOOK(Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/misc/IntervalSet;Ljava/util/Set;Ljava/util/BitSet;ZZ)V,166,5,262,3,166,5,262,3," protected void _LOOK(@NotNull ATNState s,
						 @Nullable ATNState stopState,
						 @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 @NotNull BitSet calledRuleStack,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

		if (s == stopState) {
			if (ctx == null) {
				look.add(Token.EPSILON);
				return;
			} else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}
		}

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (int i = 0; i < ctx.size(); i++) {
					ATNState returnState = atn.states.get(ctx.getReturnState(i));
//					System.out.println(""popping back to ""+retState);

					boolean removed = calledRuleStack.get(returnState.ruleIndex);
					try {
						calledRuleStack.clear(returnState.ruleIndex);
						_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
					}
					finally {
						if (removed) {
							calledRuleStack.set(returnState.ruleIndex);
						}
					}
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				if (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {
					continue;
				}

				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);

				try {
					calledRuleStack.set(((RuleTransition)t).target.ruleIndex);
					_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				finally {
					calledRuleStack.clear(((RuleTransition)t).target.ruleIndex);
				}
			}
			else if ( t instanceof PredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}"," protected void _LOOK(@NotNull ATNState s,
						 @Nullable ATNState stopState,
						 @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 @NotNull BitSet calledRuleStack,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

		if (s == stopState) {
			if (ctx == null) {
				look.add(Token.EPSILON);
				return;
			} else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}
		}

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (int i = 0; i < ctx.size(); i++) {
					ATNState returnState = atn.states.get(ctx.getReturnState(i));
//					System.out.println(""popping back to ""+retState);

					boolean removed = calledRuleStack.get(returnState.ruleIndex);
					try {
						calledRuleStack.clear(returnState.ruleIndex);
						_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
					}
					finally {
						if (removed) {
							calledRuleStack.set(returnState.ruleIndex);
						}
					}
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				if (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {
					continue;
				}

				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);

				try {
					calledRuleStack.set(((RuleTransition)t).target.ruleIndex);
					_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				finally {
					calledRuleStack.clear(((RuleTransition)t).target.ruleIndex);
				}
			}
			else if ( t instanceof AbstractPredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}",
L13228,L13220,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,tool\src\org\antlr\v4\parse\TokenVocabParser.java,tool\src\org\antlr\v4\parse\TokenVocabParser.java,"Map<String, Integer> load()",org.antlr.v4.parse.TokenVocabParser.load()Ljava/util/Map;,58,2,106,3,59,2,123,3,"public Map<String,Integer> load() {
		Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();
		int maxTokenType = -1;
		File fullFile = getImportedVocabFile();
		try {
			Pattern tokenDefPattern = Pattern.compile(""([^\n]+?)[ \\t]*?=[ \\t]*?([0-9]+)"");
			FileReader fr = new FileReader(fullFile);
			BufferedReader br = new BufferedReader(fr);
			String tokenDef = br.readLine();
			int lineNum = 1;
			while ( tokenDef!=null ) {
				Matcher matcher = tokenDefPattern.matcher(tokenDef);
				if ( matcher.find() ) {
					String tokenID = matcher.group(1);
					String tokenTypeS = matcher.group(2);
					int tokenType = Integer.valueOf(tokenTypeS);
					tool.log(""grammar"", ""import ""+tokenID+""=""+tokenType);
					tokens.put(tokenID, tokenType);
					maxTokenType = Math.max(maxTokenType,tokenType);
					lineNum++;
				}
				else {
					if ( tokenDef.length()>0 ) { // ignore blank lines
						tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,
											  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
											  "" bad token def: ""+tokenDef,
											  lineNum);
					}
				}
				tokenDef = br.readLine();
			}
			br.close();
		}
		catch (FileNotFoundException fnfe) {
			tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,
								  fullFile);
		}
		catch (IOException ioe) {
			tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
								  fullFile,
								  ioe);
		}
		catch (Exception e) {
			tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
								  fullFile,
								  e);
		}
		return tokens;
	}","public Map<String,Integer> load() {
		Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();
		int maxTokenType = -1;
		File fullFile = getImportedVocabFile();
		FileReader fr = null;
		BufferedReader br = null;
		try {
			Pattern tokenDefPattern = Pattern.compile(""([^\n]+?)[ \\t]*?=[ \\t]*?([0-9]+)"");
			fr = new FileReader(fullFile);
			br = new BufferedReader(fr);
			String tokenDef = br.readLine();
			int lineNum = 1;
			while ( tokenDef!=null ) {
				Matcher matcher = tokenDefPattern.matcher(tokenDef);
				if ( matcher.find() ) {
					String tokenID = matcher.group(1);
					String tokenTypeS = matcher.group(2);
					int tokenType;
					try {
						tokenType = Integer.valueOf(tokenTypeS);
					}
					catch (NumberFormatException nfe) {
						tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,
											  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
											  "" bad token type: ""+tokenTypeS,
											  lineNum);
						tokenType = Token.INVALID_TOKEN_TYPE;
					}
					tool.log(""grammar"", ""import ""+tokenID+""=""+tokenType);
					tokens.put(tokenID, tokenType);
					maxTokenType = Math.max(maxTokenType,tokenType);
					lineNum++;
				}
				else {
					if ( tokenDef.length()>0 ) { // ignore blank lines
						tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,
											  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
											  "" bad token def: ""+tokenDef,
											  lineNum);
					}
				}
				tokenDef = br.readLine();
			}
		}
		catch (FileNotFoundException fnfe) {
			tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,
								  fullFile);
		}
		catch (Exception e) {
			tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
								  fullFile,
								  e);
		}
		finally {
			try {
				if ( br!=null ) br.close();
			}
			catch (IOException ioe) {
				tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
									  fullFile,
									  ioe);
			}
		}
		return tokens;
	}",
L8024,L7991,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,tool\src\org\antlr\v4\automata\ATNSerializer.java,tool\src\org\antlr\v4\automata\ATNSerializer.java,String decode(char[] data),org.antlr.v4.automata.ATNSerializer.decode([C)Ljava/lang/String;,273,2,361,3,334,2,444,3,"public String decode(char[] data) {
		data = data.clone();
		// don't adjust the first value since that's the version number
		for (int i = 1; i < data.length; i++) {
			data[i] = (char)(data[i] - 2);
		}

		StringBuilder buf = new StringBuilder();
		int p = 0;
		int version = ATNSimulator.toInt(data[p++]);
		if (version != ATNSimulator.SERIALIZED_VERSION) {
			String reason = String.format(""Could not deserialize ATN with version %d (expected %d)."", version, ATNSimulator.SERIALIZED_VERSION);
			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
		}

		int grammarType = ATNSimulator.toInt(data[p++]);
		int maxType = ATNSimulator.toInt(data[p++]);
		buf.append(""max type "").append(maxType).append(""\n"");
		int nstates = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=nstates; i++) {
			int stype = ATNSimulator.toInt(data[p++]);
            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states
			int ruleIndex = ATNSimulator.toInt(data[p++]);
			String arg = """";
			if ( stype == ATNState.LOOP_END ) {
				int loopBackStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+loopBackStateNumber;
			}
			else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {
				int endStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+endStateNumber;
			}
			buf.append(i - 1).append("":"")
				.append(ATNState.serializationNames.get(stype)).append("" "")
				.append(ruleIndex).append(arg).append(""\n"");
		}
		int numNonGreedyStates = ATNSimulator.toInt(data[p++]);
		for (int i = 0; i < numNonGreedyStates; i++) {
			int stateNumber = ATNSimulator.toInt(data[p++]);
		}
		int nrules = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nrules; i++) {
			int s = ATNSimulator.toInt(data[p++]);
            if ( g.isLexer() ) {
                int arg1 = ATNSimulator.toInt(data[p++]);
                int arg2 = ATNSimulator.toInt(data[p++]);
                buf.append(""rule "").append(i).append("":"").append(s).append("" "").append(arg1).append("","").append(arg2).append('\n');
            }
            else {
                buf.append(""rule "").append(i).append("":"").append(s).append('\n');
            }
		}
		int nmodes = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nmodes; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(""mode "").append(i).append("":"").append(s).append('\n');
		}
		int nsets = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=nsets; i++) {
			int nintervals = ATNSimulator.toInt(data[p++]);
			buf.append(i-1).append("":"");
			for (int j=1; j<=nintervals; j++) {
				if ( j>1 ) buf.append("", "");
				buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append("".."").append(getTokenName(ATNSimulator.toInt(data[p + 1])));
				p += 2;
			}
			buf.append(""\n"");
		}
		int nedges = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=nedges; i++) {
			int src = ATNSimulator.toInt(data[p]);
			int trg = ATNSimulator.toInt(data[p + 1]);
			int ttype = ATNSimulator.toInt(data[p + 2]);
			int arg1 = ATNSimulator.toInt(data[p + 3]);
			int arg2 = ATNSimulator.toInt(data[p + 4]);
			int arg3 = ATNSimulator.toInt(data[p + 5]);
			buf.append(src).append(""->"").append(trg)
				.append("" "").append(Transition.serializationNames.get(ttype))
				.append("" "").append(arg1).append("","").append(arg2).append("","").append(arg3)
				.append(""\n"");
			p += 6;
		}
		int ndecisions = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=ndecisions; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(i-1).append("":"").append(s).append(""\n"");
		}
		return buf.toString();
	}","public String decode(char[] data) {
		data = data.clone();
		// don't adjust the first value since that's the version number
		for (int i = 1; i < data.length; i++) {
			data[i] = (char)(data[i] - 2);
		}

		StringBuilder buf = new StringBuilder();
		int p = 0;
		int version = ATNSimulator.toInt(data[p++]);
		if (version != ATNSimulator.SERIALIZED_VERSION) {
			String reason = String.format(""Could not deserialize ATN with version %d (expected %d)."", version, ATNSimulator.SERIALIZED_VERSION);
			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
		}

		UUID uuid = ATNSimulator.toUUID(data, p);
		p += 8;
		if (!uuid.equals(ATNSimulator.SERIALIZED_UUID)) {
			String reason = String.format(Locale.getDefault(), ""Could not deserialize ATN with UUID %s (expected %s)."", uuid, ATNSimulator.SERIALIZED_UUID);
			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
		}

		int grammarType = ATNSimulator.toInt(data[p++]);
		int maxType = ATNSimulator.toInt(data[p++]);
		buf.append(""max type "").append(maxType).append(""\n"");
		int nstates = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nstates; i++) {
			int stype = ATNSimulator.toInt(data[p++]);
            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states
			int ruleIndex = ATNSimulator.toInt(data[p++]);
			if (ruleIndex == Character.MAX_VALUE) {
				ruleIndex = -1;
			}

			String arg = """";
			if ( stype == ATNState.LOOP_END ) {
				int loopBackStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+loopBackStateNumber;
			}
			else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {
				int endStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+endStateNumber;
			}
			buf.append(i).append("":"")
				.append(ATNState.serializationNames.get(stype)).append("" "")
				.append(ruleIndex).append(arg).append(""\n"");
		}
		int numNonGreedyStates = ATNSimulator.toInt(data[p++]);
		for (int i = 0; i < numNonGreedyStates; i++) {
			int stateNumber = ATNSimulator.toInt(data[p++]);
		}
		int nrules = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nrules; i++) {
			int s = ATNSimulator.toInt(data[p++]);
            if ( g.isLexer() ) {
                int arg1 = ATNSimulator.toInt(data[p++]);
                int arg2 = ATNSimulator.toInt(data[p++]);
				if (arg2 == Character.MAX_VALUE) {
					arg2 = -1;
				}
                buf.append(""rule "").append(i).append("":"").append(s).append("" "").append(arg1).append("","").append(arg2).append('\n');
            }
            else {
                buf.append(""rule "").append(i).append("":"").append(s).append('\n');
            }
		}
		int nmodes = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nmodes; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(""mode "").append(i).append("":"").append(s).append('\n');
		}
		int nsets = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nsets; i++) {
			int nintervals = ATNSimulator.toInt(data[p++]);
			buf.append(i).append("":"");
			boolean containsEof = data[p++] != 0;
			if (containsEof) {
				buf.append(getTokenName(Token.EOF));
			}

			for (int j=0; j<nintervals; j++) {
				if ( containsEof || j>0 ) {
					buf.append("", "");
				}

				buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append("".."").append(getTokenName(ATNSimulator.toInt(data[p + 1])));
				p += 2;
			}
			buf.append(""\n"");
		}
		int nedges = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nedges; i++) {
			int src = ATNSimulator.toInt(data[p]);
			int trg = ATNSimulator.toInt(data[p + 1]);
			int ttype = ATNSimulator.toInt(data[p + 2]);
			int arg1 = ATNSimulator.toInt(data[p + 3]);
			int arg2 = ATNSimulator.toInt(data[p + 4]);
			int arg3 = ATNSimulator.toInt(data[p + 5]);
			buf.append(src).append(""->"").append(trg)
				.append("" "").append(Transition.serializationNames.get(ttype))
				.append("" "").append(arg1).append("","").append(arg2).append("","").append(arg3)
				.append(""\n"");
			p += 6;
		}
		int ndecisions = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<ndecisions; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(i).append("":"").append(s).append(""\n"");
		}
		return buf.toString();
	}",
L9806,L8817,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Consolidate Duplicate Conditional Fragments,tool\src\org\antlr\v4\codegen\ParserFactory.java,tool\src\org\antlr\v4\codegen\ParserFactory.java,"void defineImplicitLabel(GrammarAST ast, LabeledOp op)",org.antlr.v4.codegen.ParserFactory.defineImplicitLabel(Lorg/antlr/v4/tool/ast/GrammarAST;Lorg/antlr/v4/codegen/model/LabeledOp;)V,330,2,354,3,334,2,358,3,"public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {
		Decl d;
		if ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {
			String implLabel =
				gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		else if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?
			Rule r = g.getRule(ast.getText());
			String implLabel = gen.target.getImplicitRuleLabel(ast.getText());
			String ctxName =
				gen.target.getRuleFunctionContextStructName(r);
			d = new RuleContextDecl(this, implLabel, ctxName);
			((RuleContextDecl)d).isImplicit = true;
		}
		else {
			String implLabel = gen.target.getImplicitTokenLabel(ast.getText());
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		op.getLabels().add(d);
		// all labels must be in scope struct in case we exec action out of context
		getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);
	}","public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {
		Decl d;
		if ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {
			String implLabel =
				gen.getTarget().getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		else if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?
			Rule r = g.getRule(ast.getText());
			String implLabel = gen.getTarget().getImplicitRuleLabel(ast.getText());
			String ctxName =
				gen.getTarget().getRuleFunctionContextStructName(r);
			d = new RuleContextDecl(this, implLabel, ctxName);
			((RuleContextDecl)d).isImplicit = true;
		}
		else {
			String implLabel = gen.getTarget().getImplicitTokenLabel(ast.getText());
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		op.getLabels().add(d);
		// all labels must be in scope struct in case we exec action out of context
		getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);
	}",
L1506,L807,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\atn\ATNState.java,runtime\Java\src\org\antlr\v4\runtime\atn\ATNState.java,void addTransition(Transition e),org.antlr.v4.runtime.atn.ATNState.addTransition(Lorg/antlr/v4/runtime/atn/Transition;)V,180,2,190,3,181,2,183,3,"public void addTransition(Transition e) {
		if (transitions.isEmpty()) {
			epsilonOnlyTransitions = e.isEpsilon();
		}
		else if (epsilonOnlyTransitions != e.isEpsilon()) {
			System.err.format(""ATN state %d has both epsilon and non-epsilon transitions.\n"", stateNumber);
			epsilonOnlyTransitions = false;
		}

		transitions.add(e);
	}","public void addTransition(Transition e) {
		addTransition(transitions.size(), e);
	}

	public void addTransition(int index, Transition e) {
		if (transitions.isEmpty()) {
			epsilonOnlyTransitions = e.isEpsilon();
		}
		else if (epsilonOnlyTransitions != e.isEpsilon()) {
			System.err.format(Locale.getDefault(), ""ATN state %d has both epsilon and non-epsilon transitions.\n"", stateNumber);
			epsilonOnlyTransitions = false;
		}

		transitions.add(index, e);
	}",
