{
    "EXTRACT FUNCTION": {
        "Mechanics": "Create a new function, and name it after the intent of the function (name it by whatit does, not by how it does it).If the code I want to extract is very simple, such as a single function call, I stillextract it if the name of the new function will reveal the intent of the code in a betterway. If I can\u2019t come up with a more meaningful name, that\u2019s a sign that I shouldn\u2019textract the code. However, I don\u2019t have to come up with the best name right away;sometimes a good name only appears as I work with the extraction. It\u2019s OK toextract a function, try to work with it, realize it isn\u2019t helping, and then inline it backagain. As long as I\u2019ve learned something, my time wasn\u2019t wasted.If the language supports nested functions, nest the extracted function inside thesource function. That will reduce the amount of out\u00adof\u00adscope variables to deal withafter the next couple of steps. I can always use Move Function (198) later.Copy the extracted code from the source function into the new target function.Scan the extracted code for references to any variables that are local in scope to thesource function and will not be in scope for the extracted function. Pass them asparameters.If I extract into a nested function of the source function, I don\u2019t run into theseproblems.Usually, these are local variables and parameters to the function. The most generalapproach is to pass all such parameters in as arguments. There are usually nodifficulties for variables that are used but not assigned to.If a variable is only used inside the extracted code but is declared outside, move thedeclaration into the extracted code.Any variables that are assigned to need more care if they are passed by value. Ifthere\u2019s only one of them, I try to treat the extracted code as a query and assign theresult to the variable concerned.Sometimes, I find that too many local variables are being assigned by the extractedcode. It\u2019s better to abandon the extraction at this point. When this happens, Iconsider other refactorings such as Split Variable (240) or Replace Temp withQuery (178) to simplify variable usage and revisit the extraction later.Compile after all variables are dealt with.Once all the variables are dealt with, it can be useful to compile if the languageenvironment does compile\u00adtime checks. Often, this will help find any variables thathaven\u2019t been dealt with properly.Replace the extracted code in the source function with a call to the target function.Test.Look for other code that\u2019s the same or similar to the code just extracted, andconsider using Replace Inline Code with Function Call (222) to call the newfunction.Some refactoring tools support this directly. Otherwise, it can be worth doing somequick searches to see if duplicate code exists elsewhere.",
        "Example: No Variables Out of Scope": "In the simplest case, Extract Function is trivially easy.function printOwing(invoice) {  let outstanding = 0;  console.log(\"***********************\");  console.log(\"**** Customer Owes ****\");  console.log(\"***********************\");  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  // record due date  const today = Clock.today;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDat  //print details  console.log(`name: ${invoice.customer}`);  console.log(`amount: ${outstanding}`);  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);}You may be wondering what the Clock.today is about. It is a Clock Wrapper [mf\u00adcw]\u2014an object that wraps calls to the system clock. I avoid putting direct calls tothings like Date.now() in my code, because it leads to nondeterministic tests andmakes it difficult to reproduce error conditions when diagnosing failures.It\u2019s easy to extract the code that prints the banner. I just cut, paste, and put in a call:function printOwing(invoice) {  let outstanding = 0;  printBanner();  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  // record due date  const today = Clock.today;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDat  //print details  console.log(`name: ${invoice.customer}`);  console.log(`amount: ${outstanding}`);  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);}function printBanner() {  console.log(\"***********************\");  console.log(\"**** Customer Owes ****\");  console.log(\"***********************\");}Similarly, I can take the printing of details and extract that too:function printOwing(invoice) {  let outstanding = 0;  printBanner();  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  // record due date  const today = Clock.today;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDat  printDetails();  function printDetails() {    console.log(`name: ${invoice.customer}`);    console.log(`amount: ${outstanding}`);    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);  }This makes Extract Function seem like a trivially easy refactoring. But in manysituations, it turns out to be rather more tricky.In the case above, I defined printDetails so it was nested inside printOwing. Thatway it was able to access all the variables defined in printOwing. But that\u2019s not anoption to me if I\u2019m programming in a language that doesn\u2019t allow nested functions.Then I\u2019m faced, essentially, with the problem of extracting the function to the top level,which means I have to pay attention to any variables that exist only in the scope of thesource function. These are the arguments to the original function and the temporaryvariables defined in the function.",
        "Example: Using Local Variables": "The easiest case with local variables is when they are used but not reassigned. In thiscase, I can just pass them in as parameters. So if I have the following function:function printOwing(invoice) {  let outstanding = 0;  printBanner();  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  // record due date  const today = Clock.today;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDat  //print details  console.log(`name: ${invoice.customer}`);  console.log(`amount: ${outstanding}`);  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);}I can extract the printing of details passing two parameters:function printOwing(invoice) {  let outstanding = 0;  printBanner();  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  // record due date  const today = Clock.today;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDat  printDetails(invoice, outstanding);}function printDetails(invoice, outstanding) {  console.log(`name: ${invoice.customer}`);  console.log(`amount: ${outstanding}`);  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);}The same is true if the local variable is a structure (such as an array, record, or object)and I modify that structure. So, I can similarly extract the setting of the due date:function printOwing(invoice) {  let outstanding = 0;  printBanner();  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  recordDueDate(invoice);  printDetails(invoice, outstanding);}function recordDueDate(invoice) {  const today = Clock.today;  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDat}",
        "Example: Reassigning a Local Variable": "It\u2019s the assignment to local variables that becomes complicated. In this case, we\u2019re onlytalking about temps. If I see an assignment to a parameter, I immediately use SplitVariable (240), which turns it into a temp.For temps that are assigned to, there are two cases. The simpler case is where thevariable is a temporary variable used only within the extracted code. When thathappens, the variable just exists within the extracted code. Sometimes, particularlywhen variables are initialized at some distance before they are used, it\u2019s handy to useSlide Statements (223) to get all the variable manipulation together.The more awkward case is where the variable is used outside the extracted function. Inthat case, I need to return the new value. I can illustrate this with the followingfamiliar\u00adlooking function:function printOwing(invoice) {  let outstanding = 0;  printBanner();  // calculate outstanding  for (const o of invoice.orders) {    outstanding += o.amount;  }  recordDueDate(invoice);  printDetails(invoice, outstanding);}I\u2019ve shown the previous refactorings all in one step, since they were straightforward,but this time I\u2019ll take it one step at a time from the mechanics.First, I\u2019ll slide the declaration next to its use.function printOwing(invoice) {  printBanner();  // calculate outstanding  let outstanding = 0;  for (const o of invoice.orders) {    outstanding += o.amount;  }  recordDueDate(invoice);  printDetails(invoice, outstanding);}I then copy the code I want to extract into a target function.function printOwing(invoice) {  printBanner();  // calculate outstanding  let outstanding = 0;  for (const o of invoice.orders) {    outstanding += o.amount;  }  recordDueDate(invoice);  printDetails(invoice, outstanding);}function calculateOutstanding(invoice) {  let outstanding = 0;  for (const o of invoice.orders) {    outstanding += o.amount;  }  return outstanding;}Since I moved the declaration of outstanding into the extracted code, I don\u2019t need topass it in as a parameter. The outstanding variable is the only one reassigned in theextracted code, so I can return it.My JavaScript environment doesn\u2019t yield any value by compiling\u2014indeed less than I\u2019mgetting from the syntax analysis in my editor\u2014so there\u2019s no step to do here. My nextthing to do is to replace the original code with a call to the new function. Since I\u2019mreturning the value, I need to store it in the original variable.function printOwing(invoice) {  printBanner();  let outstanding = calculateOutstanding(invoice);  recordDueDate(invoice);  printDetails(invoice, outstanding);}function calculateOutstanding(invoice) {  let outstanding = 0;  for (const o of invoice.orders) {    outstanding += o.amount;  }  return outstanding;}Before I consider myself done, I rename the return value to follow my usual codingstyle.function printOwing(invoice) {  printBanner();  const outstanding = calculateOutstanding(invoice);  recordDueDate(invoice);  printDetails(invoice, outstanding);}function calculateOutstanding(invoice) {  let result = 0;  for (const o of invoice.orders) {    result += o.amount;  }  return result;}I also take the opportunity to change the original outstanding into a const.At this point you may be wondering, \u201cWhat happens if more than one variable needs tobe returned?\u201dHere, I have several options. Usually I prefer to pick different code to extract. I like afunction to return one value, so I would try to arrange for multiple functions for thedifferent values. If I really need to extract with multiple values, I can form a record andreturn that\u2014but usually I find it better to rework the temporary variables instead. HereI like using Replace Temp with Query (178) and Split Variable (240).This raises an interesting question when I\u2019m extracting functions that I expect to thenmove to another context, such as top level. I prefer small steps, so my instinct is toextract into a nested function first, then move that nested function to its new context.But the tricky part of this is dealing with variables and I don\u2019t expose that difficultyuntil I do the move. This argues that even though I can extract into a nested function, itmakes sense to extract to at least the sibling level of the source function first, so I canimmediately tell if the extracted code makes sense."
    },
    "INLINE FUNCTION": {
        "Mechanics": "Check that this isn\u2019t a polymorphic method.If this is a method in a class, and has subclasses that override it, then I can\u2019t inlineit.Find all the callers of the function.Replace each call with the function\u2019s body.Test after each replacement.The entire inlining doesn\u2019t have to be done all at once. If some parts of the inline aretricky, they can be done gradually as opportunity permits.Remove the function definition.Written this way, Inline Function is simple. In general, it isn\u2019t. I could write pages onhow to handle recursion, multiple return points, inlining a method into another objectwhen you don\u2019t have accessors, and the like. The reason I don\u2019t is that if you encounterthese complexities, you shouldn\u2019t do this refactoring.",
        "Example": "In the simplest case, this refactoring is so easy it\u2019s trivial. I start withfunction rating(aDriver) {  return moreThanFiveLateDeliveries(aDriver) ? 2 : 1;}function moreThanFiveLateDeliveries(aDriver) {  return aDriver.numberOfLateDeliveries > 5;}I can just take the return expression of the called function and paste it into the caller toreplace the call.function rating(aDriver) {  return aDriver.numberOfLateDeliveries > 5 ? 2 : 1;}But it can be a little more involved than that, requiring me to do more work to fit thecode into its new home. Consider the case where I start with this slight variation on theearlier initial code.function rating(aDriver) {  return moreThanFiveLateDeliveries(aDriver) ? 2 : 1;}function moreThanFiveLateDeliveries(dvr) {  return dvr.numberOfLateDeliveries > 5;}Almost the same, but now the declared argument onmoreThanFiveLateDeliveries is different to the name of the passed\u00adin argument.So I have to fit the code a little when I do the inline.function rating(aDriver) {  return aDriver.numberOfLateDeliveries > 5 ? 2 : 1;}It can be even more involved than this. Consider this code:function reportLines(aCustomer) {  const lines = [];  gatherCustomerData(lines, aCustomer);  return lines;}function gatherCustomerData(out, aCustomer) {  out.push([\"name\", aCustomer.name]);  out.push([\"location\", aCustomer.location]);}Inlining gatherCustomerData into reportLines isn\u2019t a simple cut and paste. It\u2019snot too complicated, and most times I would still do this in one go, with a bit of fitting.But to be cautious, it may make sense to move one line at a time. So I\u2019d start with usingMove Statements to Callers (217) on the first line (I\u2019d do it the simple way with a cut,paste, and fit).function reportLines(aCustomer) {  const lines = [];  lines.push([\"name\", aCustomer.name]);  gatherCustomerData(lines, aCustomer);  return lines;}function gatherCustomerData(out, aCustomer) {  out.push([\"name\", aCustomer.name]);  out.push([\"location\", aCustomer.location]);}I then continue with the other lines until I\u2019m done.function reportLines(aCustomer) {  const lines = [];  lines.push([\"name\", aCustomer.name]);  lines.push([\"location\", aCustomer.location]);  return lines;}The point here is to always be ready to take smaller steps. Most of the time, with thesmall functions I normally write, I can do Inline Function in one go, even if there is a bitof refitting to do. But if I run into complications, I go one line at a time. Even with oneline, things can get a bit awkward; then, I\u2019ll use the more elaborate mechanics for MoveStatements to Callers (217) to break things down even more. And if, feeling confident, Ido something the quick way and the tests break, I prefer to revert back to my last greencode and repeat the refactoring with smaller steps and a touch of chagrin."
    },
    "EXTRACT VARIABLE": {
        "Mechanics": "Ensure that the expression you want to extract does not have side effects.Declare an immutable variable. Set it to a copy of the expression you want to name.Replace the original expression with the new variable.Test.If the expression appears more than once, replace each occurrence with the variable,testing after each replacement.",
        "Example": "I start with a simple calculationfunction price(order) {  //price is base price \u00ad quantity discount + shipping  return order.quantity * order.itemPrice \u00ad    Math.max(0, order.quantity \u00ad 500) * order.itemPrice * 0.05 +    Math.min(order.quantity * order.itemPrice * 0.1, 100);}Simple as it may be, I can make it still easier to follow. First, I recognize that the baseprice is the multiple of the quantity and the item price.function price(order) {  //price is base price \u00ad quantity discount + shipping  return order.quantity * order.itemPrice \u00ad    Math.max(0, order.quantity \u00ad 500) * order.itemPrice * 0.05 +    Math.min(order.quantity * order.itemPrice * 0.1, 100);}Once that understanding is in my head, I put it in the code by creating and naming avariable for it.function price(order) {  //price is base price \u00ad quantity discount + shipping  const basePrice = order.quantity * order.itemPrice;  return order.quantity * order.itemPrice \u00ad    Math.max(0, order.quantity \u00ad 500) * order.itemPrice * 0.05 +    Math.min(order.quantity * order.itemPrice * 0.1, 100);}Of course, just declaring and initializing a variable doesn\u2019t do anything; I also have touse it, so I replace the expression that I used as its source.function price(order) {  //price is base price \u00ad quantity discount + shipping  const basePrice = order.quantity * order.itemPrice;  return basePrice \u00ad    Math.max(0, order.quantity \u00ad 500) * order.itemPrice * 0.05 +    Math.min(order.quantity * order.itemPrice * 0.1, 100);}That same expression is used later on, so I can replace it with the variable there too.function price(order) {  //price is base price \u00ad quantity discount + shipping  const basePrice = order.quantity * order.itemPrice;  return basePrice \u00ad    Math.max(0, order.quantity \u00ad 500) * order.itemPrice * 0.05 +    Math.min(basePrice * 0.1, 100);}The next line is the quantity discount, so I can extract that too.function price(order) {  //price is base price \u00ad quantity discount + shipping  const basePrice = order.quantity * order.itemPrice;  const quantityDiscount = Math.max(0, order.quantity \u00ad 500) * order.itemPrice *  return basePrice \u00ad    quantityDiscount +    Math.min(basePrice * 0.1, 100);}Finally, I finish with the shipping. As I do that, I can remove the comment, too, becauseit no longer says anything the code doesn\u2019t say.function price(order) {  const basePrice = order.quantity * order.itemPrice;  const quantityDiscount = Math.max(0, order.quantity \u00ad 500) * order.itemPrice *  const shipping = Math.min(basePrice * 0.1, 100);  return basePrice \u00ad quantityDiscount + shipping;}",
        "Example: With a Class": "Here\u2019s the same code, but this time in the context of a class:class Order {  constructor(aRecord) {    this._data = aRecord;  }  get quantity()  {return this._data.quantity;}  get itemPrice() {return this._data.itemPrice;}  get price() {    return this.quantity * this.itemPrice \u00ad      Math.max(0, this.quantity \u00ad 500) * this.itemPrice * 0.05 +      Math.min(this.quantity * this.itemPrice * 0.1, 100);  }}In this case, I want to extract the same names, but I realize that the names apply to theOrder as a whole, not just the calculation of the price. Since they apply to the wholeorder, I\u2019m inclined to extract the names as methods rather than variables.class Order {  constructor(aRecord) {    this._data = aRecord;  }  get quantity()  {return this._data.quantity;}  get itemPrice() {return this._data.itemPrice;}  get price() {    return this.basePrice \u00ad this.quantityDiscount + this.shipping;  }  get basePrice()        {return this.quantity * this.itemPrice;}  get quantityDiscount() {return Math.max(0, this.quantity \u00ad 500) * this.itemPri  get shipping()         {return Math.min(this.basePrice * 0.1, 100);}}This is one of the great benefits of objects\u2014they give you a reasonable amount ofcontext for logic to share other bits of logic and data. For something as simple as this, itdoesn\u2019t matter so much, but with a larger class it becomes very useful to call outcommon hunks of behavior as their own abstractions with their own names to refer tothem whenever I\u2019m working with the object."
    },
    "INLINE VARIABLE": {
        "Mechanics": "Check that the right\u00adhand side of the assignment is free of side effects.If the variable isn\u2019t already declared immutable, do so and test.This checks that it\u2019s only assigned to once.Find the first reference to the variable and replace it with the right\u00adhand side of theassignment.Test.Repeat replacing references to the variable until you\u2019ve replaced all of them.Remove the declaration and assignment of the variable.Test."
    },
    "CHANGE FUNCTION DECLARATION": {
        "Mechanics": "In most of the refactorings in this book, I present only a single set of mechanics. Thisisn\u2019t because there is only one set that will do the job but because, usually, one set ofmechanics will work reasonably well for most cases. Change Function Declaration,however, is an exception. The simple mechanics are often effective, but there are plentyof cases when a more gradual migration makes more sense. So, with this refactoring, Ilook at the change and ask myself if I think I can change the declaration and all itscallers easily in one go. If so, I follow the simple mechanics. The migration\u00adstylemechanics allow me to change the callers more gradually\u2014which is important if I havelots of them, they are awkward to get to, the function is a polymorphic method, or Ihave a more complicated change to the declaration.",
        "Simple Mechanics": "If you\u2019re removing a parameter, ensure it isn\u2019t referenced in the body of thefunction.Change the method declaration to the desired declaration.Find all references to the old method declaration, update them to the new one.Test.It\u2019s often best to separate changes, so if you want to both change the name and add aparameter, do these as separate steps. (In any case, if you run into trouble, revert anduse the migration mechanics instead.)",
        "Migration Mechanics": "If necessary, refactor the body of the function to make it easy to do the followingextraction step.Use Extract Function (106) on the function body to create the new function.If the new function will have the same name as the old one, give the new function atemporary name that\u2019s easy to search for.If the extracted function needs additional parameters, use the simple mechanics toadd them.Test.Apply Inline Function (115) to the old function.If you used a temporary name, use Change Function Declaration (124) again torestore it to the original name.Test.If you\u2019re changing a method on a class with polymorphism, you\u2019ll need to addindirection for each binding. If the method is polymorphic within a single classhierarchy, you only need the forwarding method on the superclass. If thepolymorphism has no superclass link, then you\u2019ll need forwarding methods on eachimplementation class.If you are refactoring a published API, you can pause the refactoring once you\u2019vecreated the new function. During this pause, deprecate the original function and waitfor clients to change to the new function. The original function declaration can beremoved when (and if) you\u2019re confident all the clients of the old function have migratedto the new one.",
        "Example: Renaming a Function (Simple Mechanics)": "Consider this function with an overly abbreved name:function circum(radius) {  return 2 * Math.PI * radius;}I want to change that to something more sensible. I begin by changing the declaration:function circumference(radius) {  return 2 * Math.PI * radius;}I then find all the callers of circum and change the name to circumference.Different language environments have an impact on how easy it is to find all thereferences to the old function. Static typing and a good IDE provide the best experience,usually allowing me to rename functions automatically with little chance of error.Without static typing, this can be more involved; even good searching tools will thenhave a lot of false positives.I use the same approach for adding or removing parameters: find all the callers, changethe declaration, and change the callers. It\u2019s often better to do these as separate steps\u2014so, if I\u2019m both renaming the function and adding a parameter, I first do the rename,test, then add the parameter, and test again.A disadvantage of this simple way of doing the refactoring is that I have to do all thecallers and the declaration (or all of them, if polymorphic) at once. If there are only afew of them, or if I have decent automated refactoring tools, this is reasonable. But ifthere\u2019s a lot, it can get tricky. Another problem is when the names aren\u2019t unique\u2014e.g., Iwant to rename the a changeAddress method on a person class but the same method,which I don\u2019t want to change, exists on an insurance agreement class. The morecomplex the change is, the less I want to do it in one go like this. When this kind ofproblem arises, I use the migration mechanics instead. Similarly, if I use simplemechanics and something goes wrong, I\u2019ll revert the code to the last known good stateand try again using migration mechanics.",
        "Example: Renaming a Function (Migration Mechanics)": "Again, I have this function with its overly abbreved name:function circum(radius) {  return 2 * Math.PI * radius;}To do this refactoring with migration mechanics, I begin by applying Extract Function(106) to the entire function body.function circum(radius) {  return circumference(radius);}function circumference(radius) {  return 2 * Math.PI * radius;}I test that, then apply Inline Function (115) to the old functions. I find all the calls of theold function and replace each one with a call of the new one. I can test after eachchange, which allows me to do them one at a time. Once I\u2019ve got them all, I remove theold function.With most refactorings, I\u2019m changing code that I can modify, but this refactoring can behandy with a published API\u2014that is, one used by code that I\u2019m unable to changemyself. I can pause the refactoring after creating circumference and, if possible,mark circum as deprecated. I will then wait for callers to change to usecircumference; once they do, I can delete circum. Even if I\u2019m never able to reachthe happy point of deleting circum, at least I have a better name for new code.",
        "Example: Adding a Parameter": "In some software, to manage a library of books, I have a book class which has the abilityto take a reservation for a customer.class Book...addReservation(customer) {  this._reservations.push(customer);}I need to support a priority queue for reservations. Thus, I need an extra parameter onaddReservation to indicate whether the reservation should go in the usual queue orthe high\u00adpriority queue. If I can easily find and change all the callers, then I can just goahead with the change\u2014but if not, I can use the migration approach, which I\u2019ll showhere.I begin by using Extract Function (106) on the body of addReservation to create thenew function. Although it will eventually be called addReservation, the new and oldfunctions can\u2019t coexist with the same name. So I use a temporary name that will be easyto search for later.class Book...addReservation(customer) {  this.zz_addReservation(customer);}zz_addReservation(customer) {  this._reservations.push(customer);}I then add the parameter to the new declaration and its call (in effect, using the simplemechanics).class Book...addReservation(customer) {  this.zz_addReservation(customer, false);}zz_addReservation(customer, isPriority) {  this._reservations.push(customer);}When I use JavaScript, before I change any of the callers, I like to apply IntroduceAssertion (302) to check the new parameter is used by the caller.class Book...zz_addReservation(customer, isPriority) {  assert(isPriority === true || isPriority === false);  this._reservations.push(customer);}Now, when I change the callers, if I make a mistake and leave off the new parameter,this assertion will help me catch the mistake. And I know from long experience thereare few more mistake\u00adprone programmers than myself.Now, I can start changing the callers by using Inline Function (115) on the originalfunction. This allows me to change one caller at a time.I then rename the new function back to the original. Usually, the simple mechanicswork fine for this, but I can also use the migration approach if I need to.",
        "Example: Changing a Parameter to One of Its Properties": "The examples so far are simple changes of a name and adding a new parameter, butwith the migration mechanics, this refactoring can handle more complicated cases quiteneatly. Here\u2019s an example that is a bit more involved.I have a function which determines if a customer is based in New England.function inNewEngland(aCustomer) {  return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(aCustomer.address.state);}Here is one of its callers:caller...const newEnglanders = someCustomers.filter(c => inNewEngland(c));inNewEngland only uses the customer\u2019s home state to determine if it\u2019s in NewEngland. I\u2019d prefer to refactor inNewEngland so that it takes a state code as aparameter, making it usable in more contexts by removing the dependency on thecustomer.With Change Function Declaration, my usual first move is to apply Extract Function(106), but in this case I can make it easier by first refactoring the function body a little. Iuse Extract Variable (119) on my desired new parameter.function inNewEngland(aCustomer) {  const stateCode = aCustomer.address.state;  return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode);}Now I use Extract Function (106) to create that new function.function inNewEngland(aCustomer) {  const stateCode = aCustomer.address.state;  return xxNEWinNewEngland(stateCode);}function xxNEWinNewEngland(stateCode) {  return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode);}I give the function a name that\u2019s easy to automatically replace to turn into the originalname later. (You can tell I don\u2019t have a standard for these temporary names.)I apply Inline Variable (123) on the input parameter in the original function.function inNewEngland(aCustomer) {  return xxNEWinNewEngland(aCustomer.address.state);}I use Inline Function (115) to fold the old function into its callers, effectively replacingthe call to the old function with a call to the new one. I can do these one at a time.caller...const newEnglanders = someCustomers.filter(c => xxNEWinNewEngland(c.address.statOnce I\u2019ve inlined the old function into every caller, I use Change Function Declarationagain to change the name of the new function to that of the original.caller...const newEnglanders = someCustomers.filter(c => inNewEngland(c.address.state));top level...function inNewEngland(stateCode) {  return [\"MA\", \"CT\", \"ME\", \"VT\", \"NH\", \"RI\"].includes(stateCode);}Automated refactoring tools make the migration mechanics both less useful and moreeffective. They make it less useful because they handle even complicated renames andparameter changes safer, so I don\u2019t have to use the migration approach as often as I dowithout that support. However, in cases like this example, where the tools can\u2019t do thewhole refactoring, they still make it much easier as the key moves of extract and inlinecan be done more quickly and safely with the tool."
    },
    "ENCAPSULATE VARIABLE": {
        "Mechanics": "Create encapsulating functions to access and update the variable.Run static checks.For each reference to the variable, replace with a call to the appropriateencapsulating function. Test after each replacement.Restrict the visibility of the variable.Sometimes it\u2019s not possible to prevent access to the variable. If so, it may be usefulto detect any remaining references by renaming the variable and testing.Test.If the value of the variable is a record, consider Encapsulate Record (162).",
        "Example": "Consider some useful data held in a global variable.let defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"};Like any data, it\u2019s referenced with code like this:spaceship.owner = defaultOwner;and updated like this:defaultOwner = {firstName: \"Rebecca\", lastName: \"Parsons\"};To do a basic encapsulation on this, I start by defining functions to read and write thedata.function getDefaultOwner()    {return defaultOwner;}function setDefaultOwner(arg) {defaultOwner = arg;}I then start working on references to defaultOwner. When I see a reference, I replaceit with a call to the getting function.spaceship.owner = getDefaultOwner();When I see an assignment, I replace it with the setting function.setDefaultOwner({firstName: \"Rebecca\", lastName: \"Parsons\"});I test after each replacement.Once I\u2019m done with all the references, I restrict the visibility of the variable. This bothchecks that there aren\u2019t any references that I\u2019ve missed, and ensures that futurechanges to the code won\u2019t access the variable directly. I can do that in JavaScript bymoving both the variable and the accessor methods to their own file and only exportingthe accessor methods.defaultOwner.js...let defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"};export function getDefaultOwner()    {return defaultOwner;}export function setDefaultOwner(arg) {defaultOwner = arg;}If I\u2019m in a situation where I cannot restrict the access to a variable, it may be useful torename the variable and retest. That won\u2019t prevent future direct access, but naming thevariable something meaningful and awkward such as__privateOnly_defaultOwner may help.I don\u2019t like the use of get prefixes on getters, so I\u2019ll rename to remove it.defaultOwner.js...let defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"};export function getdefaultOwner()       {return defaultOwnerData;}export function setDefaultOwner(arg) {defaultOwnerData = arg;}A common convention in JavaScript is to name a getting function and setting functionthe same and differentiate them due the presence of an argument. I call this practiceOverloaded Getter Setter [mf\u00adogs] and strongly dislike it. So, even though I don\u2019t likethe get prefix, I will keep the set prefix.",
        "Encapsulating the Value": "The basic refactoring I\u2019ve outlined here encapsulates a reference to some data structure,allowing me to control its access and reassignment. But it doesn\u2019t control changes tothat structure.const owner1 = defaultOwner();assert.equal(\"Fowler\", owner1.lastName, \"when set\");const owner2 = defaultOwner();owner2.lastName = \"Parsons\";assert.equal(\"Parsons\", owner1.lastName, \"after change owner2\"); // is this ok?The basic refactoring encapsulates the reference to the data item. In many cases, this isall I want to do for the moment. But I often want to take the encapsulation deeper tocontrol not just changes to the variable but also to its contents.For this, I have a couple of options. The simplest one is to prevent any changes to thevalue. My favorite way to handle this is by modifying the getting function to return acopy of the data.defaultOwner.js...let defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"};export function defaultOwner()       {return Object.assign({}, defaultOwnerData)export function setDefaultOwner(arg) {defaultOwnerData = arg;}I use this approach particularly often with lists. If I return a copy of the data, any clientsusing it can change it, but that change isn\u2019t reflected in the shared data. I have to becareful with using copies, however: Some code may expect to change shared data. Ifthat\u2019s the case, I\u2019m relying on my tests to detect a problem. An alternative is to preventchanges\u2014and a good way of doing that is Encapsulate Record (162).let defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"};export function defaultOwner()       {return new Person(defaultOwnerData);}export function setDefaultOwner(arg) {defaultOwnerData = arg;}  class Person {    constructor(data) {      this._lastName = data.lastName;      this._firstName = data.firstName    }    get lastName() {return this._lastName;}    get firstName() {return this._firstName;}    // and so on for other propertiesNow, any attempt to reassign the properties of the default owner will cause an error.Different languages have different techniques to detect or prevent changes like this, sodepending on the language I\u2019d consider other options.Detecting and preventing changes like this is often worthwhile as a temporary measure.I can either remove the changes, or provide suitable mutating functions. Then, oncethey are all dealt with, I can modify the getting method to return a copy.So far I\u2019ve talked about copying on getting data, but it may be worthwhile to make acopy in the setter too. That will depend on where the data comes from and whether Ineed to maintain a link to reflect any changes in that original data. If I don\u2019t need sucha link, a copy prevents accidents due to changes on that source data. Taking a copy maybe superfluous most of the time, but copies in these cases usually have a negligibleeffect on performance; on the other hand, if I don\u2019t do them, there is a risk of a long anddifficult bout of debugging in the future.Remember that the copying above, and the class wrapper, both only work one leveldeep in the record structure. Going deeper requires more levels of copies or objectwrapping.As you can see, encapsulating data is valuable, but often not straightforward. Exactlywhat to encapsulate\u2014and how to do it\u2014depends on the way the data is being used andthe changes I have in mind. But the more widely it\u2019s used, the more it\u2019s worth myattention to encapsulate properly."
    },
    "RENAME VARIABLE": {
        "Mechanics": "If the variable is used widely, consider Encapsulate Variable (132).Find all references to the variable, and change every one.If there are references from another code base, the variable is a published variable,and you cannot do this refactoring.If the variable does not change, you can copy it to one with the new name, thenchange gradually, testing after each change.Test.",
        "Example": "The simplest case for renaming a variable is when it\u2019s local to a single function: a tempor argument. It\u2019s too trivial for even an example: I just find each reference and changeit. After I\u2019m done, I test to ensure I didn\u2019t mess up.Problems occur when the variable has a wider scope than just a single function. Theremay be a lot of references all over the code base:let tpHd = \"untitled\";Some references access the variable:result += `<h1>${tpHd}</h1>`;Others update it:tpHd = obj['articleTitle'];My usual response to this is apply Encapsulate Variable (132).result += `<h1>${title()}</h1>`;setTitle(obj['articleTitle']);  function title()       {return tpHd;}  function setTitle(arg) {tpHd = arg;}At this point, I can rename the variable.let _title = \"untitled\";function title()       {return _title;}function setTitle(arg) {_title = arg;}I could continue by inlining the wrapping functions so all callers are using the variabledirectly. But I\u2019d rarely want to do this. If the variable is used widely enough that I feelthe need to encapsulate it in order to change its name, it\u2019s worth keeping itencapsulated behind functions for the future.In cases where I was going to inline, I\u2019d call the getting function getTitle and not usean underscore for the variable name when I rename it.",
        "Renaming a Constant": "If I\u2019m renaming a constant (or something that acts like a constant to clients) I can avoidencapsulation, and still do the rename gradually, by copying. If the original declarationlooks like this:const cpyNm = \"Acme Gooseberries\";I can begin the renaming by making a copy:const companyName = \"Acme Gooseberries\";const cpyNm = companyName;With the copy, I can gradually change references from the old name to the new name.When I\u2019m done, I remove the copy. I prefer to declare the new name and copy to the oldname if it makes it a tad easier to remove the old name and put it back again should atest fail.This works for constants as well as for variables that are read\u00adonly to clients (such as anexported variable in JavaScript)."
    },
    "INTRODUCE PARAMETER OBJECT": {
        "Mechanics": "If there isn\u2019t a suitable structure already, create one.I prefer to use a class, as that makes it easier to group behavior later on. I usuallylike to ensure these structures are value objects [mf\u00advo].Test.Use Change Function Declaration (124) to add a parameter for the new structure.Test.Adjust each caller to pass in the correct instance of the new structure. Test aftereach one.For each element of the new structure, replace the use of the original parameterwith the element of the structure. Remove the parameter. Test.",
        "Example": "I\u2019ll begin with some code that looks at a set of temperature readings and determineswhether any of them fall outside of an operating range. Here\u2019s what the data looks likefor the readings:const station = { name: \"ZB1\",                  readings: [                    {temp: 47, time: \"2016\u00ad11\u00ad10 09:10\"},                    {temp: 53, time: \"2016\u00ad11\u00ad10 09:20\"},                    {temp: 58, time: \"2016\u00ad11\u00ad10 09:30\"},                    {temp: 53, time: \"2016\u00ad11\u00ad10 09:40\"},                    {temp: 51, time: \"2016\u00ad11\u00ad10 09:50\"},                  ]                };I have a function to find the readings that are outside a temperature range.function readingsOutsideRange(station, min, max) {  return station.readings    .filter(r => r.temp < min || r.temp > max);}It might be called from some code like this:calleralerts = readingsOutsideRange(station,                              operatingPlan.temperatureFloor,                              operatingPlan.temperatureCeiling);Notice how the calling code pulls the two data items as a pair from another object andpasses the pair into readingsOutsideRange. The operating plan uses differentnames to indicate the start and end of the range compared toreadingsOutsideRange. A range like this is a common case where two separate dataitems are better combined into a single object. I\u2019ll begin by declaring a class for thecombined data.class NumberRange {  constructor(min, max) {    this._data = {min: min, max: max};  }  get min() {return this._data.min;}  get max() {return this._data.max;}}I declare a class, rather than just using a basic JavaScript object, because I usually findthis refactoring to be a first step to moving behavior into the newly created object. Sincea class makes sense for this, I go right ahead and use one directly. I also don\u2019t provideany update methods for the new class, as I\u2019ll probably make this a Value Object [mf\u00advo].Most times I do this refactoring, I create value objects.I then use Change Function Declaration (124) to add the new object as a parameter toreadingsOutsideRange.function readingsOutsideRange(station, min, max, range) {  return station.readings    .filter(r => r.temp < min || r.temp > max);}In JavaScript, I can leave the caller as is, but in other languages I\u2019d have to add a nullfor the new parameter which would look something like this:calleralerts = readingsOutsideRange(station,                              operatingPlan.temperatureFloor,                              operatingPlan.temperatureCeiling,                              null);At this point I haven\u2019t changed any behavior, and tests should still pass. I then go toeach caller and adjust it to pass in the correct date range.callerconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.tempalerts = readingsOutsideRange(station,                              operatingPlan.temperatureFloor,                              operatingPlan.temperatureCeiling,                              range);I still haven\u2019t altered any behavior yet, as the parameter isn\u2019t used. All tests should stillwork.Now I can start replacing the usage of the parameters. I\u2019ll start with the maximum.function readingsOutsideRange(station, min, max, range) {  return station.readings    .filter(r => r.temp < min || r.temp > range.max);}callerconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.tempalerts = readingsOutsideRange(station,                              operatingPlan.temperatureFloor,                              operatingPlan.temperatureCeiling,                              range);I can test at this point, then remove the other parameter.function readingsOutsideRange(station, min, range) {  return station.readings    .filter(r => r.temp < range.min || r.temp > range.max);}callerconst range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.tempalerts = readingsOutsideRange(station,                              operatingPlan.temperatureFloor,                              range);That completes this refactoring. However, replacing a clump of parameters with a realobject is just the setup for the really good stuff. The great benefits of making a class likethis is that I can then move behavior into the new class. In this case, I\u2019d add a methodfor range that tests if a value falls within the range.function readingsOutsideRange(station, range) {  return station.readings    .filter(r => !range.contains(r.temp));}class NumberRange...contains(arg) {return (arg >= this.min && arg <= this.max);}This is a first step to creating a range [mf\u00adrange] that can take on a lot of usefulbehavior. Once I\u2019ve identified the need for a range in my code, I can be constantly onthe lookout for other cases where I see a max/min pair of numbers and replace themwith a range. (One immediate possibility is the operating plan, replacingtemperatureFloor and temperatureCeiling with a temperatureRange.) As Ilook at how these pairs are used, I can move more useful behavior into the range class,simplifying its usage across the code base. One of the first things I may add is a value\u00adbased equality method to make it a true value object."
    },
    "COMBINE FUNCTIONS INTO CLASS": {
        "Mechanics": "Apply Encapsulate Record (162) to the common data record that the functionsshare.If the data that is common between the functions isn\u2019t already grouped into a recordstructure, use Introduce Parameter Object (140) to create a record to group ittogether.Take each function that uses the common record and use Move Function (198) tomove it into the new class.Any arguments to the function call that are members can be removed from theargument list.Each bit of logic that manipulates the data can be extracted with Extract Function(106) and then moved into the new class.",
        "Example": "I grew up in England, a country renowned for its love of Tea. (Personally, I don\u2019t likemost tea they serve in England, but have since acquired a taste for Chinese andJapanese teas.) So my author\u2019s fantasy conjures up a state utility for providing tea tothe population. Every month they read the tea meters, to get a record like this:reading = {customer: \"ivan\", quantity: 10, month: 5, year: 2017};I look through the code that processes these records, and I see lots of places wheresimilar calculations are done on the data. So I find a spot that calculates the basecharge:client 1...const aReading = acquireReading();const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;Being England, everything essential must be taxed, so it is with tea. But the rules allowat least an essential level of tea to be free of taxation.client 2...const aReading = acquireReading();const base = (baseRate(aReading.month, aReading.year) * aReading.quantity);const taxableCharge = Math.max(0, base \u00ad taxThreshold(aReading.year));I\u2019m sure that, like me, you noticed that the formula for the base charge is duplicatedbetween these two fragments. If you\u2019re like me, you\u2019re already reaching for ExtractFunction (106). Interestingly, it seems our work has been done for us elsewhere.client 3...const aReading = acquireReading();const basicChargeAmount = calculateBaseCharge(aReading);function calculateBaseCharge(aReading) {  return baseRate(aReading.month, aReading.year) * aReading.quantity;}Given this, I have a natural impulse to change the two earlier bits of client code to usethis function. But the trouble with top\u00adlevel functions like this is that they are often easyto miss. I\u2019d rather change the code to give the function a closer connection to the data itprocesses. A good way to do this is to turn the data into a class.To turn the record into a class, I use Encapsulate Record (162).class Reading {  constructor(data) {    this._customer = data.customer;    this._quantity = data.quantity;    this._month = data.month;    this._year = data.year;  }  get customer() {return this._customer;}  get quantity() {return this._quantity;}  get month()    {return this._month;}  get year()     {return this._year;}}To move the behavior, I\u2019ll start with the function I already have:calculateBaseCharge. To use the new class, I need to apply it to the data as soon asI\u2019ve acquired it.client 3...const rawReading = acquireReading();const aReading = new Reading(rawReading);const basicChargeAmount = calculateBaseCharge(aReading);I then use Move Function (198) to move calculateBaseCharge into the new class.class Reading...get calculateBaseCharge() {  return baseRate(this.month, this.year) * this.quantity;}client 3...const rawReading = acquireReading();const aReading = new Reading(rawReading);const basicChargeAmount = aReading.calculateBaseCharge;While I\u2019m at it, I use Rename Function (124) to make it something more to my liking.get baseCharge() {  return baseRate(this.month, this.year) * this.quantity;}client 3...const rawReading = acquireReading();const aReading = new Reading(rawReading);const basicChargeAmount = aReading.baseCharge;With this naming, the client of the reading class can\u2019t tell whether the base charge is afield or a derived value. This is a Good Thing\u2014the Uniform Access Principle [mf\u00adua].I now alter the first client to call the method rather than repeat the calculation.client 1...const rawReading = acquireReading();const aReading = new Reading(rawReading);const baseCharge = aReading.baseCharge;There\u2019s a strong chance I\u2019ll use Inline Variable (123) on the baseCharge variablebefore the day is out. But more relevant to this refactoring is the client that calculatesthe taxable amount. My first step here is to use the new base charge property.client 2...const rawReading = acquireReading();const aReading = new Reading(rawReading);const taxableCharge = Math.max(0, aReading.baseCharge \u00ad taxThreshold(aReading.yeI use Extract Function (106) on the calculation for the taxable charge.function taxableChargeFn(aReading) {  return Math.max(0, aReading.baseCharge \u00ad taxThreshold(aReading.year));}client 3...const rawReading = acquireReading();const aReading = new Reading(rawReading);const taxableCharge = taxableChargeFn(aReading);Then I apply Move Function (198).class Reading...get taxableCharge() {  return  Math.max(0, this.baseCharge \u00ad taxThreshold(this.year));}client 3...const rawReading = acquireReading();const aReading = new Reading(rawReading);const taxableCharge = aReading.taxableCharge;Since all the derived data is calculated on demand, I have no problem should I need toupdate the stored data. In general, I prefer immutable data, but many circumstancesforce us to work with mutable data (such as JavaScript, a language ecosystem thatwasn\u2019t designed with immutability in mind). When there is a reasonable chance thedata will be updated somewhere in the program, then a class is very helpful."
    },
    "COMBINE FUNCTIONS INTO TRANSFORM": {
        "Mechanics": "Create a transformation function that takes the record to be transformed andreturns the same values.This will usually involve a deep copy of the record. It is often worthwhile to write atest to ensure the transform does not alter the original record.Pick some logic and move its body into the transform to create a new field in therecord. Change the client code to access the new field.If the logic is complex, use Extract Function (106) first.Test.Repeat for the other relevant functions.",
        "Example": "Where I grew up, tea is an important part of life\u2014so much that I can imagine a specialutility that provides tea to the populace that\u2019s regulated like a utility. Every month, theutility gets a reading of how much tea a customer has acquired.reading = {customer: \"ivan\", quantity: 10, month: 5, year: 2017};Code in various places calculates various consequences of this tea usage. One suchcalculation is the base monetary amount that\u2019s used to calculate the charge for thecustomer.client 1...const aReading = acquireReading();const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;Another is the amount that should be taxed\u2014which is less than the base amount sincethe government wisely considers that every citizen should get some tea tax free.client 2...const aReading = acquireReading();const base = (baseRate(aReading.month, aReading.year) * aReading.quantity);const taxableCharge = Math.max(0, base \u00ad taxThreshold(aReading.year));Looking through this code, I see these calculations repeated in several places. Suchduplication is asking for trouble when they need to change (and I\u2019d bet it\u2019s \u201cwhen\u201d not\u201cif\u201d). I can deal with this repetition by using Extract Function (106) on thesecalculations, but such functions often end up scattered around the program making ithard for future developers to realize they are there. Indeed, looking around I discoversuch a function, used in another area of the code.client 3...const aReading = acquireReading();const basicChargeAmount = calculateBaseCharge(aReading);function calculateBaseCharge(aReading) {  return  baseRate(aReading.month, aReading.year) * aReading.quantity;}One way of dealing with this is to move all of these derivations into a transformationstep that takes the raw reading and emits a reading enriched with all the commonderived results.I begin by creating a transformation function that merely copies the input object.function enrichReading(original) {  const result = _.cloneDeep(original);  return result;}I\u2019m using the cloneDeep from lodash to create a deep copy.When I\u2019m applying a transformation that produces essentially the same thing but withadditional information, I like to name it using \u201cenrich\u201d. If it were producing somethingI felt was different, I would name it using \u201ctransform\u201d.I then pick one of the calculations I want to change. First, I enrich the reading it useswith the current one that does nothing yet.client 3...const rawReading = acquireReading();const aReading = enrichReading(rawReading);const basicChargeAmount = calculateBaseCharge(aReading);I use Move Function (198) on calculateBaseCharge to move it into the enrichmentcalculation.function enrichReading(original) {  const result = _.cloneDeep(original);  result.baseCharge = calculateBaseCharge(result);  return result;}Within the transformation function, I\u2019m happy to mutate a result object, instead ofcopying each time. I like immutability, but most common languages make it difficult towork with. I\u2019m prepared to go through the extra effort to support it at boundaries, butwill mutate within smaller scopes. I also pick my names (using aReading as theaccumulating variable) to make it easier to move the code into the transformerfunction.I change the client that uses that function to use the enriched field instead.client 3...const rawReading = acquireReading();const aReading = enrichReading(rawReading);const basicChargeAmount = aReading.baseCharge;Once I\u2019ve moved all calls to calculateBaseCharge, I can nest it insideenrichReading. That would make it clear that clients that need the calculated basecharge should use the enriched record.One trap to beware of here. When I write enrichReading like this, to return theenriched reading, I\u2019m implying that the original reading record isn\u2019t changed. So it\u2019swise for me to add a test.it('check reading unchanged', function() {  const baseReading = {customer: \"ivan\", quantity: 15, month: 5, year: 2017};  const oracle = _.cloneDeep(baseReading);  enrichReading(baseReading);  assert.deepEqual(baseReading, oracle);});I can then change client 1 to also use the same field.client 1...const rawReading = acquireReading();const aReading = enrichReading(rawReading);const baseCharge = aReading.baseCharge;There is a good chance I can then use Inline Variable (123) on baseCharge too.Now I turn to the taxable amount calculation. My first step is to add in thetransformation function.const rawReading = acquireReading();const aReading = enrichReading(rawReading);const base = (baseRate(aReading.month, aReading.year) * aReading.quantity);const taxableCharge = Math.max(0, base \u00ad taxThreshold(aReading.year));I can immediately replace the calculation of the base charge with the new field. If thecalculation was complex, I could Extract Function (106) first, but here it\u2019s simpleenough to do in one step.const rawReading = acquireReading();const aReading = enrichReading(rawReading);const base = aReading.baseCharge;const taxableCharge = Math.max(0, base \u00ad taxThreshold(aReading.year));Once I\u2019ve tested that that works, I apply Inline Variable (123):const rawReading = acquireReading();const aReading = enrichReading(rawReading);const taxableCharge = Math.max(0, aReading.baseCharge \u00ad taxThreshold(aReading.yeand move that computation into the transformer:function enrichReading(original) {  const result = _.cloneDeep(original);  result.baseCharge = calculateBaseCharge(result);  result.taxableCharge = Math.max(0, result.baseCharge \u00ad taxThreshold(result.yea  return result;}I modify the original code to use the new field.const rawReading = acquireReading();const aReading = enrichReading(rawReading);const taxableCharge = aReading.taxableCharge;Once I\u2019ve tested that, it\u2019s likely I would be able to use Inline Variable (123) ontaxableCharge.One big problem with an enriched reading like this is: What happens should a clientchange a data value? Changing, say, the quantity field would result in data that\u2019sinconsistent. To avoid this in JavaScript, my best option is to use Combine Functionsinto Class (144) instead. If I\u2019m in a language with immutable data structures, I don\u2019thave this problem, so its more common to see transforms in those languages. But evenin languages without immutability, I can use transforms if the data appears in a read\u00adonly context, such as deriving data to display on a web page."
    },
    "SPLIT PHASE": {
        "Mechanics": "Extract the second phase code into its own function.Test.Introduce an intermediate data structure as an additional argument to the extractedfunction.Test.Examine each parameter of the extracted second phase. If it is used by first phase,move it to the intermediate data structure. Test after each move.Sometimes, a parameter should not be used by the second phase. In this case,extract the results of each usage of the parameter into a field of the intermediatedata structure and use Move Statements to Callers (217) on the line that populatesit.Apply Extract Function (106) on the first\u00adphase code, returning the intermediatedata structure.It\u2019s also reasonable to extract the first phase into a transformer object.",
        "Example": "I\u2019ll start with code to price an order for some vague and unimportant kind of goods:function priceOrder(product, quantity, shippingMethod) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  const shippingPerCase = (basePrice > shippingMethod.discountThreshold)          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = quantity * shippingPerCase;  const price =  basePrice \u00ad discount + shippingCost;  return price;}Although this is the usual kind of trivial example, there is a sense of two phases goingon here. The first couple of lines of code use the product information to calculate theproduct\u00adoriented price of the order, while the later code uses shipping information todetermine the shipping cost. If I have changes coming up that complicate the pricingand shipping calculations, but they work relatively independently, then splitting thiscode into two phases is valuable.I begin by applying Extract Function (106) to the shipping calculation.function priceOrder(product, quantity, shippingMethod) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  const price =  applyShipping(basePrice, shippingMethod, quantity, discount);  return price;}function applyShipping(basePrice, shippingMethod, quantity, discount) {  const shippingPerCase = (basePrice > shippingMethod.discountThreshold)          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = quantity * shippingPerCase;  const price =  basePrice \u00ad discount + shippingCost;  return price;}I pass in all the data that this second phase needs as individual parameters. In a morerealistic case, there can be a lot of these, but I don\u2019t worry about it as I\u2019ll whittle themdown later.Next, I introduce the intermediate data structure that will communicate between thetwo phases.function priceOrder(product, quantity, shippingMethod) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  const priceData = {};  const price =  applyShipping(priceData, basePrice, shippingMethod, quantity, d  return price;}function applyShipping(priceData, basePrice, shippingMethod, quantity, discount)  const shippingPerCase = (basePrice > shippingMethod.discountThreshold)          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = quantity * shippingPerCase;  const price =  basePrice \u00ad discount + shippingCost;  return price;}Now, I look at the various parameters to applyShipping. The first one is basePricewhich is created by the first\u00adphase code. So I move this into the intermediate datastructure, removing it from the parameter list.function priceOrder(product, quantity, shippingMethod) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  const priceData = {basePrice: basePrice};  const price =  applyShipping(priceData, basePrice, shippingMethod, quantity, d  return price;}function applyShipping(priceData, basePrice, shippingMethod, quantity, discount)  const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshol          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = quantity * shippingPerCase;  const price =  priceData.basePrice \u00ad discount + shippingCost;  return price;}The next parameter in the list is shippingMethod. This one I leave as is, since it isn\u2019tused by the first\u00adphase code.After this, I have quantity. This is used by the first phase but not created by it, so Icould actually leave this in the parameter list. My usual preference, however, is to moveas much as I can to the intermediate data structure.function priceOrder(product, quantity, shippingMethod) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  const priceData = {basePrice: basePrice, quantity: quantity};  const price =  applyShipping(priceData, shippingMethod, quantity, discount);  return price;}function applyShipping(priceData, shippingMethod, quantity, discount) {  const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshol          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = priceData.quantity * shippingPerCase;  const price =  priceData.basePrice \u00ad discount + shippingCost;  return price;}I do the same with discount.function priceOrder(product, quantity, shippingMethod) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  const priceData = {basePrice: basePrice, quantity: quantity, discount:discount  const price =  applyShipping(priceData, shippingMethod, discount);  return price;}function applyShipping(priceData, shippingMethod, discount) {  const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshol          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = priceData.quantity * shippingPerCase;  const price =  priceData.basePrice \u00ad priceData.discount + shippingCost;  return price;}Once I\u2019ve gone through all the function parameters, I have the intermediate datastructure fully formed. So I can extract the first\u00adphase code into its own function,returning this data.function priceOrder(product, quantity, shippingMethod) {  const priceData = calculatePricingData(product, quantity);  const price =  applyShipping(priceData, shippingMethod);  return price;}function calculatePricingData(product, quantity) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  return {basePrice: basePrice, quantity: quantity, discount:discount};}function applyShipping(priceData, shippingMethod) {  const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshol          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = priceData.quantity * shippingPerCase;  const price =  priceData.basePrice \u00ad priceData.discount + shippingCost;  return price;}I can\u2019t resist tidying out those final constants.function priceOrder(product, quantity, shippingMethod) {  const priceData = calculatePricingData(product, quantity);  return applyShipping(priceData, shippingMethod);}function calculatePricingData(product, quantity) {  const basePrice = product.basePrice * quantity;  const discount = Math.max(quantity \u00ad product.discountThreshold, 0)          * product.basePrice * product.discountRate;  return {basePrice: basePrice, quantity: quantity, discount:discount};}function applyShipping(priceData, shippingMethod) {  const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshol          ? shippingMethod.discountedFee : shippingMethod.feePerCase;  const shippingCost = priceData.quantity * shippingPerCase;  return priceData.basePrice \u00ad priceData.discount + shippingCost;}Perhaps the most important criteria to be used in decomposing modules is to identifysecrets that modules should hide from the rest of the system [Parnas]. Data structuresare the most common secrets, and I can hide data structures by encapsulating themwith Encapsulate Record (162) and Encapsulate Collection (170). Even primitive datavalues can be encapsulated with Replace Primitive with Object (174)\u2014the magnitude ofsecond\u00adorder benefits from doing this often surprises people. Temporary variablesoften get in the way of refactoring\u2014I have to ensure they are calculated in the rightorder and their values are available to other parts of the code that need them. UsingReplace Temp with Query (178) is a great help here, particularly when splitting up anoverly long function.Classes were designed for information hiding. In the previous chapter, I described away to form them with Combine Functions into Class (144). The common extract/inlineoperations also apply to classes with Extract Class (182) and Inline Class (186).As well as hiding the internals of classes, it\u2019s often useful to hide connections betweenclasses, which I can do with Hide Delegate (189). But too much hiding leads to bloatedinterfaces, so I also need its reverse: Remove Middle Man (192).Classes and modules are the largest forms of encapsulation, but functions alsoencapsulate their implementation. Sometimes, I may need to make a wholesale changeto an algorithm, which I can do by wrapping it in a function with Extract Function(106) and applying Substitute Algorithm (195)."
    },
    "ENCAPSULATE RECORD": {
        "Mechanics": "Use Encapsulate Variable (132) on the variable holding the record.Give the functions that encapsulate the record names that are easily searchable.Replace the content of the variable with a simple class that wraps the record. Definean accessor inside this class that returns the raw record. Modify the functions thatencapsulate the variable to use this accessor.Test.Provide new functions that return the object rather than the raw record.For each user of the record, replace its use of a function that returns the record witha function that returns the object. Use an accessor on the object to get at the fielddata, creating that accessor if needed. Test after each change.If it\u2019s a complex record, such as one with a nested structure, focus on clients thatupdate the data first. Consider returning a copy or read\u00adonly proxy of the data forclients that only read the data.Remove the class\u2019s raw data accessor and the easily searchable functions thatreturned the raw record.Test.If the fields of the record are themselves structures, consider using EncapsulateRecord and Encapsulate Collection (170) recursively.",
        "Example": "I\u2019ll start with a constant that is widely used across a program.const organization = {name: \"Acme Gooseberries\", country: \"GB\"};This is a JavaScript object which is being used as a record structure by various parts ofthe program, with accesses like this:result += `<h1>${organization.name}</h1>`;andorganization.name = newName;The first step is a simple Encapsulate Variable (132).function getRawDataOfOrganization() {return organization;}example reader...result += `<h1>${getRawDataOfOrganization().name}</h1>`;example writer...getRawDataOfOrganization().name = newName;It\u2019s not quite a standard Encapsulate Variable (132), since I gave the getter a namedeliberately chosen to be both ugly and easy to search for. This is because I intend itslife to be short.Encapsulating a record means going deeper than just the variable itself; I want tocontrol how it\u2019s manipulated. I can do this by replacing the record with a class.class Organization...class Organization {  constructor(data) {    this._data = data;  }}top levelconst organization = new Organization({name: \"Acme Gooseberries\", country: \"GB\"}function getRawDataOfOrganization() {return organization._data;}function getOrganization() {return organization;}Now that I have an object in place, I start looking at the users of the record. Any onethat updates the record gets replaced with a setter.class Organization...set name(aString) {this._data.name = aString;}client...getOrganization().name = newName;Similarly, I replace any readers with the appropriate getter.class Organization...get name()    {return this._data.name;}client...result += `<h1>${getOrganization().name}</h1>`;After I\u2019ve done that, I can follow through on my threat to give the ugly soundingfunction a short life.function getRawDataOfOrganization() {return organization._data;}function getOrganization() {return organization;}I\u2019d also be inclined to fold the _data field directly into the object.class Organization {  constructor(data) {    this._name = data.name;    this._country = data.country;  }  get name()    {return this._name;}  set name(aString) {this._name = aString;}  get country()    {return this._country;}  set country(aCountryCode) {this._country = aCountryCode;}}This has the advantage of breaking the link to the input data record. This might beuseful if a reference to it runs around, which would break encapsulation. Should I notfold the data into individual fields, I would be wise to copy _data when I assign it.",
        "Example: Encapsulating a Nested Record": "The above example looks at a shallow record, but what do I do with data that is deeplynested, e.g., coming from a JSON document? The core refactoring steps still apply, andI have to be equally careful with updates, but I do get some options around reads.As an example, here is some slightly more nested data: a collection of customers, keptin a hashmap indexed by their customer ID.\"1920\": {  name: \"martin\",  id: \"1920\",  usages: {    \"2016\": {      \"1\": 50,      \"2\": 55,      // remaining months of the year    },    \"2015\": {      \"1\": 70,      \"2\": 63,      // remaining months of the year    }  }},\"38673\": {  name: \"neal\",  id: \"38673\",  // more customers in a similar formWith more nested data, reads and writes can be digging into the data structure.sample update...customerData[customerID].usages[year][month] = amount;sample read...function compareUsage (customerID, laterYear, month) {  const later   = customerData[customerID].usages[laterYear][month];  const earlier = customerData[customerID].usages[laterYear \u00ad 1][month];  return {laterAmount: later, change: later \u00ad earlier};}To encapsulate this data, I also start with Encapsulate Variable (132).function getRawDataOfCustomers()    {return customerData;}function setRawDataOfCustomers(arg) {customerData = arg;}sample update...getRawDataOfCustomers()[customerID].usages[year][month] = amount;sample read...function compareUsage (customerID, laterYear, month) {  const later   = getRawDataOfCustomers()[customerID].usages[laterYear][month];  const earlier = getRawDataOfCustomers()[customerID].usages[laterYear \u00ad 1][mont  return {laterAmount: later, change: later \u00ad earlier};}I then make a class for the overall data structure.class CustomerData {  constructor(data) {    this._data = data;  }}top level...function getCustomerData() {return customerData;}function getRawDataOfCustomers()    {return customerData._data;}function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}The most important area to deal with is the updates. So, while I look at all the callers ofgetRawDataOfCustomers, I\u2019m focused on those where the data is changed. Toremind you, here\u2019s the update again:sample update...getRawDataOfCustomers()[customerID].usages[year][month] = amount;The general mechanics now say to return the full customer and use an accessor,creating one if needed. I don\u2019t have a setter on the customer for this update, and thisone digs into the structure. So, to make one, I begin by using Extract Function (106) onthe code that digs into the data structure.sample update...setUsage(customerID, year, month, amount);top level...function setUsage(customerID, year, month, amount) {  getRawDataOfCustomers()[customerID].usages[year][month] = amount;}I then use Move Function (198) to move it into the new customer data class.sample update...getCustomerData().setUsage(customerID, year, month, amount);class CustomerData...setUsage(customerID, year, month, amount) {  this._data[customerID].usages[year][month] = amount;}When working with a big data structure, I like to concentrate on the updates. Gettingthem visible and gathered in a single place is the most important part of theencapsulation.At some point, I will think I\u2019ve got them all\u2014but how can I be sure? There\u2019s a couple ofways to check. One is to modify getRawDataOfCustomers to return a deep copy ofthe data; if my test coverage is good, one of the tests should break if I missed amodification.top level...function getCustomerData() {return customerData;}function getRawDataOfCustomers()    {return customerData.rawData;}function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}class CustomerData...get rawData() {  return _.cloneDeep(this._data);}I\u2019m using the lodash library to make a deep copy.Another approach is to return a read\u00adonly proxy for the data structure. Such a proxycould raise an exception if the client code tries to modify the underlying object. Somelanguages make this easy, but it\u2019s a pain in JavaScript, so I\u2019ll leave it as an exercise forthe reader. I could also take a copy and recursively freeze it to detect any modifications.Dealing with the updates is valuable, but what about the readers? Here there are a fewoptions.The first option is to do the same thing as I did for the setters. Extract all the reads intotheir own functions and move them into the customer data class.class CustomerData...usage(customerID, year, month) {  return this._data[customerID].usages[year][month];}top level...function compareUsage (customerID, laterYear, month) {  const later   = getCustomerData().usage(customerID, laterYear, month);  const earlier = getCustomerData().usage(customerID, laterYear \u00ad 1, month)  return {laterAmount: later, change: later \u00ad earlier};}The great thing about this approach is that it gives customerData an explicit API thatcaptures all the uses made of it. I can look at the class and see all their uses of the data.But this can be a lot of code for lots of special cases. Modern languages provide goodaffordances for digging into a list\u00adand\u00adhash [mf\u00adlh] data structure, so it\u2019s useful to giveclients just such a data structure to work with.If the client wants a data structure, I can just hand out the actual data. But the problemwith this is that there\u2019s no way to prevent clients from modifying the data directly,which breaks the whole point of encapsulating all the updates inside functions.Consequently, the simplest thing to do is to provide a copy of the underlying data, usingthe rawData method I wrote earlier.class CustomerData...get rawData() {  return _.cloneDeep(this._data);}top level...function compareUsage (customerID, laterYear, month) {  const later   = getCustomerData().rawData[customerID].usages[laterYear][month]  const earlier = getCustomerData().rawData[customerID].usages[laterYear \u00ad 1][mo  return {laterAmount: later, change: later \u00ad earlier};}But although it\u2019s simple, there are downsides. The most obvious problem is the cost ofcopying a large data structure, which may turn out to be a performance problem. Aswith anything like this, however, the performance cost might be acceptable\u2014I wouldwant to measure its impact before I start to worry about it. There may also be confusionif clients expect modifying the copied data to modify the original. In those cases, a read\u00adonly proxy or freezing the copied data might provide a helpful error should they do this.Another option is more work, but offers the most control: Apply Encapsulate Recordrecursively. With this, I turn the customer record into its own class, apply EncapsulateCollection (170) to the usages, and create a usage class. I can then enforce control ofupdates by using accessors, perhaps applying Change Reference to Value (252) on theusage objects. But this can be a lot of effort for a large data structure\u2014and not reallyneeded if I don\u2019t access that much of the data structure. Sometimes, a judicious mix ofgetters and new classes may work, using a getter to dig deep into the structure butreturning an object that wraps the structure rather than the unencapsulated data. Iwrote about this kind of thing in an article \u201cRefactoring Code to Load a Document\u201d [mf\u00adref\u00addoc]."
    },
    "ENCAPSULATE COLLECTION": {
        "Mechanics": "Apply Encapsulate Variable (132) if the reference to the collection isn\u2019t alreadyencapsulated.Add functions to add and remove elements from the collection.If there is a setter for the collection, use Remove Setting Method (331) if possible. Ifnot, make it take a copy of the provided collection.Run static checks.Find all references to the collection. If anyone calls modifiers on the collection,change them to use the new add/remove functions. Test after each change.Modify the getter for the collection to return a protected view on it, using a read\u00adonly proxy or a copy.Test.",
        "Example": "I start with a person class that has a field for a list of courses.class Person...constructor (name) {  this._name = name;  this._courses = [];}get name() {return this._name;}get courses() {return this._courses;}set courses(aList) {this._courses = aList;}class Course...constructor(name, isAdvanced) {  this._name = name;  this._isAdvanced = isAdvanced;}get name()       {return this._name;}get isAdvanced() {return this._isAdvanced;}Clients use the course collection to gather information on courses.numAdvancedCourses = aPerson.courses  .filter(c => c.isAdvanced)  .length;A naive developer would say this class has proper data encapsulation: After all, eachfield is protected by accessor methods. But I would argue that the list of courses isn\u2019tproperly encapsulated. Certainly, anyone updating the courses as a single value hasproper control through the setter:client code...const basicCourseNames = readBasicCourseNames(filename);aPerson.courses = basicCourseNames.map(name => new Course(name, false));But clients might find it easier to update the course list directly.client code...for(const name of readBasicCourseNames(filename)) {  aPerson.courses.push(new Course(name, false));}This violates encapsulating because the person class has no ability to take control whenthe list is updated in this way. While the reference to the field is encapsulated, thecontent of the field is not.I\u2019ll begin creating proper encapsulation by adding methods to the person class thatallow a client to add and remove individual courses.class Person...addCourse(aCourse) {  this._courses.push(aCourse);}removeCourse(aCourse, fnIfAbsent = () => {throw new RangeError();}) {  const index = this._courses.indexOf(aCourse);  if (index === \u00ad1) fnIfAbsent();  else this._courses.splice(index, 1);}With a removal, I have to decide what to do if a client asks to remove an element thatisn\u2019t in the collection. I can either shrug, or raise an error. With this code, I default toraising an error, but give the callers an opportunity to do something else if they wish.I then change any code that calls modifiers directly on the collection to use newmethods.client code...for(const name of readBasicCourseNames(filename)) {  aPerson.addCourse(new Course(name, false));}With individual add and remove methods, there is usually no need for setCourses, inwhich case I\u2019ll use Remove Setting Method (331) on it. Should the API need a settingmethod for some reason, I ensure it puts a copy of the collection in the field.class Person...set courses(aList) {this._courses = aList.slice();}All this enables the clients to use the right kind of modifier methods, but I prefer toensure nobody modifies the list without using them. I can do this by providing a copy.class Person...get courses() {return this._courses.slice();}In general, I find it wise to be moderately paranoid about collections and I\u2019d rather copythem unnecessarily than debug errors due to unexpected modifications. Modificationsaren\u2019t always obvious; for example, sorting an array in JavaScript modifies the original,while many languages default to making a copy for an operation that changes acollection. Any class that\u2019s responsible for managing a collection should always give outcopies\u2014but I also get into the habit of making a copy if I do something that\u2019s liable tochange a collection."
    },
    "REPLACE PRIMITIVE WITH OBJECT": {
        "Mechanics": "Apply Encapsulate Variable (132) if it isn\u2019t already.Create a simple value class for the data value. It should take the existing value in itsconstructor and provide a getter for that value.Run static checks.Change the setter to create a new instance of the value class and store that in thefield, changing the type of the field if present.Change the getter to return the result of invoking the getter of the new class.Test.Consider using Rename Function (124) on the original accessors to better reflectwhat they do.Consider clarifying the role of the new object as a value or reference object byapplying Change Reference to Value (252) or Change Value to Reference (256).",
        "Example": "I begin with a simple order class that reads its data from a simple record structure. Oneof its properties is a priority, which it reads as a simple string.class Order...constructor(data) {  this.priority = data.priority;  // more initializationSome client codes uses it like this:client...highPriorityCount = orders.filter(o => \"high\" === o.priority                                    || \"rush\" === o.priority)                          .length;Whenever I\u2019m fiddling with a data value, the first thing I do is use EncapsulateVariable (132) on it.class Order...get priority()        {return this._priority;}set priority(aString) {this._priority = aString;}The constructor line that initializes the priority will now use the setter I define here.This self\u00adencapsulates the field so I can preserve its current use while I manipulate thedata itself.I create a simple value class for the priority. It has a constructor for the value and aconversion function to return a string.class Priority {  constructor(value) {this._value = value;}  toString() {return this._value;}}I prefer using a conversion function (toString) rather than a getter (value) here.For clients of the class, asking for the string representation should feel more like aconversion than getting a property.I then modify the accessors to use this new class.class Order...get priority()        {return this._priority.toString();}set priority(aString) {this._priority = new Priority(aString);}Now that I have a priority class, I find the current getter on the order to be misleading.It doesn\u2019t return the priority\u2014but a string that describes the priority. My immediatemove is to use Rename Function (124).class Order...get priorityString()  {return this._priority.toString();}set priority(aString) {this._priority = new Priority(aString);}client...highPriorityCount = orders.filter(o => \"high\" === o.priorityString                                    || \"rush\" === o.priorityString)                          .length;In this case, I\u2019m happy to retain the name of the setter. The name of the argumentcommunicates what it expects.Now I\u2019m done with the formal refactoring. But as I look at who uses the priority, Iconsider whether they should use the priority class themselves. As a result, I provide agetter on order that provides the new priority object directly.class Order...get priority()        {return this._priority;}get priorityString()  {return this._priority.toString();}set priority(aString) {this._priority = new Priority(aString);}client...highPriorityCount = orders.filter(o => \"high\" === o.priority.toString()                                    || \"rush\" === o.priority.toString())                          .length;As the priority class becomes useful elsewhere, I would allow clients of the order to usethe setter with a priority instance, which I do by adjusting the priority constructor.class Priority...constructor(value) {  if (value instanceof Priority) return value;  this._value = value;}The point of all this is that now, my new priority class can be useful as a place for newbehavior\u2014either new to the code or moved from elsewhere. Here\u2019s some simple code toadd validation of priority values and comparison logic:class Priority...constructor(value) {  if (value instanceof Priority) return value;  if (Priority.legalValues().includes(value))    this._value = value;  else    throw new Error(`<${value}> is invalid for Priority`);}toString() {return this._value;}get _index() {return Priority.legalValues().findIndex(s => s === this._value);}static legalValues() {return ['low', 'normal', 'high', 'rush'];}equals(other) {return this._index === other._index;}higherThan(other) {return this._index > other._index;}lowerThan(other) {return this._index < other._index;}As I do this, I decide that a priority should be a value object, so I provide an equalsmethod and ensure that it is immutable.Now I\u2019ve added that behavior, I can make the client code more meaningful:client...highPriorityCount = orders.filter(o => o.priority.higherThan(new Priority(\"norma                          .length;"
    },
    "REPLACE TEMP WITH QUERY": {
        "Mechanics": "Check that the variable is determined entirely before it\u2019s used, and the code thatcalculates it does not yield a different value whenever it is used.If the variable isn\u2019t read\u00adonly, and can be made read\u00adonly, do so.Test.Extract the assignment of the variable into a function.If the variable and the function cannot share a name, use a temporary name for thefunction.Ensure the extracted function is free of side effects. If not, use Separate Query fromModifier (306).Test.Use Inline Variable (123) to remove the temp.",
        "Example": "Here is a simple class:class Order...  constructor(quantity, item) {    this._quantity = quantity;    this._item = item;  }    get price() {    var basePrice = this._quantity * this._item.price;    var discountFactor = 0.98;    if (basePrice > 1000) discountFactor \u00ad= 0.03;    return basePrice * discountFactor;  }}I want to replace the temps basePrice and discountFactor with methods.Starting with basePrice, I make it const and run tests. This is a good way ofchecking that I haven\u2019t missed a reassignment\u2014unlikely in such a short function butcommon when I\u2019m dealing with something larger.class Order...  constructor(quantity, item) {    this._quantity = quantity;    this._item = item;  }  get price() {    const basePrice = this._quantity * this._item.price;    var discountFactor = 0.98;    if (basePrice > 1000) discountFactor \u00ad= 0.03;    return basePrice * discountFactor;  }}I then extract the right\u00adhand side of the assignment to a getting method.class Order...get price() {  const basePrice = this.basePrice;  var discountFactor = 0.98;  if (basePrice > 1000) discountFactor \u00ad= 0.03;  return basePrice * discountFactor;} get basePrice() {   return this._quantity * this._item.price; }I test, and apply Inline Variable (123).class Order...get price() {  const basePrice = this.basePrice;  var discountFactor = 0.98;  if (this.basePrice > 1000) discountFactor \u00ad= 0.03;  return this.basePrice * discountFactor;}I then repeat the steps with discountFactor, first using Extract Function (106).class Order...get price() {  const discountFactor = this.discountFactor;  return this.basePrice * discountFactor;} get discountFactor() {   var discountFactor = 0.98;   if (this.basePrice > 1000) discountFactor \u00ad= 0.03;   return discountFactor; }In this case I need my extracted function to contain both assignments todiscountFactor. I can also set the original variable to be const.Then, I inline:get price() {  return this.basePrice * this.discountFactor;}"
    },
    "EXTRACT CLASS": {
        "Mechanics": "Decide how to split the responsibilities of the class.Create a new child class to express the split\u00adoff responsibilities.If the responsibilities of the original parent class no longer match its name, renamethe parent.Create an instance of the child class when constructing the parent and add a linkfrom parent to child.Use Move Field (207) on each field you wish to move. Test after each move.Use Move Function (198) to move methods to the new child. Start with lower\u00adlevelmethods (those being called rather than calling). Test after each move.Review the interfaces of both classes, remove unneeded methods, change names tobetter fit the new circumstances.Decide whether to expose the new child. If so, consider applying Change Referenceto Value (252) to the child class.",
        "Example": "I start with a simple person class:class Person...get name()    {return this._name;}set name(arg) {this._name = arg;}get telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`;}get officeAreaCode()    {return this._officeAreaCode;}set officeAreaCode(arg) {this._officeAreaCode = arg;}get officeNumber() {return this._officeNumber;}set officeNumber(arg) {this._officeNumber = arg;}Here. I can separate the telephone number behavior into its own class. I start bydefining an empty telephone number class:class TelephoneNumber {}That was easy! Next, I create an instance of telephone number when constructing theperson:class Person...constructor() {  this._telephoneNumber = new TelephoneNumber();}class TelephoneNumber...get officeAreaCode()    {return this._officeAreaCode;}set officeAreaCode(arg) {this._officeAreaCode = arg;}I then use Move Field (207) on one of the fields.class Person...get officeAreaCode()    {return this._telephoneNumber.officeAreaCode;}set officeAreaCode(arg) {this._telephoneNumber.officeAreaCode = arg;}I test, then move the next field.class TelephoneNumber...get officeNumber() {return this._officeNumber;}set officeNumber(arg) {this._officeNumber = arg;}class Person...get officeNumber() {return this._telephoneNumber.officeNumber;}set officeNumber(arg) {this._telephoneNumber.officeNumber = arg;}Test again, then move the telephone number method.class TelephoneNumber...get telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`;}class Person...get telephoneNumber() {return this._telephoneNumber.telephoneNumber;}Now I should tidy things up. Having \u201coffice\u201d as part of the telephone number codemakes no sense, so I rename them.class TelephoneNumber...get areaCode()    {return this._areaCode;}set areaCode(arg) {this._areaCode = arg;}get number()    {return this._number;}set number(arg) {this._number = arg;}class Person...get officeAreaCode()    {return this._telephoneNumber.areaCode;}set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg;}get officeNumber()    {return this._telephoneNumber.number;}set officeNumber(arg) {this._telephoneNumber.number = arg;}The telephone number method on the telephone number class also doesn\u2019t make muchsense, so I apply Rename Function (124).class TelephoneNumber...toString() {return `(${this.areaCode}) ${this.number}`;}class Person...get telephoneNumber() {return this._telephoneNumber.toString();}Telephone numbers are generally useful, so I think I\u2019ll expose the new object to clients.I can replace those \u201coffice\u201d methods with accessors for the telephone number. But thisway, the telephone number will work better as a Value Object [mf\u00advo], so I would applyChange Reference to Value (252) first (that refactoring\u2019s example shows how I\u2019d do thatfor the telephone number)."
    },
    "INLINE CLASS": {
        "Mechanics": "In the target class, create functions for all the public functions of the source class.These functions should just delegate to the source class.Change all references to source class methods so they use the target class\u2019sdelegators instead. Test after each change.Move all the functions and data from the source class into the target, testing aftereach move, until the source class is empty.Delete the source class and hold a short, simple funeral service.",
        "Example": "Here\u2019s a class that holds a couple of pieces of tracking information for a shipment.class TrackingInformation {  get shippingCompany()    {return this._shippingCompany;}  set shippingCompany(arg) {this._shippingCompany = arg;}  get trackingNumber()    {return this._trackingNumber;}  set trackingNumber(arg) {this._trackingNumber = arg;}  get display()            {    return `${this.shippingCompany}: ${this.trackingNumber}`;  }}It\u2019s used as part of a shipment class.class Shipment...get trackingInfo() {  return this._trackingInformation.display;}get trackingInformation()    {return this._trackingInformation;}set trackingInformation(aTrackingInformation) {  this._trackingInformation = aTrackingInformation;}While this class may have been worthwhile in the past, I no longer feel it\u2019s pulling itsweight, so I want to inline it into Shipment.I start by looking at places that are invoking the methods of TrackingInformation.caller...aShipment.trackingInformation.shippingCompany = request.vendor;I\u2019m going to move all such functions to Shipment, but I do it slightly differently to howI usually do Move Function (198). In this case, I start by putting a delegating methodinto the shipment, and adjusting the client to call that.class Shipment...set shippingCompany(arg) {this._trackingInformation.shippingCompany = arg;}caller...aShipment.trackingInformation.shippingCompany = request.vendor;I do this for all the elements of tracking information that are used by clients. Once I\u2019vedone that, I can move all the elements of the tracking information over into theshipment class.I start by applying Inline Function (115) to the display method.class Shipment...get trackingInfo() {  return `${this.shippingCompany}: ${this.trackingNumber}`;}I move the shipping company field.get shippingCompany()    {return this._trackingInformation._shippingCompany;}set shippingCompany(arg) {this._trackingInformation._shippingCompany = arg;}I don\u2019t use the full mechanics for Move Field (207) since in this case I only referenceshippingCompany from Shipment which is the target of the move. I thus don\u2019t needthe steps that put a reference from the source to the target.I continue until everything is moved over. Once I\u2019ve done that, I can delete the trackinginformation class.class Shipment...get trackingInfo() {  return `${this.shippingCompany}: ${this.trackingNumber}`;}get shippingCompany()    {return this._shippingCompany;}set shippingCompany(arg) {this._shippingCompany = arg;}get trackingNumber()    {return this._trackingNumber;}set trackingNumber(arg) {this._trackingNumber = arg;}"
    },
    "HIDE DELEGATE": {
        "Mechanics": "For each method on the delegate, create a simple delegating method on the server.Adjust the client to call the server. Test after each change.If no client needs to access the delegate anymore, remove the server\u2019s accessor forthe delegate.Test.",
        "Example": "I start with a person and a department.class Person...constructor(name) {  this._name = name;}get name() {return this._name;}get department()    {return this._department;}set department(arg) {this._department = arg;}class Department...get chargeCode()    {return this._chargeCode;}set chargeCode(arg) {this._chargeCode = arg;}get manager()    {return this._manager;}set manager(arg) {this._manager = arg;}Some client code wants to know the manager of a person. To do this, it needs to get thedepartment first.client code...manager = aPerson.department.manager;This reveals to the client how the department class works and that the department isresponsible for tracking the manager. I can reduce this coupling by hiding thedepartment class from the client. I do this by creating a simple delegating method onperson:class Person...get manager() {return this._department.manager;}I now need to change all clients of person to use this new method:client code...manager = aPerson.department.manager;Once I\u2019ve made the change for all methods of department and for all the clients ofperson, I can remove the department accessor on person."
    },
    "REMOVE MIDDLE MAN": {
        "Mechanics": "Create a getter for the delegate.For each client use of a delegating method, replace the call to the delegating methodby chaining through the accessor. Test after each replacement.If all calls to a delegating method are replaced, you can delete the delegatingmethod.With automated refactorings, you can use Encapsulate Variable (132) on thedelegate field and then Inline Function (115) on all the methods that use it.",
        "Example": "I begin with a person class that uses a linked department object to determine amanager. (If you\u2019re reading this book sequentially, this example may look eerilyfamiliar.)client code...manager = aPerson.manager;class Person...get manager() {return this._department.manager;}class Department...get manager()   {return this._manager;}This is simple to use and encapsulates the department. However, if lots of methods aredoing this, I end up with too many of these simple delegations on the person. That\u2019swhen it is good to remove the middle man. First, I make an accessor for the delegate:class Person...get department()   {return this._department;}Now I go to each client at a time and modify them to use the department directly.client code...manager = aPerson.department.manager;Once I\u2019ve done this with all the clients, I can remove the manager method fromPerson. I can repeat this process for any other simple delegations on Person.I can do a mixture here. Some delegations may be so common that I\u2019d like to keep themto make client code easier to work with. There is no absolute reason why I should eitherhide a delegate or remove a middle man\u2014particular circumstances suggest whichapproach to take, and reasonable people can differ on what works best.If I have automated refactorings, then there\u2019s a useful variation on these steps. First, Iuse Encapsulate Variable (132) on department. This changes the manager getter touse the public department getter:class Person...get manager() {return this.department.manager;}The change is rather too subtle in JavaScript, but by removing the underscore fromdepartment I\u2019m using the new getter rather than accessing the field directly.Then I apply Inline Function (115) on the manager method to replace all the callers atonce."
    },
    "SUBSTITUTE ALGORITHM": {
        "Mechanics": "Arrange the code to be replaced so that it fills a complete function.Prepare tests using this function only, to capture its behavior.Prepare your alternative algorithm.Run static checks.Run tests to compare the output of the old algorithm to the new one. If they are thesame, you\u2019re done. Otherwise, use the old algorithm for comparison in testing anddebugging.So far, the refactorings have been about creating, removing, and renaming programelements. Another important part of refactoring is moving elements between contexts. Iuse Move Function (198) to move functions between classes and other modules. Fieldscan move too, with Move Field (207).I also move individual statements around. I use Move Statements into Function (213)and Move Statements to Callers (217) to move them in or out of functions, as well asSlide Statements (223) to move them within a function. Sometimes, I can take somestatements that match an existing function and use Replace Inline Code with FunctionCall (222) to remove the duplication.Two refactorings I often do with loops are Split Loop (227), to ensure a loop does onlyone thing, and Replace Loop with Pipeline (231) to get rid of a loop entirely.And then there\u2019s the favorite refactoring of many a fine programmer: Remove DeadCode (237). Nothing is as satisfying as applying the digital flamethrower to superfluousstatements."
    },
    "MOVE FUNCTION": {
        "Mechanics": "Examine all the program elements used by the chosen function in its currentcontext. Consider whether they should move too.If I find a called function that should also move, I usually move it first. That way,moving a clusters of functions begins with the one that has the least dependency onthe others in the group.If a high\u00adlevel function is the only caller of subfunctions, then you can inline thosefunctions into the high\u00adlevel method, move, and reextract at the destination.Check if the chosen function is a polymorphic method.If I\u2019m in an object\u00adoriented language, I have to take account of super\u00ad and subclassdeclarations.Copy the function to the target context. Adjust it to fit in its new home.If the body uses elements in the source context, I need to either pass those elementsas parameters or pass a reference to that source context.Moving a function often means I need to come up with a different name that worksbetter in the new context.Perform static analysis.Figure out how to reference the target function from the source context.Turn the source function into a delegating function.Test.Consider Inline Function (115) on the source function.The source function can stay indefinitely as a delegating function. But if its callerscan just as easily reach the target directly, then it\u2019s better to remove the middleman.",
        "Example: Moving a Nested Function to Top Level": "I\u2019ll begin with a function that calculates the total distance for a GPS track record.function trackSummary(points) {  const totalTime = calculateTime();  const totalDistance = calculateDistance();  const pace = totalTime / 60 /  totalDistance ;  return {    time: totalTime,    distance: totalDistance,    pace: pace  };  function calculateDistance() {    let result = 0;    for (let i = 1; i < points.length; i++) {      result += distance(points[i\u00ad1], points[i]);    }    return result;  } function distance(p1,p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }}I\u2019d like to move calculateDistance to the top level so I can calculate distances fortracks without all the other parts of the summary.I begin by copying the function to the top level.function trackSummary(points) {  const totalTime = calculateTime();  const totalDistance = calculateDistance();  const pace = totalTime / 60 /  totalDistance ;  return {    time: totalTime,    distance: totalDistance,    pace: pace  };  function calculateDistance() {    let result = 0;    for (let i = 1; i < points.length; i++) {      result += distance(points[i\u00ad1], points[i]);    }    return result;  }  ... function distance(p1,p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }}  function top_calculateDistance() {    let result = 0;    for (let i = 1; i < points.length; i++) {      result += distance(points[i\u00ad1], points[i]);    }    return result;  }When I copy a function like this, I like to change the name so I can distinguish themboth in the code and in my head. I don\u2019t want to think about what the right nameshould be right now, so I create a temporary name.The program still works, but my static analysis is rightly rather upset. The new functionhas two undefined symbols: distance and points. The natural way to deal withpoints is to pass it in as a parameter.function top_calculateDistance(points) {  let result = 0;  for (let i = 1; i < points.length; i++) {    result += distance(points[i\u00ad1], points[i]);  }  return result;}I could do the same with distance, but perhaps it makes sense to move it togetherwith calculateDistance. Here\u2019s the relevant code:function trackSummary...function distance(p1,p2) {  // haversine formula see http://www.movable\u00adtype.co.uk/scripts/latlong.html  const EARTH_RADIUS = 3959; // in miles  const dLat = radians(p2.lat) \u00ad radians(p1.lat);  const dLon = radians(p2.lon) \u00ad radians(p1.lon);  const a = Math.pow(Math.sin(dLat / 2),2)          + Math.cos(radians(p2.lat))          * Math.cos(radians(p1.lat))          * Math.pow(Math.sin(dLon / 2), 2);  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1\u00ada));  return EARTH_RADIUS * c;}function radians(degrees) {  return degrees * Math.PI / 180;}I can see that distance only uses radians and radians doesn\u2019t use anything insideits current context. So rather than pass the functions, I might as well move them too. Ican make a small step in this direction by moving them from their current context tonest them inside the nested calculateDistance.function trackSummary(points) {  const totalTime = calculateTime();  const totalDistance = calculateDistance();  const pace = totalTime / 60 /  totalDistance ;  return {    time: totalTime,    distance: totalDistance,    pace: pace  };  function calculateDistance() {    let result = 0;    for (let i = 1; i < points.length; i++) {      result += distance(points[i\u00ad1], points[i]);    }    return result;    function distance(p1,p2) { ... }    function radians(degrees) { ... }  }By doing this, I can use both static analysis and testing to tell me if there are anycomplications. In this case all is well, so I can copy them over totop_calculateDistance.function top_calculateDistance(points) {  let result = 0;  for (let i = 1; i < points.length; i++) {    result += distance(points[i\u00ad1], points[i]);  }  return result; function distance(p1,p2) { ... } function radians(degrees) { ... }}Again, the copy doesn\u2019t change how the program runs, but does give me an opportunityfor more static analysis. Had I not spotted that distance calls radians, the linterwould have caught it at this step.Now that I have prepared the table, it\u2019s time for the major change\u2014the body of theoriginal calculateDistance will now call top_calculateDistance:function trackSummary(points) {  const totalTime = calculateTime();  const totalDistance = calculateDistance();  const pace = totalTime / 60 /  totalDistance ;  return {    time: totalTime,    distance: totalDistance,    pace: pace  };  function calculateDistance() {    return top_calculateDistance(points);  }This is the crucial time to run tests to fully test that the moved function has beddeddown in its new home.With that done, it\u2019s like unpacking the boxes after moving house. The first thing is todecide whether to keep the original function that\u2019s just delegating or not. In this case,there are few callers and, as usual with nested functions, they are highly localized. SoI\u2019m happy to get rid of it.function trackSummary(points) {  const totalTime = calculateTime();  const totalDistance = top_calculateDistance(points);  const pace = totalTime / 60 /  totalDistance ;  return {    time: totalTime,    distance: totalDistance,    pace: pace  };Now is also a good time to think about what I want the name to be. Since the top\u00adlevelfunction has the highest visibility, I\u2019d like it to have the best name. totalDistanceseems like a good choice. I can\u2019t use that immediately since it will be shadowed by thevariable inside trackSummary\u2014but I don\u2019t see any reason to keep that anyway, so Iuse Inline Variable (123) on it.function trackSummary(points) {  const totalTime = calculateTime();  const pace = totalTime / 60 /  totalDistance(points) ;  return {    time: totalTime,    distance: totalDistance(points),    pace: pace  };function totalDistance(points) {  let result = 0;  for (let i = 1; i < points.length; i++) {    result += distance(points[i\u00ad1], points[i]);  }  return result;If I\u2019d had the need to keep the variable, I\u2019d have renamed it to something liketotalDistanceCache or distance.Since the functions for distance and radians don\u2019t depend on anything insidetotalDistance, I prefer to move them to top level too, putting all four functions atthe top level.function trackSummary(points) { ... }function totalDistance(points) { ... }function distance(p1,p2) { ... }function radians(degrees) { ... }Some people would prefer to keep distance and radians inside totalDistance inorder to restrict their visibility. In some languages that may be a consideration, but withES 2015, JavaScript has an excellent module mechanism that\u2019s the best tool forcontrolling function visibility. In general, I\u2019m wary of nested functions\u2014they too easilyset up hidden data interrelationships that can get hard to follow.",
        "Example: Moving between Classes": "To illustrate this variety of Move Function, I\u2019ll start here:class Account...get bankCharge() {  let result = 4.5;  if (this._daysOverdrawn > 0) result += this.overdraftCharge;  return result;}get overdraftCharge() {  if (this.type.isPremium) {    const baseCharge = 10;    if (this.daysOverdrawn <= 7)      return baseCharge;    else      return baseCharge + (this.daysOverdrawn \u00ad 7) * 0.85;  }  else    return this.daysOverdrawn * 1.75;}Coming up are changes that lead to different types of account having differentalgorithms for determining the charge. Thus it seems natural to moveoverdraftCharge to the account type class.The first step is to look at the features that the overdraftCharge method uses andconsider whether it is worth moving a batch of methods together. In this case I need thedaysOverdrawn method to remain on the account class, because that will vary withindividual accounts.Next, I copy the method body over to the account type and get it to fit.class AccountType...overdraftCharge(daysOverdrawn) {  if (this.isPremium) {    const baseCharge = 10;    if (daysOverdrawn <= 7)      return baseCharge;    else      return baseCharge + (daysOverdrawn \u00ad 7) * 0.85;  }  else    return daysOverdrawn * 1.75;}In order to get the method to fit in its new location, I need to deal with two call targetsthat change their scope. isPremium is now a simple call on this. WithdaysOverdrawn I have to decide\u2014do I pass the value or do I pass the account? For themoment, I just pass the simple value but I may well change this in the future if I requiremore than just the days overdrawn from the account\u2014especially if what I want from theaccount varies with the account type.Next, I replace the original method body with a delegating call.class Account...get bankCharge() {  let result = 4.5;  if (this._daysOverdrawn > 0) result += this.overdraftCharge;  return result;}get overdraftCharge() {  return this.type.overdraftCharge(this.daysOverdrawn);}Then comes the decision of whether to leave the delegation in place or to inlineoverdraftCharge. Inlining results in:class Account...get bankCharge() {  let result = 4.5;  if (this._daysOverdrawn > 0)    result += this.type.overdraftCharge(this.daysOverdrawn);  return result;}In the earlier steps, I passed daysOverdrawn as a parameter\u2014but if there\u2019s a lot ofdata from the account to pass, I might prefer to pass the account itself.class Account...get bankCharge() {  let result = 4.5;  if (this._daysOverdrawn > 0) result += this.overdraftCharge;  return result;}get overdraftCharge() {  return this.type.overdraftCharge(this);}class AccountType...overdraftCharge(account) {  if (this.isPremium) {    const baseCharge = 10;    if (account.day>sOverdrawn <= 7)      return baseCharge;    else      return baseCharge + (account.daysOverdrawn \u00ad 7) * 0.85;  }  else    return account.daysOverdrawn * 1.75;}"
    },
    "MOVE FIELD": {
        "Mechanics": "Ensure the source field is encapsulated.Test.Create a field (and accessors) in the target.Run static checks.Ensure there is a reference from the source object to the target object.An existing field or method may give you the target. If not, see if you can easilycreate a method that will do so. Failing that, you may need to create a new field inthe source object that can store the target. This may be a permanent change, but youcan also do it temporarily until you have done enough refactoring in the broadercontext.Adjust accessors to use the target field.If the target is shared between source objects, consider first updating the setter tomodify both target and source fields, followed by Introduce Assertion (302) todetect inconsistent updates. Once you determine all is well, finish changing theaccessors to use the target field.Test.Remove the source field.Test.",
        "Example": "I\u2019m starting here with this customer and contract:class Customer...constructor(name, discountRate) {  this._name = name;  this._discountRate = discountRate;  this._contract = new CustomerContract(dateToday());}get discountRate() {return this._discountRate;}becomePreferred() {  this._discountRate += 0.03;  // other nice things}applyDiscount(amount) {  return amount.subtract(amount.multiply(this._discountRate));}class CustomerContract...constructor(startDate) {  this._startDate = startDate;}I want to move the discount rate field from the customer to the customer contract.The first thing I need to use is Encapsulate Variable (132) to encapsulate access to thediscount rate field.class Customer...constructor(name, discountRate) {  this._name = name;  this._setDiscountRate(discountRate);  this._contract = new CustomerContract(dateToday());}get discountRate() {return this._discountRate;}_setDiscountRate(aNumber) {this._discountRate = aNumber;}becomePreferred() {  this._setDiscountRate(this.discountRate + 0.03);  // other nice things}applyDiscount(amount) {  return amount.subtract(amount.multiply(this.discountRate));}I use a method to update the discount rate, rather than a property setter, as I don\u2019t wantto make a public setter for the discount rate.I add a field and accessors to the customer contract.class CustomerContract...constructor(startDate, discountRate) {  this._startDate = startDate;  this._discountRate = discountRate;}get discountRate()    {return this._discountRate;}set discountRate(arg) {this._discountRate = arg;}I now modify the accessors on customer to use the new field. When I did that, I got anerror: \u201cCannot set property \u2019discountRate\u2019 of undefined\u201d. This was because_setDiscountRate was called before I created the contract object in the constructor.To fix that, I first reverted to the previous state, then used Slide Statements (223) tomove the _setDiscountRate after creating the contract.class Customer...constructor(name, discountRate) {  this._name = name;  this._setDiscountRate(discountRate);  this._contract = new CustomerContract(dateToday());}I tested that, then changed the accessors again to use the contract.class Customer...get discountRate() {return this._contract.discountRate;}_setDiscountRate(aNumber) {this._contract.discountRate = aNumber;}Since I\u2019m using JavaScript, there is no declared source field, so I don\u2019t need to removeanything further.",
        "Changing a Bare Record": "This refactoring is generally easier with objects, since encapsulation provides a naturalway to wrap data access in methods. If I have many functions accessing a bare record,then, while it\u2019s still a valuable refactoring, it is decidedly more tricky.I can create accessor functions and modify all the reads and writes to use them. If thefield that\u2019s being moved is immutable, I can update both the source and the target fieldswhen I set its value and gradually migrate reads. Still, if possible, my first move wouldbe to use Encapsulate Record (162) to turn the record into a class so I can make thechange more easily.",
        "Example: Moving to a Shared Object": "Now, let\u2019s consider a different case. Here\u2019s an account with an interest rate:class Account...constructor(number, type, interestRate) {  this._number = number;  this._type = type;  this._interestRate = interestRate;}get interestRate() {return this._interestRate;}class AccountType...constructor(nameString) {  this._name = nameString;}I want to change things so that an account\u2019s interest rate is determined from its accounttype.The access to the interest rate is already nicely encapsulated, so I\u2019ll just create the fieldand an appropriate accessor on the account type.class AccountType...constructor(nameString, interestRate) {  this._name = nameString;  this._interestRate = interestRate;}get interestRate() {return this._interestRate;}But there is a potential problem when I update the accesses from account. Before thisrefactoring, each account had its own interest rate. Now, I want all accounts to sharethe interest rates of their account type. If all the accounts of the same type already havethe same interest rate, then there\u2019s no change in observable behavior, so I\u2019m fine withthe refactoring. But if there\u2019s an account with a different interest rate, it\u2019s no longer arefactoring. If my account data is held in a database, I should check the database toensure that all my accounts have the rate matching their type. I can also IntroduceAssertion (302) in the account class.class Account...constructor(number, type, interestRate) {  this._number = number;  this._type = type;  assert(interestRate === this._type.interestRate);  this._interestRate = interestRate;}get interestRate() {return this._interestRate;}I might run the system for a while with this assertion in place to see if I get an error. Or,instead of adding an assertion, I might log the problem. Once I\u2019m confident that I\u2019m notintroducing an observable change, I can change the access, removing the update fromthe account completely.class Account...constructor(number, type) {  this._number = number;  this._type = type;}get interestRate() {return this._type.interestRate;}"
    },
    "MOVE STATEMENTS INTO FUNCTION": {
        "Mechanics": "If the repetitive code isn\u2019t adjacent to the call of the target function, use SlideStatements (223) to get it adjacent.If the target function is only called by the source function, just cut the code from thesource, paste it into the target, test, and ignore the rest of these mechanics.If you have more callers, use Extract Function (106) on one of the call sites toextract both the call to the target function and the statements you wish to move intoit. Give it a name that\u2019s transient, but easy to grep.Convert every other call to use the new function. Test after each conversion.When all the original calls use the new function, use Inline Function (115) to inlinethe original function completely into the new function, removing the originalfunction.Rename Function (124) to change the name of the new function to the same nameas the original function.Or to a better name, if there is one.",
        "Example": "I\u2019ll start with this code to emit HTML for data about a photo:function renderPerson(outStream, person) {  const result = [];  result.push(`<p>${person.name}</p>`);  result.push(renderPhoto(person.photo));  result.push(`<p>title: ${person.photo.title}</p>`);  result.push(emitPhotoData(person.photo));  return result.join(\"\\n\");}function photoDiv(p) {  return [    \"<div>\",    `<p>title: ${p.title}</p>`,    emitPhotoData(p),    \"</div>\",  ].join(\"\\n\");}function emitPhotoData(aPhoto) {  const result = [];  result.push(`<p>location: ${aPhoto.location}</p>`);  result.push(`<p>date: ${aPhoto.date.toDateString()}</p>`);  return result.join(\"\\n\");}This code shows two calls to emitPhotoData, each preceded by a line of code that issemantically equivalent. I\u2019d like to remove this duplication by moving the title printinginto emitPhotoData. If I had just the one caller, I would just cut and paste the code,but the more callers I have, the more I\u2019m inclined to use a safer procedure.I begin by using Extract Function (106) on one of the callers. I\u2019m extracting thestatements I want to move into emitPhotoData, together with the call toemitPhotoData itself.function photoDiv(p) {  return [    \"<div>\",    zznew(p),    \"</div>\",  ].join(\"\\n\");}function zznew(p) {  return [    `<p>title: ${p.title}</p>`,    emitPhotoData(p),  ].join(\"\\n\");}I can now look at the other callers of emitPhotoData and, one by one, replace thecalls and the preceding statements with calls to the new function.function renderPerson(outStream, person) {  const result = [];  result.push(`<p>${person.name}</p>`);  result.push(renderPhoto(person.photo));  result.push(zznew(person.photo));  return result.join(\"\\n\");}Now that I\u2019ve done all the callers, I use Inline Function (115) on emitPhotoData:function zznew(p) {  return [    `<p>title: ${p.title}</p>`,    `<p>location: ${p.location}</p>`,    `<p>date: ${p.date.toDateString()}</p>`,  ].join(\"\\n\");}and finish with Rename Function (124):function renderPerson(outStream, person) {  const result = [];  result.push(`<p>${person.name}</p>`);  result.push(renderPhoto(person.photo));  result.push(emitPhotoData(person.photo));  return result.join(\"\\n\");}function photoDiv(aPhoto) {  return [    \"<div>\",    emitPhotoData(aPhoto),    \"</div>\",  ].join(\"\\n\");}function emitPhotoData(aPhoto) {  return [    `<p>title: ${aPhoto.title}</p>`,    `<p>location: ${aPhoto.location}</p>`,    `<p>date: ${aPhoto.date.toDateString()}</p>`,  ].join(\"\\n\");}I also make the parameter names fit my convention while I\u2019m at it."
    },
    "MOVE STATEMENTS TO CALLERS": {
        "Mechanics": "In simple circumstances, where you have only one or two callers and a simplefunction to call from, just cut the first line from the called function and paste (andperhaps fit) it into the callers. Test and you\u2019re done.Otherwise, apply Extract Function (106) to all the statements that you don\u2019t wish tomove; give it a temporary but easily searchable name.If the function is a method that is overridden by subclasses, do the extraction on allof them so that the remaining method is identical in all classes. Then remove thesubclass methods.Use Inline Function (115) on the original function.Apply Change Function Declaration (124) on the extracted function to rename it tothe original name.Or to a better name, if you can think of one.",
        "Example": "Here\u2019s a simple case: a function with two callers.function renderPerson(outStream, person) {  outStream.write(`<p>${person.name}</p>\\n`);  renderPhoto(outStream, person.photo);  emitPhotoData(outStream, person.photo);}function listRecentPhotos(outStream, photos) {  photos    .filter(p => p.date > recentDateCutoff())    .forEach(p => {      outStream.write(\"<div>\\n\");      emitPhotoData(outStream, p);      outStream.write(\"</div>\\n\");    });}function emitPhotoData(outStream, photo) {  outStream.write(`<p>title: ${photo.title}</p>\\n`);  outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`);  outStream.write(`<p>location: ${photo.location}</p>\\n`);}I need to modify the software so that listRecentPhotos renders the locationinformation differently while renderPerson stays the same. To make this changeeasier, I\u2019ll use Move Statements to Callers on the final line.Usually, when faced with something this simple, I\u2019ll just cut the last line fromrenderPerson and paste it below the two calls. But since I\u2019m explaining what to do inmore tricky cases, I\u2019ll go through the more elaborate but safer procedure.My first step is to use Extract Function (106) on the code that will remain inemitPhotoData.function renderPerson(outStream, person) {  outStream.write(`<p>${person.name}</p>\\n`);  renderPhoto(outStream, person.photo);  emitPhotoData(outStream, person.photo);}function listRecentPhotos(outStream, photos) {  photos    .filter(p => p.date > recentDateCutoff())    .forEach(p => {      outStream.write(\"<div>\\n\");      emitPhotoData(outStream, p);      outStream.write(\"</div>\\n\");    });}function emitPhotoData(outStream, photo) {  zztmp(outStream, photo);  outStream.write(`<p>location: ${photo.location}</p>\\n`);}function zztmp(outStream, photo) {  outStream.write(`<p>title: ${photo.title}</p>\\n`);  outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`);}Usually, the name of the extracted function is only temporary, so I don\u2019t worry aboutcoming up with anything meaningful. However, it is helpful to use something that\u2019seasy to grep. I can test at this point to ensure the code works over the function callboundary.Now I use Inline Function (115), one call at a time. I start with renderPerson.function renderPerson(outStream, person) {  outStream.write(`<p>${person.name}</p>\\n`);  renderPhoto(outStream, person.photo);  zztmp(outStream, person.photo);  outStream.write(`<p>location: ${person.photo.location}</p>\\n`);}function listRecentPhotos(outStream, photos) {  photos    .filter(p => p.date > recentDateCutoff())    .forEach(p => {      outStream.write(\"<div>\\n\");      emitPhotoData(outStream, p);      outStream.write(\"</div>\\n\");    });}function emitPhotoData(outStream, photo) {  zztmp(outStream, photo);  outStream.write(`<p>location: ${photo.location}</p>\\n`);}function zztmp(outStream, photo) {  outStream.write(`<p>title: ${photo.title}</p>\\n`);  outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`);}I test again to ensure this call is working properly, then move onto the next.function renderPerson(outStream, person) {  outStream.write(`<p>${person.name}</p>\\n`);  renderPhoto(outStream, person.photo);  zztmp(outStream, person.photo);  outStream.write(`<p>location: ${person.photo.location}</p>\\n`);}function listRecentPhotos(outStream, photos) {  photos    .filter(p => p.date > recentDateCutoff())    .forEach(p => {      outStream.write(\"<div>\\n\");      zztmp(outStream, p);      outStream.write(`<p>location: ${p.location}</p>\\n`);      outStream.write(\"</div>\\n\");    });}function emitPhotoData(outStream, photo) {  zztmp(outStream, photo);  outStream.write(`<p>location: ${photo.location}</p>\\n`);}function zztmp(outStream, photo) {  outStream.write(`<p>title: ${photo.title}</p>\\n`);  outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`);}Then I can delete the outer function, completing Inline Function (115).function renderPerson(outStream, person) {  outStream.write(`<p>${person.name}</p>\\n`);  renderPhoto(outStream, person.photo);  zztmp(outStream, person.photo);  outStream.write(`<p>location: ${person.photo.location}</p>\\n`);}function listRecentPhotos(outStream, photos) {  photos    .filter(p => p.date > recentDateCutoff())    .forEach(p => {      outStream.write(\"<div>\\n\");      zztmp(outStream, p);      outStream.write(`<p>location: ${p.location}</p>\\n`);      outStream.write(\"</div>\\n\");    });}function emitPhotoData(outStream, photo) {  zztmp(outStream, photo);  outStream.write(`<p>location: ${photo.location}</p>\\n`);}function zztmp(outStream, photo) {  outStream.write(`<p>title: ${photo.title}</p>\\n`);  outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`);}I then rename zztmp back to the original name.function renderPerson(outStream, person) {  outStream.write(`<p>${person.name}</p>\\n`);  renderPhoto(outStream, person.photo);  emitPhotoData(outStream, person.photo);  outStream.write(`<p>location: ${person.photo.location}</p>\\n`);}function listRecentPhotos(outStream, photos) {  photos    .filter(p => p.date > recentDateCutoff())    .forEach(p => {      outStream.write(\"<div>\\n\");      emitPhotoData(outStream, p);      outStream.write(`<p>location: ${p.location}</p>\\n`);      outStream.write(\"</div>\\n\");    });}function emitPhotoData(outStream, photo) {  outStream.write(`<p>title: ${photo.title}</p>\\n`);  outStream.write(`<p>date: ${photo.date.toDateString()}</p>\\n`);}"
    },
    "REPLACE INLINE CODE WITH FUNCTION CALL": {
        "Mechanics": "Replace the inline code with a call to the existing function.Test."
    },
    "SLIDE STATEMENTS": {
        "Mechanics": "Identify the target position to move the fragment to. Examine statements betweensource and target to see if there is interference for the candidate fragment. Abandonaction if there is any interference.A fragment cannot slide backwards earlier than any element it references isdeclared.A fragment cannot slide forwards beyond any element that references it.A fragment cannot slide over any statement that modifies an element it references.A fragment that modifies an element cannot slide over any other element thatreferences the modified element.Cut the fragment from the source and paste into the target position.Test.If the test fails, try breaking down the slide into smaller steps. Either slide over lesscode or reduce the amount of code in the fragment you\u2019re moving.",
        "Example": "When sliding code fragments, there are two decisions involved: what slide I\u2019d like to doand whether I can do it. The first decision is very context\u00adspecific. On the simplest level,I like to declare elements close to where I use them, so I\u2019ll often slide a declarationdown to its usage. But almost always I slide some code because I want to do anotherrefactoring\u2014perhaps to get a clump of code together to Extract Function (106).Once I have a sense of where I\u2019d like to move some code, the next part is deciding if Ican do it. This involves looking at the code I\u2019m sliding and the code I\u2019m sliding over: Dothey interfere with each other in a way that would change the observable behavior ofthe program?Consider the following fragment of code: 1 const pricingPlan = retrievePricingPlan(); 2 const order = retreiveOrder(); 3 const baseCharge = pricingPlan.base; 4 let charge; 5 const chargePerUnit = pricingPlan.unit; 6 const units = order.units; 7 let discount; 8 charge = baseCharge + units * chargePerUnit; 9 let discountableUnits = Math.max(units \u00ad pricingPlan.discountThreshold, 0);10 discount = discountableUnits * pricingPlan.discountFactor;11 if (order.isRepeat) discount += 20;12 charge = charge \u00ad discount;13 chargeOrder(charge);The first seven lines are declarations, and it\u2019s relatively easy to move these. Forexample, I may want to move all the code dealing with discounts together, which wouldinvolve moving line 7 (`let discount`) to above line 10 (`discount = ...`).Since a declaration has no side effects and refers to no other variable, I can safely movethis forwards as far as the first line that references discount itself. This is also acommon move\u2014if I want to use Extract Function (106) on the discount logic, I\u2019ll needto move the declaration down first.I do similar analysis with any code that doesn\u2019t have side effects. So I can take line 2(`const order = ...`) and move it down to above line 6 (`const units =...`) without trouble.In this case, I\u2019m also helped by the fact that the code I\u2019m moving over doesn\u2019t have sideeffects either. Indeed, I can freely rearrange code that lacks side effects to my heart\u2019scontent, which is one of the reasons why wise programmers prefer to use side\u00adeffect\u00adfree code as much as possible.There is a wrinkle here, however. How do I know that line 2 is side\u00adeffect\u00adfree? To besure, I\u2019d need to look inside retrieveOrder() to ensure there are no side effectsthere (and inside any functions it calls, and inside any functions its functions call, andso on). In practice, when working on my own code, I know that I generally follow theCommand\u00adQuery Separation [mf\u00adcqs] principle, so any function that returns a value isfree of side effects. But I can only be confident of that because I know the code base; if Iwere working in an unknown code base, I\u2019d have to be more cautious. But I do try tofollow the Command\u00adQuery Separation in my own code because it\u2019s so valuable to knowthat code is free of side effects.When sliding code that has a side effect, or sliding over code with side effects, I have tobe much more careful. What I\u2019m looking for is interference between the two codefragments. So, let\u2019s say I want to slide line 11 (`if (order.isRepeat) ...`) downto the end. I\u2019m prevented from doing that by line 12 because it references the variablewhose state I\u2019m changing in line 11. Similarly, I can\u2019t take line 13(`chargeOrder(charge)`) and move it up because line 12 modifies some state thatline 13 references. However, I can slide line 8 (`charge = baseCharge + ...`)over lines 9\u201311 because there they don\u2019t modify any common state.The most straightforward rule to follow is that I can\u2019t slide one fragment of code overanother if any data that both fragments refer to is modified by either one. But that\u2019s nota comprehensive rule; I can happily slide either of the following two lines over theother:a = a + 10;a = a + 5;But judging whether a slide is safe means I have to really understand the operationsinvolved and how they compose.Since I need to worry so much about updating state, I look to remove as much of it as Ican. So with this code, I\u2019d be looking to apply Split Variable (240) on charge before Iindulge in any sliding around of that code.Here, the analysis is relatively simple because I\u2019m mostly just modifying local variables.With more complex data structures, it\u2019s much harder to be sure when I get interference.So tests play an important role: Slide the fragment, run tests, see if things break. If mytest coverage is good, I can feel happy with the refactoring. But if tests aren\u2019t reliable, Ineed to be more wary\u2014or, more likely, to improve the tests for the code I\u2019m working on.The most important consequence of a test failure after a slide is to use smaller slides:Instead of sliding over ten lines, I\u2019ll just pick five, or slide up to what I reckon is adangerous line. It may also mean that the slide isn\u2019t worth it, and I need to work onsomething else first.",
        "Example: Sliding with Conditionals": "I can also do slides with conditionals. This will either involve removing duplicate logicwhen I slide out of a conditional, or adding duplicate logic when I slide in.Here\u2019s a case where I have the same statements in both legs of a conditional:let result;if (availableResources.length === 0) {  result = createResource();  allocatedResources.push(result);} else {  result = availableResources.pop();  allocatedResources.push(result);}return result;I can slide these out of the conditional, in which case they turn into a single statementoutside of the conditional block.let result;if (availableResources.length === 0) {  result = createResource();} else {  result = availableResources.pop();}allocatedResources.push(result);return result;In the reverse case, sliding a fragment into a conditional means repeating it in every legof the conditional.",
        "Further Reading": "I\u2019ve seen an almost identical refactoring under the name of Swap Statement [wake\u00adswap]. Swap Statement moves adjacent fragments, but it only works with single\u00adstatement fragments. You can think of it as Slide Statements where both the slidingfragment and the slid\u00adover fragment are single statements. This refactoring appeals tome; after all, I\u2019m always going on about taking small steps\u2014steps that may seemridiculously small to those new to refactoring.But I ended up writing this refactoring with larger fragments because that is what I do.I only move one statement at a time if I\u2019m having difficulty with a larger slide, and Irarely run into problems with larger slides. With more messy code, however, smallerslides end up being easier."
    },
    "SPLIT LOOP": {
        "Mechanics": "Copy the loop.Identify and eliminate duplicate side effects.Test.When done, consider Extract Function (106) on each loop.",
        "Example": "I\u2019ll start with a little bit of code that calculates the total salary and youngest age.let youngest = people[0] ? people[0].age : Infinity;let totalSalary = 0;for (const p of people) {  if (p.age < youngest) youngest = p.age;  totalSalary += p.salary;}return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;It\u2019s a very simple loop, but it\u2019s doing two different calculations. To split them, I beginwith just copying the loop.let youngest = people[0] ? people[0].age : Infinity;let totalSalary = 0;for (const p of people) {  if (p.age < youngest) youngest = p.age;  totalSalary += p.salary;}for (const p of people) {  if (p.age < youngest) youngest = p.age;  totalSalary += p.salary;}return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;With the loop copied, I need to remove the duplication that would otherwise producewrong results. If something in the loop has no side effects, I can leave it there for now,but it\u2019s not the case with this example.let youngest = people[0] ? people[0].age : Infinity;let totalSalary = 0;for (const p of people) {  if (p.age < youngest) youngest = p.age;  totalSalary += p.salary;}for (const p of people) {  if (p.age < youngest) youngest = p.age;  totalSalary += p.salary;}return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;Officially, that\u2019s the end of the Split Loop refactoring. But the point of Split Loop isn\u2019twhat it does on its own but what it sets up for the next move\u2014and I\u2019m usually lookingto extract the loops into their own functions. I\u2019ll use Slide Statements (223) toreorganize the code a bit first.let totalSalary = 0;for (const p of people) {  totalSalary += p.salary;}let youngest = people[0] ? people[0].age : Infinity;for (const p of people) {  if (p.age < youngest) youngest = p.age;}return `youngestAge: ${youngest}, totalSalary: ${totalSalary}`;Then I do a couple of Extract Function (106).return `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;function totalSalary() {  let totalSalary = 0;  for (const p of people) {    totalSalary += p.salary;  }  return totalSalary;}function youngestAge() {  let youngest = people[0] ? people[0].age : Infinity;  for (const p of people) {    if (p.age < youngest) youngest = p.age;  }  return youngest;}I can rarely resist Replace Loop with Pipeline (231) for the total salary, and there\u2019s anobvious Substitute Algorithm (195) for the youngest age.return `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`;function totalSalary() {  return people.reduce((total,p) => total + p.salary, 0);}function youngestAge() {  return Math.min(...people.map(p => p.age));}"
    },
    "REPLACE LOOP WITH PIPELINE": {
        "Mechanics": "Create a new variable for the loop\u2019s collection.This may be a simple copy of an existing variable.Starting at the top, take each bit of behavior in the loop and replace it with acollection pipeline operation in the derivation of the loop collection variable. Testafter each change.Once all behavior is removed from the loop, remove it.If it assigns to an accumulator, assign the pipeline result to the accumulator.",
        "Example": "I\u2019ll begin with some data: a CSV file of data about our offices.office, country, telephoneChicago, USA, +1 312 373 1000Beijing, China, +86 4008 900 505Bangalore, India, +91 80 4064 9570Porto Alegre, Brazil, +55 51 3079 3550Chennai, India, +91 44 660 44766... (more data follows)The following function picks out the offices in India and returns their cities andtelephone numbers:function acquireData(input) {  const lines = input.split(\"\\n\");  let firstLine = true;  const result = [];  for (const line of lines) {    if (firstLine) {      firstLine = false;      continue;    }    if (line.trim() === \"\") continue;    const record = line.split(\",\");    if (record[1].trim() === \"India\") {      result.push({city: record[0].trim(), phone: record[2].trim()});    }  }  return result;}I want to replace that loop with a collection pipeline.My first step is to create a separate variable for the loop to work over.function acquireData(input) {  const lines = input.split(\"\\n\");  let firstLine = true;  const result = [];  const loopItems = lines  for (const line of loopItems) {    if (firstLine) {      firstLine = false;      continue;    }    if (line.trim() === \"\") continue;    const record = line.split(\",\");    if (record[1].trim() === \"India\") {      result.push({city: record[0].trim(), phone: record[2].trim()});    }  }  return result;}The first part of the loop is all about skipping the first line of the CSV file. This calls fora slice, so I remove that first section of the loop and add a slice operation to theformation of the loop variable.function acquireData(input) {  const lines = input.split(\"\\n\");  let firstLine = true;  const result = [];  const loopItems = lines        .slice(1);  for (const line of loopItems) {    if (firstLine) {      firstLine = false;      continue;    }    if (line.trim() === \"\") continue;    const record = line.split(\",\");    if (record[1].trim() === \"India\") {      result.push({city: record[0].trim(), phone: record[2].trim()});    }  }  return result;}As a bonus, this lets me delete firstLine\u2014and I particularly enjoy deleting controlvariables.The next bit of behavior removes any blank lines. I can replace this with a filteroperation.function acquireData(input) {  const lines = input.split(\"\\n\");  const result = [];  const loopItems = lines        .slice(1)        .filter(line => line.trim() !== \"\")        ;  for (const line of loopItems) {    if (line.trim() === \"\") continue;    const record = line.split(\",\");    if (record[1].trim() === \"India\") {      result.push({city: record[0].trim(), phone: record[2].trim()});    }  }  return result;}When writing a pipeline, I find it best to put the terminal semicolon on its own line.I use the map operation to turn lines into an array of strings\u2014misleadingly calledrecord in the original function, but it\u2019s safer to keep the name for now and rename later.function acquireData(input) {  const lines = input.split(\"\\n\");  const result = [];  const loopItems = lines        .slice(1)        .filter(line => line.trim() !== \"\")        .map(line => line.split(\",\"))        ;  for (const line of loopItems) {    const record = line;.split(\",\");    if (record[1].trim() === \"India\") {      result.push({city: record[0].trim(), phone: record[2].trim()});    }  }  return result;}Filter again to just get the India records:function acquireData(input) {  const lines = input.split(\"\\n\");  const result = [];  const loopItems = lines        .slice(1)        .filter(line => line.trim() !== \"\")        .map(line => line.split(\",\"))        .filter(record => record[1].trim() === \"India\")        ;  for (const line of loopItems) {    const record = line;    if (record[1].trim() === \"India\") {      result.push({city: record[0].trim(), phone: record[2].trim()});    }  }  return result;}Map to the output record form:function acquireData(input) {  const lines = input.split(\"\\n\");  const result = [];  const loopItems = lines        .slice(1)        .filter(line => line.trim() !== \"\")        .map(line => line.split(\",\"))        .filter(record => record[1].trim() === \"India\")        .map(record => ({city: record[0].trim(), phone: record[2].trim()}))        ;  for (const line of loopItems) {    const record = line;    result.push(line);  }  return result;}Now, all the loop does is assign values to the accumulator. So I can remove it and assignthe result of the pipeline to the accumulator:function acquireData(input) {  const lines = input.split(\"\\n\");  const result = lines        .slice(1)        .filter(line => line.trim() !== \"\")        .map(line => line.split(\",\"))        .filter(record => record[1].trim() === \"India\")        .map(record => ({city: record[0].trim(), phone: record[2].trim()}))        ;  for (const line of loopItems) {    const record = line;    result.push(line);  }  return result;}That\u2019s the core of the refactoring. But I do have some cleanup I\u2019d like to do. I inlinedresult, renamed some lambda variables, and made the layout read more like a table.function acquireData(input) {  const lines = input.split(\"\\n\");  return lines        .slice  (1)        .filter (line   => line.trim() !== \"\")        .map    (line   => line.split(\",\"))        .filter (fields => fields[1].trim() === \"India\")        .map    (fields => ({city: fields[0].trim(), phone: fields[2].trim()}))        ;}I thought about inlining lines too, but felt that its presence explains what\u2019shappening.",
        "Further Reading": "For more examples on turning loops into pipelines, see my essay \u201cRefactoring withLoops and Collection Pipelines\u201d [mf\u00adref\u00adpipe]."
    },
    "REMOVE DEAD CODE": {
        "Mechanics": "If the dead code can be referenced from outside, e.g., when it\u2019s a full function, do asearch to check for callers.Remove the dead code.Test.Data structures play an important role in our programs, so it\u2019s no great shock that Ihave a clutch of refactorings that focus on them. A value that\u2019s used for differentpurposes is a breeding ground for confusion and bugs\u2014so, when I see one, I use SplitVariable (240) to separate the usages. As with any program element, getting avariable\u2019s name right is tricky and important, so Rename Variable (137) is often myfriend. But sometimes the best thing I can do with a variable is to get rid of itcompletely\u2014with Replace Derived Variable with Query (248).I often find problems in a code base due to a confusion between references and values,so I use Change Reference to Value (252) and Change Value to Reference (256) tochange between these styles."
    },
    "SPLIT VARIABLE": {
        "Mechanics": "Change the name of the variable at its declaration and first assignment.If the later assignments are of the form i = i + something, that is a collectingvariable, so don\u2019t split it. A collecting variable is often used for calculating sums,string concatenation, writing to a stream, or adding to a collection.If possible, declare the new variable as immutable.Change all references of the variable up to its second assignment.Test.Repeat in stages, at each stage renaming the variable at the declaration andchanging references until the next assignment, until you reach the final assignment.",
        "Example": "For this example, I compute the distance traveled by a haggis. From a standing start, ahaggis experiences an initial force. After a delay, a secondary force kicks in to furtheraccelerate the haggis. Using the common laws of motion, I can compute the distancetraveled as follows:function distanceTravelled (scenario, time) {  let result;  let acc = scenario.primaryForce / scenario.mass;  let primaryTime = Math.min(time, scenario.delay);  result = 0.5 * acc * primaryTime * primaryTime;  let secondaryTime = time \u00ad scenario.delay;  if (secondaryTime > 0) {    let primaryVelocity = acc * scenario.delay;    acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;    result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * seco  }  return result;}A nice awkward little function. The interesting thing for our example is the way thevariable acc is set twice. It has two responsibilities: one to hold the initial accelerationfrom the first force and another later to hold the acceleration from both forces. I wantto split this variable.When trying to understand how a variable is used, it\u2019s handy if my editor can highlightall occurrences of a symbol within a function or file. Most modern editors can do thispretty easily.I start at the beginning by changing the name of the variable and declaring the newname as const. Then, I change all references to the variable from that point up to thenext assignment. At the next assignment, I declare it:function distanceTravelled (scenario, time) {  let result;  const primaryAcceleration = scenario.primaryForce / scenario.mass;  let primaryTime = Math.min(time, scenario.delay);  result = 0.5 * primaryAcceleration * primaryTime * primaryTime;  let secondaryTime = time \u00ad scenario.delay;  if (secondaryTime > 0) {    let primaryVelocity = primaryAcceleration * scenario.delay;    let acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass;    result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * seco  }  return result;}I choose the new name to represent only the first use of the variable. I make it const toensure it is only assigned once. I can then declare the original variable at its secondassignment. Now I can compile and test, and all should work.I continue on the second assignment of the variable. This removes the original variablename completely, replacing it with a new variable named for the second use.function distanceTravelled (scenario, time) {  let result;  const primaryAcceleration = scenario.primaryForce / scenario.mass;  let primaryTime = Math.min(time, scenario.delay);  result = 0.5 * primaryAcceleration * primaryTime * primaryTime;  let secondaryTime = time \u00ad scenario.delay;  if (secondaryTime > 0) {    let primaryVelocity = primaryAcceleration * scenario.delay;    const secondaryAcceleration = (scenario.primaryForce + scenario.secondaryFor    result += primaryVelocity * secondaryTime +      0.5 * secondaryAcceleration * secondaryTime * secondaryTime;  }  return result;}I\u2019m sure you can think of a lot more refactoring to be done here. Enjoy it. (I\u2019m sure it\u2019sbetter than eating the haggis\u2014do you know what they put in those things?)",
        "Example: Assigning to an Input Parameter": "Another case of splitting a variable is where the variable is declared as an inputparameter. Consider something likefunction discount (inputValue, quantity) {  if (inputValue > 50) inputValue = inputValue \u00ad 2;  if (quantity > 100) inputValue = inputValue \u00ad 1;  return inputValue;}Here inputValue is used both to supply an input to the function and to hold the resultfor the caller. (Since JavaScript has call\u00adby\u00advalue parameters, any modification ofinputValue isn\u2019t seen by the caller.)In this situation, I would split that variable.function discount (originalInputValue, quantity) {  let inputValue = originalInputValue;  if (inputValue > 50) inputValue = inputValue \u00ad 2;  if (quantity > 100) inputValue = inputValue \u00ad 1;  return inputValue;}I then perform Rename Variable (137) twice to get better names.function discount (inputValue, quantity) {  let result = inputValue;  if (inputValue > 50) result = result \u00ad 2;  if (quantity > 100) result = result \u00ad 1;  return result;}You\u2019ll notice that I changed the second line to use inputValue as its data source.Although the two are the same, I think that line is really about applying themodification to the result value based on the original input value, not the(coincidentally same) value of the result accumulator."
    },
    "RENAME FIELD": {
        "Mechanics": "If the record has limited scope, rename all accesses to the field and test; no need todo the rest of the mechanics.If the record isn\u2019t already encapsulated, apply Encapsulate Record (162).Rename the private field inside the object, adjust internal methods to fit.Test.If the constructor uses the name, apply Change Function Declaration (124) torename it.Apply Rename Function (124) to the accessors.",
        "Example: Renaming a Field": "I\u2019ll start with a constant.const organization = {name: \"Acme Gooseberries\", country: \"GB\"};I want to change \u201cname\u201d to \u201ctitle\u201d. The object is widely used in the code base, and thereare updates to the title in the code. So my first move is to apply Encapsulate Record(162).class Organization {  constructor(data) {    this._name = data.name;    this._country = data.country;  }  get name()    {return this._name;}  set name(aString) {this._name = aString;}  get country()    {return this._country;}  set country(aCountryCode) {this._country = aCountryCode;}}const organization = new Organization({name: \"Acme Gooseberries\", country: \"GB\"}Now that I\u2019ve encapsulated the record structure into the class, there are four places Ineed to look at for renaming: the getting function, the setting function, the constructor,and the internal data structure. While that may sound like I\u2019ve increased my workload,it actually makes my work easier since I can now change these independently instead ofall at once, taking smaller steps. Smaller steps mean fewer things to go wrong in eachstep\u2014therefore, less work. It wouldn\u2019t be less work if I never made mistakes\u2014but notmaking mistakes is a fantasy I gave up on a long time ago.Since I\u2019ve copied the input data structure into the internal data structure, I need toseparate them so I can work on them independently. I can do this by defining aseparate field and adjusting the constructor and accessors to use it.class Organization...class Organization {  constructor(data) {    this._title = data.name;    this._country = data.country;  }  get name()    {return this._title;}  set name(aString) {this._title = aString;}  get country()    {return this._country;}  set country(aCountryCode) {this._country = aCountryCode;}}Next, I add support for using \u201ctitle\u201d in the constructor.class Organization...class Organization {  constructor(data) {    this._title = (data.title !== undefined) ? data.title : data.name;    this._country = data.country;  }  get name()    {return this._title;}  set name(aString) {this._title = aString;}  get country()    {return this._country;}  set country(aCountryCode) {this._country = aCountryCode;}}Now, callers of my constructor can use either name or title (with title takingprecedence). I can now go through all constructor callers and change them one\u00adby\u00adoneto use the new name.const organization = new Organization({title: \"Acme Gooseberries\", country: \"GB\"Once I\u2019ve done all of them, I can remove the support for the name.class Organization...class Organization {  constructor(data) {    this._title = data.title;    this._country = data.country;  }  get name()    {return this._title;}  set name(aString) {this._title = aString;}  get country()    {return this._country;}  set country(aCountryCode) {this._country = aCountryCode;}}Now that the constructor and data use the new name, I can change the accessors, whichis as simple as applying Rename Function (124) to each one.class Organization...class Organization {  constructor(data) {    this._title = data.title;    this._country = data.country;  }  get title()    {return this._title;}  set title(aString) {this._title = aString;}  get country()    {return this._country;}  set country(aCountryCode) {this._country = aCountryCode;}}I\u2019ve shown this process in its most heavyweight form needed for a widely used datastructure. If it\u2019s being used only locally, as in a single function, I can probably justrename the various properties in one go without doing encapsulation. It\u2019s a matter ofjudgment when to apply to the full mechanics here\u2014but, as usual with refactoring, ifmy tests break, that\u2019s a sign I need to use the more gradual procedure.Some languages allow me to make a data structure immutable. In this case, rather thanencapsulating it, I can copy the value to the new name, gradually change the users, thenremove the old name. Duplicating data is a recipe for disaster with mutable datastructures; removing such disasters is why immutable data is so popular."
    },
    "REPLACE DERIVED VARIABLE WITH QUERY": {
        "Mechanics": "Identify all points of update for the variable. If necessary, use Split Variable (240)to separate each point of update.Create a function that calculates the value of the variable.Use Introduce Assertion (302) to assert that the variable and the calculation givethe same result whenever the variable is used.If necessary, use Encapsulate Variable (132) to provide a home for the assertion.Test.Replace any reader of the variable with a call to the new function.Test.Apply Remove Dead Code (237) to the declaration and updates to the variable.",
        "Example": "Here\u2019s a small but perfectly formed example of ugliness:class ProductionPlan...get production() {return this._production;}applyAdjustment(anAdjustment) {  this._adjustments.push(anAdjustment);  this._production += anAdjustment.amount;}Ugliness is in the eye of beholder; here, I see ugliness in duplication\u2014not the commonduplication of code but duplication of data. When I apply an adjustment, I\u2019m not juststoring that adjustment but also using it to modify an accumulator. I can just calculatethat value, without having to update it.But I\u2019m a cautious fellow. It is my hypothesis is that I can just calculate it\u2014I can testthat hypothesis by using Introduce Assertion (302):class ProductionPlan...get production() {  assert(this._production === this.calculatedProduction);  return this._production;}  get calculatedProduction() {    return this._adjustments      .reduce((sum, a) => sum + a.amount, 0);  }With the assertion in place, I run my tests. If the assertion doesn\u2019t fail, I can replacereturning the field with returning the calculation:class ProductionPlan...get production() {  assert(this._production === this.calculatedProduction);  return this.calculatedProduction;}Then Inline Function (115):class ProductionPlan...get production() {  return this._adjustments    .reduce((sum, a) => sum + a.amount, 0);}I clean up any references to the old variable with Remove Dead Code (237):class ProductionPlan...applyAdjustment(anAdjustment) {  this._adjustments.push(anAdjustment);  this._production += anAdjustment.amount;}",
        "Example: More Than One Source": "The above example is nice and easy because there\u2019s clearly a single source for the valueof production. But sometimes, more than one element can combine in theaccumulator.class ProductionPlan...constructor (production) {  this._production = production;  this._adjustments = [];}get production() {return this._production;}applyAdjustment(anAdjustment) {  this._adjustments.push(anAdjustment);  this._production += anAdjustment.amount;}If I do the same Introduce Assertion (302) that I did above, it will now fail for any casewhere the initial value of the production isn\u2019t zero.But I can still replace the derived data. The only difference is that I must first applySplit Variable (240).constructor (production) {  this._initialProduction = production;  this._productionAccumulator = 0;  this._adjustments = [];}get production() {  return this._initialProduction + this._productionAccumulator;}Now I can Introduce Assertion (302):class ProductionPlan...get production() {  assert(this._productionAccumulator === this.calculatedProductionAccumulator);  return this._initialProduction + this._productionAccumulator;}  get calculatedProductionAccumulator() {    return this._adjustments      .reduce((sum, a) => sum + a.amount, 0);  }and continue pretty much as before. I\u2019d be inclined, however, to leavetotalProductionAjustments as its own property, without inlining it."
    },
    "CHANGE REFERENCE TO VALUE": {
        "Mechanics": "Check that the candidate class is immutable or can become immutable.For each setter, apply Remove Setting Method (331).Provide a value\u00adbased equality method that uses the fields of the value object.Most language environments provide an overridable equality function for thispurpose. Usually you must override a hashcode generator method as well.",
        "Example": "Imagine we have a person object that holds onto a crude telephone number.class Person...constructor() {  this._telephoneNumber = new TelephoneNumber();}get officeAreaCode()    {return this._telephoneNumber.areaCode;}set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg;}get officeNumber()    {return this._telephoneNumber.number;}set officeNumber(arg) {this._telephoneNumber.number = arg;}class TelephoneNumber...get areaCode()    {return this._areaCode;}set areaCode(arg) {this._areaCode = arg;}get number()    {return this._number;}set number(arg) {this._number = arg;}This situation is the result of an Extract Class (182) where the old parent still holdsupdate methods for the new object. This is a good time to apply Change Reference toValue since there is only one reference to the new class.The first thing I need to do is to make the telephone number immutable. I do this byapplying Remove Setting Method (331) to the fields. The first step of Remove SettingMethod (331) is to use Change Function Declaration (124) to add the two fields to theconstructor and enhance the constructor to call the setters.class TelephoneNumber...constructor(areaCode, number) {  this._areaCode = areaCode;  this._number = number;}Now I look at the callers of the setters. For each one, I need to change it to areassignment. I start with the area code.class Person...get officeAreaCode()    {return this._telephoneNumber.areaCode;}set officeAreaCode(arg) {  this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);}get officeNumber()    {return this._telephoneNumber.number;}set officeNumber(arg) {this._telephoneNumber.number = arg;}I then repeat that step with the remaining field.class Person...get officeAreaCode()    {return this._telephoneNumber.areaCode;}set officeAreaCode(arg) {  this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);}get officeNumber()    {return this._telephoneNumber.number;}set officeNumber(arg) {  this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg);}Now the telephone number is immutable, it is ready to become a true value. Thecitizenship test for a value object is that it uses value\u00adbased equality. This is an areawhere JavaScript falls down, as there is nothing in the language and core libraries thatunderstands replacing a reference\u00adbased equality with a value\u00adbased one. The best I cando is to create my own equals method.class TelephoneNumber...equals(other) {  if (!(other instanceof TelephoneNumber)) return false;  return this.areaCode === other.areaCode &&    this.number === other.number;}It\u2019s also important to test it with something likeit('telephone equals', function() {  assert(        new TelephoneNumber(\"312\", \"555\u00ad0142\")         .equals(new TelephoneNumber(\"312\", \"555\u00ad0142\")));});The unusual formatting I use here should make it obvious that they are the sameconstructor call.The vital thing I do in the test is create two independent objects and test that theymatch as equal.In most object\u00adoriented languages, there is a built\u00adin equality test that is supposed to beoverridden for value\u00adbased equality. In Ruby, I can override the == operator; in Java, Ioverride the Object.equals() method. And whenever I override an equality method,I usually need to override a hashcode generating method too (e.g.,Object.hashCode() in Java) to ensure collections that use hashing work properlywith my new value.If the telephone number is used by more than one client, the procedure is still the same.As I apply Remove Setting Method (331), I\u2019ll be modifying several clients instead of justone. Tests for non\u00adequal telephone numbers, as well as comparisons to non\u00adtelephone\u00adnumbers and null values, are also worthwhile."
    },
    "CHANGE VALUE TO REFERENCE": {
        "Mechanics": "Create a repository for instances of the related object (if one isn\u2019t already present).Ensure the constructor has a way of looking up the correct instance of the relatedobject.Change the constructors for the host object to use the repository to obtain therelated object. Test after each change.",
        "Example": "I\u2019ll begin with a class that represents orders, which I might create from an incomingJSON document. Part of the order data is a customer ID from which I\u2019m creating acustomer object.class Order...constructor(data) {  this._number = data.number;  this._customer = new Customer(data.customer);  // load other data}get customer() {return this._customer;}class Customer...constructor(id) {  this._id = id;}get id() {return this._id;}The customer object I create this way is a value. If I have five orders that refer to thecustomer ID of 123, I\u2019ll have five separate customer objects. Any change I make to oneof them will not be reflected in the others. Should I want to enrich the customer objects,perhaps by gathering data from a customer service, I\u2019d have to update all five customerswith the same data. Having duplicate objects like this always makes me nervous\u2014it\u2019sconfusing to have multiple objects representing the same entity, such as a customer.This problem is particularly awkward if the customer object is mutable, which can leadto inconsistencies between the customer objects.If I want to use the same customer object each time, I\u2019ll need a place to store it. Exactlywhere to store entities like this will vary from application to application, but for asimple case I like to use a repository object [mf\u00adrepos].let _repositoryData;export function initialize() {  _repositoryData = {};  _repositoryData.customers = new Map();}export function registerCustomer(id) {  if (! _repositoryData.customers.has(id))    _repositoryData.customers.set(id, new Customer(id));  return findCustomer(id);}export function findCustomer(id) {  return _repositoryData.customers.get(id);}The repository allows me to register customer objects with an ID and ensures I onlycreate one customer object with the same ID. With this in place, I can change theorder\u2019s constructor to use it.Often, when doing this refactoring, the repository already exists, so I can just use it.The next step is to figure out how the constructor for the order can obtain the correctcustomer object. In this case it\u2019s easy, since the customer\u2019s ID is present in the inputdata stream.class Order...constructor(data) {  this._number = data.number;  this._customer = registerCustomer(data.customer);  // load other data}get customer() {return this._customer;}Now, any changes I make to the customer of one order will be synchronized across allthe orders sharing the same customer.For this example, I created a new customer object with the first order that referenced it.Another common approach is to get a list of customers, populate the repository withthem, and then link to them as I read the orders. In that case, an order that contains acustomer ID not in the repository would indicate an error.One problem with this code is that the constructor body is coupled to the globalrepository. Globals should be treated with care\u2014like a powerful drug, they can bebeneficial in small doses but a poison if used too much. If I\u2019m concerned about it, I canpass the repository as a parameter to the constructor.Much of the power of programs comes from their ability to implement conditional logic\u2014but, sadly, much of the complexity of programs lies in these conditionals. I often userefactoring to make conditional sections easier to understand. I regularly applyDecompose Conditional (260) to complicated conditionals, and I use ConsolidateConditional Expression (263) to make logical combinations clearer. I use ReplaceNested Conditional with Guard Clauses (266) to clarify cases where I want to run somepre\u00adchecks before my main processing. If I see several conditions using the sameswitching logic, it\u2019s a good time to pull Replace Conditional with Polymorphism (272)out the box.A lot of conditionals are used to handle special cases, such as nulls; if that logic ismostly the same, then Introduce Special Case (289) (often referred to as Introduce NullObject (289)) can remove a lot of duplicate code. And, although I like to removeconditions a lot, if I want to communicate (and check) a program\u2019s state, I findIntroduce Assertion (302) a worthwhile addition."
    },
    "DECOMPOSE CONDITIONAL": {
        "Mechanics": "Apply Extract Function (106) on the condition and each leg of the conditional.",
        "Example": "Suppose I\u2019m calculating the charge for something that has separate rates for winter andsummer:if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))  charge = quantity * plan.summerRate;else  charge = quantity * plan.regularRate + plan.regularServiceCharge;I extract the condition into its own function.if (summer())  charge = quantity * plan.summerRate;else  charge = quantity * plan.regularRate + plan.regularServiceCharge;function summer() {  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);}Then I do the then leg:if (summer())  charge = summerCharge();else  charge = quantity * plan.regularRate + plan.regularServiceCharge;function summer() {  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);}function summerCharge() {  return quantity * plan.summerRate;}Finally, the else leg:if (summer())  charge = summerCharge();else  charge = regularCharge();function summer() {  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);}function summerCharge() {  return quantity * plan.summerRate;}function regularCharge() {  return quantity * plan.regularRate + plan.regularServiceCharge;}With that done, I like to reformat the conditional using the ternary operator.charge = summer() ? summerCharge() : regularCharge();function summer() {  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);}function summerCharge() {  return quantity * plan.summerRate;}function regularCharge() {  return quantity * plan.regularRate + plan.regularServiceCharge;}"
    },
    "CONSOLIDATE CONDITIONAL EXPRESSION": {
        "Mechanics": "Ensure that none of the conditionals have any side effects.If any do, use Separate Query from Modifier (306) on them first.Take two of the conditional statements and combine their conditions using a logicaloperator.Sequences combine with or, nested if statements combine with and.Test.Repeat combining conditionals until they are all in a single condition.Consider using Extract Function (106) on the resulting condition.",
        "Example": "Perusing some code, I see the following:function disabilityAmount(anEmployee) {  if (anEmployee.seniority < 2) return 0;  if (anEmployee.monthsDisabled > 12) return 0;  if (anEmployee.isPartTime) return 0;  // compute the disability amountIt\u2019s a sequence of conditional checks which all have the same result. Since the result isthe same, I should combine these conditions into a single expression. For a sequencelike this, I do it using an or operator.function disabilityAmount(anEmployee) {  if ((anEmployee.seniority < 2)      || (anEmployee.monthsDisabled > 12)) return 0;  if (anEmployee.isPartTime) return 0;  // compute the disability amountI test, then fold in the other condition:function disabilityAmount(anEmployee) {  if ((anEmployee.seniority < 2)      || (anEmployee.monthsDisabled > 12)      || (anEmployee.isPartTime)) return 0;  // compute the disability amountOnce I have them all together, I use Extract Function (106) on the condition.function disabilityAmount(anEmployee) {  if (isNotEligableForDisability()) return 0;  // compute the disability amount  function isNotEligableForDisability() {    return ((anEmployee.seniority < 2)            || (anEmployee.monthsDisabled > 12)            || (anEmployee.isPartTime));  }",
        "Example: Using ": "and",
        "s": "The example above showed combining statements with an or, but I may run into casesthat need ands as well. Such a case uses nested if statements:if (anEmployee.onVacation)  if (anEmployee.seniority > 10)    return 1;return 0.5;I combine these using and operators.if ((anEmployee.onVacation)    && (anEmployee.seniority > 10)) return 1;return 0.5;If I have a mix of these, I can combine using and and or operators as needed. Whenthis happens, things are likely to get messy, so I use Extract Function (106) liberally tomake it all understandable."
    },
    "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES": {
        "Mechanics": "Select outermost condition that needs to be replaced, and change it into a guardclause.Test.Repeat as needed.If all the guard clauses return the same result, use Consolidate ConditionalExpression (263).",
        "Example": "Here\u2019s some code to calculate a payment amount for an employee. It\u2019s only relevant ifthe employee is still with the company, so it has to check for the two other cases.function payAmount(employee) {  let result;  if(employee.isSeparated) {    result = {amount: 0, reasonCode: \"SEP\"};  }  else {    if (employee.isRetired) {      result = {amount: 0, reasonCode: \"RET\"};    }    else {      // logic to compute amount      lorem.ipsum(dolor.sitAmet);      consectetur(adipiscing).elit();      sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);      ut.enim.ad(minim.veniam);      result = someFinalComputation();    }  }  return result;}Nesting the conditionals here masks the true meaning of what it going on. The primarypurpose of this code only applies if these conditions aren\u2019t the case. In this situation,the intention of the code reads more clearly with guard clauses.As with any refactoring change, I like to take small steps, so I begin with the topmostcondition.function payAmount(employee) {  let result;  if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"};  if (employee.isRetired) {    result = {amount: 0, reasonCode: \"RET\"};  }  else {    // logic to compute amount    lorem.ipsum(dolor.sitAmet);    consectetur(adipiscing).elit();    sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);    ut.enim.ad(minim.veniam);    result = someFinalComputation();  }  return result;}I test that change and move on to the next one.function payAmount(employee) {  let result;  if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"};  if (employee.isRetired)   return {amount: 0, reasonCode: \"RET\"};  // logic to compute amount  lorem.ipsum(dolor.sitAmet);  consectetur(adipiscing).elit();  sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);  ut.enim.ad(minim.veniam);  result = someFinalComputation();  return result;}At which point the result variable isn\u2019t really doing anything useful, so I remove it.function payAmount(employee) {  let result;  if (employee.isSeparated) return {amount: 0, reasonCode: \"SEP\"};  if (employee.isRetired)   return {amount: 0, reasonCode: \"RET\"};  // logic to compute amount  lorem.ipsum(dolor.sitAmet);  consectetur(adipiscing).elit();  sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);  ut.enim.ad(minim.veniam);  return someFinalComputation();}The rule is that you always get an extra strawberry when you remove a mutablevariable.",
        "Example: Reversing the Conditions": "When reviewing the manuscript of the first edition of this book, Joshua Kerievskypointed out that we often do Replace Nested Conditional with Guard Clauses byreversing the conditional expressions. Even better, he gave me an example so I didn\u2019thave to further tax my imagination.function adjustedCapital(anInstrument) {  let result = 0;  if (anInstrument.capital > 0) {    if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {      result = (anInstrument.income / anInstrument.duration) * anInstrument.adju    }  }  return result;}Again, I make the replacements one at a time, but this time I reverse the condition as Iput in the guard clause.function adjustedCapital(anInstrument) {  let result = 0;  if (anInstrument.capital <= 0) return result;  if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {    result = (anInstrument.income / anInstrument.duration) * anInstrument.adjust  }  return result;}The next conditional is a bit more complicated, so I do it in two steps. First, I simplyadd a not.function adjustedCapital(anInstrument) {  let result = 0;  if (anInstrument.capital <= 0) return result;  if (!(anInstrument.interestRate > 0 && anInstrument.duration > 0)) return resu  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustme  return result;}Leaving nots in a conditional like that twists my mind around at a painful angle, so Isimplify it:function adjustedCapital(anInstrument) {  let result = 0;  if (anInstrument.capital <= 0) return result;  if (anInstrument.interestRate <= 0 || anInstrument.duration <= 0) return resul  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustme  return result;}Both of those lines have conditions with the same result, so I apply ConsolidateConditional Expression (263).function adjustedCapital(anInstrument) {  let result = 0;  if (   anInstrument.capital      <= 0      || anInstrument.interestRate <= 0      || anInstrument.duration     <= 0) return result;  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustme  return result;}The result variable is doing two things here. Its first setting to zero indicates what toreturn when the guard clause triggers; its second value is the final computation. I canget rid of it, which both eliminates its double usage and gets me a strawberry.function adjustedCapital(anInstrument) {  if (   anInstrument.capital      <= 0      || anInstrument.interestRate <= 0      || anInstrument.duration     <= 0) return 0;  return (anInstrument.income / anInstrument.duration) * anInstrument.adjustment}"
    },
    "REPLACE CONDITIONAL WITH POLYMORPHISM": {
        "Mechanics": "If classes do not exist for polymorphic behavior, create them together with a factoryfunction to return the correct instance.Use the factory function in calling code.Move the conditional function to the superclass.If the conditional logic is not a self\u00adcontained function, use Extract Function (106)to make it so.Pick one of the subclasses. Create a subclass method that overrides the conditionalstatement method. Copy the body of that leg of the conditional statement into thesubclass method and adjust it to fit.Repeat for each leg of the conditional.Leave a default case for the superclass method. Or, if superclass should be abstract,declare that method as abstract or throw an error to show it should be theresponsibility of a subclass.",
        "Example": "My friend has a collection of birds and wants to know how fast they can fly and whatthey have for plumage. So we have a couple of small programs to determine theinformation.function plumages(birds) {  return new Map(birds.map(b => [b.name, plumage(b)]));}function speeds(birds) {  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]));}function plumage(bird) {  switch (bird.type) {  case 'EuropeanSwallow':    return \"average\";  case 'AfricanSwallow':    return (bird.numberOfCoconuts > 2) ? \"tired\" : \"average\";  case 'NorwegianBlueParrot':    return (bird.voltage > 100) ? \"scorched\" : \"beautiful\";  default:    return \"unknown\";  }}function airSpeedVelocity(bird) {  switch (bird.type) {  case 'EuropeanSwallow':    return 35;  case 'AfricanSwallow':    return 40 \u00ad 2 * bird.numberOfCoconuts;  case 'NorwegianBlueParrot':    return (bird.isNailed) ? 0 : 10 + bird.voltage / 10;  default:    return null;  }}We have a couple of different operations that vary with the type of bird, so it makessense to create classes and use polymorphism for any type\u00adspecific behavior.I begin by using Combine Functions into Class (144) on airSpeedVelocity andplumage.function plumage(bird) {  return new Bird(bird).plumage;}function airSpeedVelocity(bird) {  return new Bird(bird).airSpeedVelocity;}class Bird {  constructor(birdObject) {    Object.assign(this, birdObject);  }  get plumage() {    switch (this.type) {    case 'EuropeanSwallow':      return \"average\";    case 'AfricanSwallow':      return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";    case 'NorwegianBlueParrot':      return (this.voltage > 100) ? \"scorched\" : \"beautiful\";    default:      return \"unknown\";    }  }  get airSpeedVelocity() {    switch (this.type) {    case 'EuropeanSwallow':      return 35;    case 'AfricanSwallow':      return 40 \u00ad 2 * this.numberOfCoconuts;    case 'NorwegianBlueParrot':      return (this.isNailed) ? 0 : 10 + this.voltage / 10;    default:      return null;    }  }}I now add subclasses for each kind of bird, together with a factory function toinstantiate the appropriate subclass.function plumage(bird) {  return createBird(bird).plumage;}function airSpeedVelocity(bird) {  return createBird(bird).airSpeedVelocity;}  function createBird(bird) {    switch (bird.type) {    case 'EuropeanSwallow':      return new EuropeanSwallow(bird);    case 'AfricanSwallow':      return new AfricanSwallow(bird);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrot(bird);    default:      return new Bird(bird);    }  }  class EuropeanSwallow extends Bird {  }  class AfricanSwallow extends Bird {  }  class NorwegianBlueParrot extends Bird {  }Now that I\u2019ve created the class structure that I need, I can begin on the two conditionalmethods. I\u2019ll begin with plumage. I take one leg of the switch statement and override itin the appropriate subclass.class EuropeanSwallow...get plumage() {  return \"average\";}class Bird...get plumage() {  switch (this.type) {  case 'EuropeanSwallow':    throw \"oops\";  case 'AfricanSwallow':    return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";  case 'NorwegianBlueParrot':    return (this.voltage > 100) ? \"scorched\" : \"beautiful\";  default:    return \"unknown\";  }}I put in the throw because I\u2019m paranoid.I can compile and test at this point. Then, if all is well, I do the next leg.class AfricanSwallow...get plumage() {  return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";}Then, the Norwegian Blue:class NorwegianBlueParrot...get plumage() {  return (this.voltage > 100) ? \"scorched\" : \"beautiful\";}I leave the superclass method for the default case.class Bird...get plumage() {  return \"unknown\";}I repeat the same process for airSpeedVelocity. Once I\u2019m done, I end up with thefollowing code (I also inlined the top\u00adlevel functions for airSpeedVelocity andplumage):function plumages(birds) {  return new Map(birds                 .map(b => createBird(b))                 .map(bird => [bird.name, bird.plumage]));}function speeds(birds) {  return new Map(birds                 .map(b => createBird(b))                 .map(bird => [bird.name, bird.airSpeedVelocity]));}function createBird(bird) {  switch (bird.type) {  case 'EuropeanSwallow':    return new EuropeanSwallow(bird);  case 'AfricanSwallow':    return new AfricanSwallow(bird);  case 'NorwegianBlueParrot':    return new NorwegianBlueParrot(bird);  default:    return new Bird(bird);  }}class Bird {  constructor(birdObject) {    Object.assign(this, birdObject);  }  get plumage() {    return \"unknown\";  }  get airSpeedVelocity() {    return null;  }}class EuropeanSwallow extends Bird {  get plumage() {    return \"average\";  }  get airSpeedVelocity() {    return 35;  }}class AfricanSwallow extends Bird {  get plumage() {    return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";  }  get airSpeedVelocity() {    return 40 \u00ad 2 * this.numberOfCoconuts;  }}class NorwegianBlueParrot extends Bird {  get plumage() {    return (this.voltage > 100) ? \"scorched\" : \"beautiful\";  }  get airSpeedVelocity() {    return (this.isNailed) ? 0 : 10 + this.voltage / 10;  }}Looking at this final code, I can see that the superclass Bird isn\u2019t strictly needed. InJavaScript, I don\u2019t need a type hierarchy for polymorphism; as long as my objectsimplement the appropriately named methods, everything works fine. In this situation,however, I like to keep the unnecessary superclass as it helps explain the way theclasses are related in the domain.",
        "Example: Using Polymorphism for Variation": "With the birds example, I\u2019m using a clear generalization hierarchy. That\u2019s howsubclassing and polymorphism is often discussed in textbooks (including mine)\u2014butit\u2019s not the only way inheritance is used in practice; indeed, it probably isn\u2019t the mostcommon or best way. Another case for inheritance is when I wish to indicate that oneobject is mostly similar to another, but with some variations.As an example of this case, consider some code used by a rating agency to compute aninvestment rating for the voyages of sailing ships. The rating agency gives out either an\u201cA\u201d or \u201cB\u201d rating, depending of various factors due to risk and profit potential. The riskcomes from assessing the nature of the voyage as well as the history of the captain\u2019sprior voyages.function rating(voyage, history) {  const vpf = voyageProfitFactor(voyage, history);  const vr = voyageRisk(voyage);  const chr = captainHistoryRisk(voyage, history);  if (vpf * 3 > (vr + chr * 2)) return \"A\";  else return \"B\";}function voyageRisk(voyage) {  let result = 1;  if (voyage.length > 4) result += 2;  if (voyage.length > 8) result += voyage.length \u00ad 8;  if ([\"china\", \"east\u00adindies\"].includes(voyage.zone)) result += 4;  return Math.max(result, 0);}function captainHistoryRisk(voyage, history) {  let result = 1;  if (history.length < 5) result += 4;  result += history.filter(v => v.profit < 0).length;  if (voyage.zone === \"china\" && hasChina(history)) result \u00ad= 2;  return Math.max(result, 0);}function hasChina(history) {  return history.some(v => \"china\" === v.zone);}function voyageProfitFactor(voyage, history) {  let result = 2;  if (voyage.zone === \"china\") result += 1;  if (voyage.zone === \"east\u00adindies\") result += 1;  if (voyage.zone === \"china\" && hasChina(history)) {    result += 3;    if (history.length > 10) result += 1;    if (voyage.length > 12) result += 1;    if (voyage.length > 18) result \u00ad= 1;  }  else {    if (history.length > 8) result += 1;    if (voyage.length > 14) result \u00ad= 1;  }  return result;}The functions voyageRisk and captainHistoryRisk score points for risk,voyageProfitFactor scores points for the potential profit, and rating combinesthese to give the overall rating for the voyage.The calling code would look something like this:const voyage = {zone: \"west\u00adindies\", length: 10};const history = [  {zone: \"east\u00adindies\", profit:  5},  {zone: \"west\u00adindies\", profit: 15},  {zone: \"china\",       profit: \u00ad2},  {zone: \"west\u00adafrica\", profit:  7},];const myRating = rating(voyage, history);What I want to focus on here is how a couple of places use conditional logic to handlethe case of a voyage to China where the captain has been to China before.function rating(voyage, history) {  const vpf = voyageProfitFactor(voyage, history);  const vr = voyageRisk(voyage);  const chr = captainHistoryRisk(voyage, history);  if (vpf * 3 > (vr + chr * 2)) return \"A\";  else return \"B\";}  function voyageRisk(voyage) {  let result = 1;  if (voyage.length > 4) result += 2;  if (voyage.length > 8) result += voyage.length \u00ad 8;  if ([\"china\", \"east\u00adindies\"].includes(voyage.zone)) result += 4;  return Math.max(result, 0);}function captainHistoryRisk(voyage, history) {  let result = 1;  if (history.length < 5) result += 4;  result += history.filter(v => v.profit < 0).length;  if (voyage.zone === \"china\" && hasChina(history)) result \u00ad= 2;  return Math.max(result, 0);}function hasChina(history) {  return history.some(v => \"china\" === v.zone);}function voyageProfitFactor(voyage, history) {  let result = 2;  if (voyage.zone === \"china\") result += 1;  if (voyage.zone === \"east\u00adindies\") result += 1;  if (voyage.zone === \"china\" && hasChina(history)) {    result += 3;    if (history.length > 10) result += 1;    if (voyage.length > 12) result += 1;    if (voyage.length > 18) result \u00ad= 1;  }  else {    if (history.length > 8) result += 1;    if (voyage.length > 14) result \u00ad= 1;  }  return result;}I will use inheritance and polymorphism to separate out the logic for handling thesecases from the base logic. This is a particularly useful refactoring if I\u2019m about tointroduce more special logic for this case\u2014and the logic for these repeat China voyagescan make it harder to understand the base case.I\u2019m beginning with a set of functions. To introduce polymorphism, I need to create aclass structure, so I begin by applying Combine Functions into Class (144). This resultsin the following code:function rating(voyage, history) {  return new Rating(voyage, history).value;}class Rating {  constructor(voyage, history) {    this.voyage = voyage;    this.history = history;  }  get value() {    const vpf = this.voyageProfitFactor;    const vr = this.voyageRisk;    const chr = this.captainHistoryRisk;    if (vpf * 3 > (vr + chr * 2)) return \"A\";    else return \"B\";  }  get voyageRisk() {    let result = 1;    if (this.voyage.length > 4) result += 2;    if (this.voyage.length > 8) result += this.voyage.length \u00ad 8;    if ([\"china\", \"east\u00adindies\"].includes(this.voyage.zone)) result += 4;    return Math.max(result, 0);  }  get captainHistoryRisk() {    let result = 1;    if (this.history.length < 5) result += 4;    result += this.history.filter(v => v.profit < 0).length;    if (this.voyage.zone === \"china\" && this.hasChinaHistory) result \u00ad= 2;    return Math.max(result, 0);  }  get voyageProfitFactor() {    let result = 2;    if (this.voyage.zone === \"china\") result += 1;    if (this.voyage.zone === \"east\u00adindies\") result += 1;    if (this.voyage.zone === \"china\" && this.hasChinaHistory) {      result += 3;      if (this.history.length > 10) result += 1;      if (this.voyage.length > 12) result += 1;      if (this.voyage.length > 18) result \u00ad= 1;    }    else {      if (this.history.length > 8) result += 1;      if (this.voyage.length > 14) result \u00ad= 1;    }    return result;  }  get hasChinaHistory() {    return this.history.some(v => \"china\" === v.zone);  }}That\u2019s given me the class for the base case. I now need to create an empty subclass tohouse the variant behavior.class ExperiencedChinaRating extends Rating {}I then create a factory function to return the variant class when needed.function createRating(voyage, history) {  if (voyage.zone === \"china\" && history.some(v => \"china\" === v.zone))    return new ExperiencedChinaRating(voyage, history);  else return new Rating(voyage, history);}I need to modify any callers to use the factory function instead of directly invoking theconstructor, which in this case is just the rating function.function rating(voyage, history) {  return createRating(voyage, history).value;}There are two bits of behavior I need to move into a subclass. I begin with the logic incaptainHistoryRisk:class Rating...get captainHistoryRisk() {  let result = 1;  if (this.history.length < 5) result += 4;  result += this.history.filter(v => v.profit < 0).length;  if (this.voyage.zone === \"china\" && this.hasChinaHistory) result \u00ad= 2;  return Math.max(result, 0);}I write the overriding method in the subclass:class ExperiencedChinaRatingget captainHistoryRisk() {  const result = super.captainHistoryRisk \u00ad 2;  return Math.max(result, 0);}class Rating...get captainHistoryRisk() {  let result = 1;  if (this.history.length < 5) result += 4;  result += this.history.filter(v => v.profit < 0).length;  if (this.voyage.zone === \"china\" && this.hasChinaHistory) result \u00ad= 2;  return Math.max(result, 0);}Separating the variant behavior from voyageProfitFactor is a bit more messy. Ican\u2019t simply remove the variant behavior and call the superclass method since there isan alternative path here. I also don\u2019t want to copy the whole superclass method down tothe subclass.class Rating...get voyageProfitFactor() {  let result = 2;  if (this.voyage.zone === \"china\") result += 1;  if (this.voyage.zone === \"east\u00adindies\") result += 1;  if (this.voyage.zone === \"china\" && this.hasChinaHistory) {    result += 3;    if (this.history.length > 10) result += 1;    if (this.voyage.length > 12) result += 1;    if (this.voyage.length > 18) result \u00ad= 1;  }  else {    if (this.history.length > 8) result += 1;    if (this.voyage.length > 14) result \u00ad= 1;  }  return result;}So my response is to first use Extract Function (106) on the entire conditional block.class Rating...get voyageProfitFactor() {  let result = 2;  if (this.voyage.zone === \"china\") result += 1;  if (this.voyage.zone === \"east\u00adindies\") result += 1;  result += this.voyageAndHistoryLengthFactor;  return result;}get voyageAndHistoryLengthFactor() {  let result = 0;  if (this.voyage.zone === \"china\" && this.hasChinaHistory) {    result += 3;    if (this.history.length > 10) result += 1;    if (this.voyage.length > 12) result += 1;    if (this.voyage.length > 18) result \u00ad= 1;  }  else {    if (this.history.length > 8) result += 1;    if (this.voyage.length > 14) result \u00ad= 1;  }  return result;}A function name with an \u201cAnd\u201d in it is a pretty bad smell, but I\u2019ll let it sit and reek for amoment, while I apply the subclassing.class Rating...get voyageAndHistoryLengthFactor() {  let result = 0;  if (this.history.length > 8) result += 1;  if (this.voyage.length > 14) result \u00ad= 1;  return result;}class ExperiencedChinaRating...get voyageAndHistoryLengthFactor() {  let result = 0;  result += 3;  if (this.history.length > 10) result += 1;  if (this.voyage.length > 12) result += 1;  if (this.voyage.length > 18) result \u00ad= 1;  return result;}That\u2019s, formally, the end of the refactoring\u2014I\u2019ve separated the variant behavior out intothe subclass. The superclass\u2019s logic is simpler to understand and work with, and I onlyneed to deal with variant case when I\u2019m working on the subclass code, which isexpressed in terms of its difference with the superclass.But I feel I should at least outline what I\u2019d do with the awkward new method.Introducing a method purely for overriding by a subclass is a common thing to do whendoing this kind of base\u00adand\u00advariation inheritance. But a crude method like thisobscures what\u2019s going on, instead of revealing.The \u201cAnd\u201d gives away that there are really two separate modifications going on here\u2014soI think it\u2019s wise to separate them. I\u2019ll do this by using Extract Function (106) on thehistory length modification, both in the superclass and subclass. I start with just thesuperclass:class Rating...get voyageAndHistoryLengthFactor() {  let result = 0;  result += this.historyLengthFactor;  if (this.voyage.length > 14) result \u00ad= 1;  return result;}get historyLengthFactor() {  return (this.history.length > 8) ? 1 : 0;}I do the same with the subclass:class ExperiencedChinaRating...get voyageAndHistoryLengthFactor() {  let result = 0;  result += 3;  result += this.historyLengthFactor;  if (this.voyage.length > 12) result += 1;  if (this.voyage.length > 18) result \u00ad= 1;  return result;}get historyLengthFactor() {  return (this.history.length > 10) ? 1 : 0;}I can then use Move Statements to Callers (217) on the superclass case.class Rating...get voyageProfitFactor() {  let result = 2;  if (this.voyage.zone === \"china\") result += 1;  if (this.voyage.zone === \"east\u00adindies\") result += 1;  result += this.historyLengthFactor;  result += this.voyageAndHistoryLengthFactor;  return result;}get voyageAndHistoryLengthFactor() {  let result = 0;  result += this.historyLengthFactor;  if (this.voyage.length > 14) result \u00ad= 1;  return result;}class ExperiencedChinaRating...get voyageAndHistoryLengthFactor() {  let result = 0;  result += 3;  result += this.historyLengthFactor;  if (this.voyage.length > 12) result += 1;  if (this.voyage.length > 18) result \u00ad= 1;  return result;}I\u2019d then use Rename Function (124).class Rating...get voyageProfitFactor() {  let result = 2;  if (this.voyage.zone === \"china\") result += 1;  if (this.voyage.zone === \"east\u00adindies\") result += 1;  result += this.historyLengthFactor;  result += this.voyageLengthFactor;  return result;}get voyageLengthFactor() {  return (this.voyage.length > 14) ? \u00ad 1: 0;}Changing to a ternary to simplify voyageLengthFactor.class ExperiencedChinaRating...get voyageLengthFactor() {  let result = 0;  result += 3;  if (this.voyage.length > 12) result += 1;  if (this.voyage.length > 18) result \u00ad= 1;  return result;}One last thing. I don\u2019t think adding 3 points makes sense as part of the voyage lengthfactor\u2014it\u2019s better added to the overall result.class ExperiencedChinaRating...  get voyageProfitFactor() {    return super.voyageProfitFactor + 3;  }get voyageLengthFactor() {  let result = 0;  result += 3;  if (this.voyage.length > 12) result += 1;  if (this.voyage.length > 18) result \u00ad= 1;  return result;}At the end of the refactoring, I have the following code. First, there is the basic ratingclass which can ignore any complications of the experienced China case:class Rating {  constructor(voyage, history) {    this.voyage = voyage;    this.history = history;  }  get value() {    const vpf = this.voyageProfitFactor;    const vr = this.voyageRisk;    const chr = this.captainHistoryRisk;    if (vpf * 3 > (vr + chr * 2)) return \"A\";    else return \"B\";  }  get voyageRisk() {    let result = 1;    if (this.voyage.length > 4) result += 2;    if (this.voyage.length > 8) result += this.voyage.length \u00ad 8;    if ([\"china\", \"east\u00adindies\"].includes(this.voyage.zone)) result += 4;    return Math.max(result, 0);  }  get captainHistoryRisk() {    let result = 1;    if (this.history.length < 5) result += 4;    result += this.history.filter(v => v.profit < 0).length;    return Math.max(result, 0);  }  get voyageProfitFactor() {    let result = 2;    if (this.voyage.zone === \"china\") result += 1;    if (this.voyage.zone === \"east\u00adindies\") result += 1;    result += this.historyLengthFactor;    result += this.voyageLengthFactor;    return result;  }  get voyageLengthFactor() {    return (this.voyage.length > 14) ? \u00ad 1: 0;  }  get historyLengthFactor() {    return (this.history.length > 8) ? 1 : 0;  }}The code for the experienced China case reads as a set of variations on the base:class ExperiencedChinaRating extends Rating {  get captainHistoryRisk() {    const result = super.captainHistoryRisk \u00ad 2;    return Math.max(result, 0);  }  get voyageLengthFactor() {    let result = 0;    if (this.voyage.length > 12) result += 1;    if (this.voyage.length > 18) result \u00ad= 1;    return result;  }  get historyLengthFactor() {    return (this.history.length > 10) ? 1 : 0;  }  get voyageProfitFactor() {    return super.voyageProfitFactor + 3;  }}"
    },
    "INTRODUCE SPECIAL CASE": {
        "Mechanics": "Begin with a container data structure (or class) that contains a property which is thesubject of the refactoring. Clients of the container compare the subject property ofthe container to a special\u00adcase value. We wish to replace the special\u00adcase value of thesubject with a special case class or data structure.Add a special\u00adcase check property to the subject, returning false.Create a special\u00adcase object with only the special\u00adcase check property, returningtrue.Apply Extract Function (106) to the special\u00adcase comparison code. Ensure that allclients use the new function instead of directly comparing it.Introduce the new special\u00adcase subject into the code, either by returning it from afunction call or by applying a transform function.Change the body of the special\u00adcase comparison function so that it uses the special\u00adcase check property.Test.Use Combine Functions into Class (144) or Combine Functions into Transform(149) to move all of the common special\u00adcase behavior into the new element.Since the special\u00adcase class usually returns fixed values to simple requests, thesemay be handled by making the special case a literal record.Use Inline Function (115) on the special\u00adcase comparison function for the placeswhere it\u2019s still needed.",
        "Example": "A utility company installs its services in sites.class Site...get customer() {return this._customer;}There are various properties of the customer class; I\u2019ll consider three of them.class Customer...get name()           {...}get billingPlan()    {...}set billingPlan(arg) {...}get paymentHistory() {...}Most of the time, a site has a customer, but sometimes there isn\u2019t one. Someone mayhave moved out and I don\u2019t yet know who, if anyone, has moved in. When this happens,the data record fills the customer field with the string \u201cunknown\u201d. Because this canhappen, clients of the site need to be able to handle an unknown customer. Here aresome example fragments:client 1...const aCustomer = site.customer;// ... lots of intervening code ...let customerName;if (aCustomer === \"unknown\") customerName = \"occupant\";else customerName = aCustomer.name;client 2...const plan = (aCustomer === \"unknown\") ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...if (aCustomer !== \"unknown\") aCustomer.billingPlan = newPlan;client 4...const weeksDelinquent = (aCustomer === \"unknown\") ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;Looking through the code base, I see many clients of the site object that have to dealwith an unknown customer. Most of them do the same thing when they get one: Theyuse \u201coccupant\u201d as the name, give them a basic billing plan, and class them as zero\u00adweeks delinquent. This widespread testing for a special case, plus a common response,is what tells me it\u2019s time for a Special Case Object.I begin by adding a method to the customer to indicate it is unknown.class Customer...get isUnknown() {return false;}I then add an Unknown Customer class.class UnknownCustomer {  get isUnknown() {return true;}}Note that I don\u2019t make UnknownCustomer a subclass of Customer. In otherlanguages, particularly those statically typed, I would, but JavaScript\u2019s rules forsubclassing, as well as its dynamic typing, make it better to not do that here.Now comes the tricky bit. I have to return this new special\u00adcase object whenever Iexpect \"unknown\" and change each test for an unknown value to use the newisUnknown method. In general, I always want to arrange things so I can make onesmall change at a time, then test. But if I change the customer class to return anunknown customer instead of \u201cunknown\u201d, I have to make every client testing for\u201cunknown\u201d to call isUnknown\u2014and I have to do it all at once. I find that as appealingas eating liver (i.e., not at all).There is a common technique to use whenever I find myself in this bind. I use ExtractFunction (106) on the code that I\u2019d have to change in lots of places\u2014in this case, thespecial\u00adcase comparison code.function isUnknown(arg) {  if (!((arg instanceof Customer) || (arg === \"unknown\")))    throw new Error(`investigate bad value: <${arg}>`);  return (arg === \"unknown\");}I\u2019ve put a trap in here for an unexpected value. This can help me to spot any mistakes orodd behavior as I\u2019m doing this refactoring.I can now use this function whenever I\u2019m testing for an unknown customer. I canchange these calls one at a time, testing after each change.client 1...let customerName;if (isUnknown(aCustomer)) customerName = \"occupant\";else customerName = aCustomer.name;After a while, I have done them all.client 2...const plan = (isUnknown(aCustomer)) ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;client 4...const weeksDelinquent = isUnknown(aCustomer) ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;Once I\u2019ve changed all the callers to use isUnknown, I can change the site class to returnan unknown customer.class Site...get customer() {  return (this._customer === \"unknown\") ? new UnknownCustomer() : this._customer}I can check that I\u2019m no longer using the \u201cunknown\u201d string by changing isUnknown touse the unknown value.client 1...function isUnknown(arg) {  if (!(arg instanceof Customer || arg instanceof UnknownCustomer))    throw new Error(`investigate bad value: <${arg}>`);  return arg.isUnknown;}I test to ensure that\u2019s all working.Now the fun begins. I can use Combine Functions into Class (144) to take each client\u2019sspecial\u00adcase check and see if I can replace it with a commonly expected value. At themoment, I have various clients using \u201coccupant\u201d for the name of an unknown customer,like this:client 1...let customerName;if (isUnknown(aCustomer)) customerName = \"occupant\";else customerName = aCustomer.name;I add a suitable method to the unknown customer:class UnknownCustomer...get name() {return \"occupant\";}Now I can make all that conditional code go away.client 1...const customerName = aCustomer.name;Once I\u2019ve tested that this works, I\u2019ll probably be able to use Inline Variable (123) onthat variable too.Next is the billing plan property.client 2...const plan = (isUnknown(aCustomer)) ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan;For read behavior, I do the same thing I did with the name\u2014take the common responseand reply with it. With the write behavior, the current code doesn\u2019t call the setter for anunknown customer\u2014so for the special case, I let the setter be called, but it doesnothing.class UnknownCustomer...get billingPlan()    {return registry.billingPlans.basic;}set billingPlan(arg) { /* ignore */ }client reader...const plan = aCustomer.billingPlan;client writer...aCustomer.billingPlan = newPlan;Special\u00adcase objects are value objects, and thus should always be immutable, even if theobjects they are substituting for are not.The last case is a bit more involved because the special case needs to return anotherobject that has its own properties.client...const weeksDelinquent = isUnknown(aCustomer) ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;The general rule with a special\u00adcase object is that if it needs to return related objects,they are usually special cases themselves. So here I need to create a null paymenthistory.class UnknownCustomer...get paymentHistory() {return new NullPaymentHistory();}class NullPaymentHistory...get weeksDelinquentInLastYear() {return 0;}client...const weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;I carry on, looking at all the clients to see if I can replace them with the polymorphicbehavior. But there will be exceptions\u2014clients that want to do something different withthe special case. I may have 23 clients that use \u201coccupant\u201d for the name of an unknowncustomer, but there\u2019s always one that needs something different.client...const name = ! isUnknown(aCustomer) ? aCustomer.name : \"unknown occupant\";In that case, I need to retain a special\u00adcase check. I will change it to use the method oncustomer, essentially using Inline Function (115) on isUnknown.client...const name = aCustomer.isUnknown ? \"unknown occupant\" : aCustomer.name;When I\u2019m done with all the clients, I should be able to use Remove Dead Code (237) onthe global isPresent function, as nobody should be calling it any more.",
        "Example: Using an Object Literal": "Creating a class like this is a fair bit of work for what is really a simple value. But for theexample I gave, I had to make the class since the customer could be updated. If,however, I only read the data structure, I can use a literal object instead.Here is the opening case again\u2014just the same, except this time there is no client thatupdates the customer:class Site...get customer() {return this._customer;}class Customer...get name()           {...}get billingPlan()    {...}set billingPlan(arg) {...}get paymentHistory() {...}client 1...const aCustomer = site.customer;// ... lots of intervening code ...let customerName;if (aCustomer === \"unknown\") customerName = \"occupant\";else customerName = aCustomer.name;client 2...const plan = (aCustomer === \"unknown\") ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...const weeksDelinquent = (aCustomer === \"unknown\") ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;As with the previous case, I start by adding an isUnknown property to the customerand creating a special\u00adcase object with that field. The difference is that this time, thespecial case is a literal.class Customer...get isUnknown() {return false;}top level...function createUnknownCustomer() {  return {    isUnknown: true,  };}I apply Extract Function (106) to the special case condition test.function isUnknown(arg) {  return (arg === \"unknown\");}client 1...let customerName;if (isUnknown(aCustomer)) customerName = \"occupant\";else customerName = aCustomer.name;client 2...const plan = isUnknown(aCustomer) ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...const weeksDelinquent = isUnknown(aCustomer) ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;I change the site class and the condition test to work with the special case.class Site...get customer() {  return (this._customer === \"unknown\") ? createUnknownCustomer() : this._custom}top level...function isUnknown(arg) {  return arg.isUnknown;}Then I replace each standard response with the appropriate literal value. I start withthe name:function createUnknownCustomer() {  return {    isUnknown: true,    name: \"occupant\",  };}client 1...const customerName = aCustomer.name;Then, the billing plan:function createUnknownCustomer() {  return {    isUnknown: true,    name: \"occupant\",    billingPlan: registry.billingPlans.basic,  };}client 2...const plan = aCustomer.billingPlan;Similarly, I can create a nested null payment history with the literal:function createUnknownCustomer() {  return {    isUnknown: true,    name: \"occupant\",    billingPlan: registry.billingPlans.basic,    paymentHistory: {      weeksDelinquentInLastYear: 0,    },  };}client 3...const weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;If I use a literal like this, I should make it immutable, which I might do with freeze.Usually, I\u2019d rather use a class.",
        "Example: Using a Transform": "Both previous cases involve a class, but the same idea can be applied to a record byusing a transform step.Let\u2019s assume our input is a simple record structure that looks something like this:{  name: \"Acme Boston\",  location: \"Malden MA\",  // more site details  customer: {    name: \"Acme Industries\",    billingPlan: \"plan\u00ad451\",    paymentHistory: {      weeksDelinquentInLastYear: 7      //more    },    // more  }}In some cases, the customer isn\u2019t known, and such cases are marked in the same way:{  name: \"Warehouse Unit 15\",  location: \"Malden MA\",  // more site details  customer: \"unknown\",}I have similar client code that checks for the unknown customer:client 1...const site = acquireSiteData();const aCustomer = site.customer;// ... lots of intervening code ...let customerName;if (aCustomer === \"unknown\") customerName = \"occupant\";else customerName = aCustomer.name;client 2...const plan = (aCustomer === \"unknown\") ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...const weeksDelinquent = (aCustomer === \"unknown\") ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;My first step is to run the site data structure through a transform that, currently, doesnothing but a deep copy.client 1...  const rawSite = acquireSiteData();  const site = enrichSite(rawSite);  const aCustomer = site.customer;  // ... lots of intervening code ...  let customerName;  if (aCustomer === \"unknown\") customerName = \"occupant\";  else customerName = aCustomer.name;function enrichSite(inputSite) {  return _.cloneDeep(inputSite);}I apply Extract Function (106) to the test for an unknown customer.function isUnknown(aCustomer) {  return aCustomer === \"unknown\";}client 1...const rawSite = acquireSiteData();const site = enrichSite(rawSite);const aCustomer = site.customer;// ... lots of intervening code ...let customerName;if (isUnknown(aCustomer)) customerName = \"occupant\";else customerName = aCustomer.name;client 2...const plan = (isUnknown(aCustomer)) ?      registry.billingPlans.basic      : aCustomer.billingPlan;client 3...const weeksDelinquent = (isUnknown(aCustomer)) ?      0      : aCustomer.paymentHistory.weeksDelinquentInLastYear;I begin the enrichment by adding an isUnknown property to the customer.function enrichSite(aSite) {  const result = _.cloneDeep(aSite);  const unknownCustomer = {    isUnknown: true,  };  if (isUnknown(result.customer)) result.customer = unknownCustomer;  else result.customer.isUnknown = false;  return result;}I can then modify the special\u00adcase condition test to include probing for this newproperty. I keep the original test as well, so that the test will work on both raw andenriched sites.function isUnknown(aCustomer) {  if (aCustomer === \"unknown\") return true;  else return aCustomer.isUnknown;}I test to ensure that\u2019s all OK, then start applying Combine Functions into Transform(149) on the special case. First, I move the choice of name into the enrichment function.function enrichSite(aSite) {  const result = _.cloneDeep(aSite);  const unknownCustomer = {    isUnknown: true,    name: \"occupant\",  };  if (isUnknown(result.customer)) result.customer = unknownCustomer;  else result.customer.isUnknown = false;  return result;}client 1...const rawSite = acquireSiteData();const site = enrichSite(rawSite);const aCustomer = site.customer;// ... lots of intervening code ...const customerName = aCustomer.name;I test, then do the billing plan.function enrichSite(aSite) {  const result = _.cloneDeep(aSite);  const unknownCustomer = {    isUnknown: true,    name: \"occupant\",    billingPlan: registry.billingPlans.basic,  };  if (isUnknown(result.customer)) result.customer = unknownCustomer;  else result.customer.isUnknown = false;  return result;}client 2...const plan = aCustomer.billingPlan;I test again, then do the last client.function enrichSite(aSite) {  const result = _.cloneDeep(aSite);  const unknownCustomer = {    isUnknown: true,    name: \"occupant\",    billingPlan: registry.billingPlans.basic,    paymentHistory: {      weeksDelinquentInLastYear: 0,    }  };  if (isUnknown(result.customer)) result.customer = unknownCustomer;  else result.customer.isUnknown = false;  return result;}client 3...const weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear;"
    },
    "INTRODUCE ASSERTION": {
        "Mechanics": "When you see that a condition is assumed to be true, add an assertion to state it.Since assertions should not affect the running of a system, adding one is alwaysbehavior\u00adpreserving.",
        "Example": "Here\u2019s a simple tale of discounts. A customer can be given a discount rate to apply to alltheir purchases:class Customer...applyDiscount(aNumber) {  return (this.discountRate)    ? aNumber \u00ad (this.discountRate * aNumber)    : aNumber;}There\u2019s an assumption here that the discount rate is a positive number. I can make thatassumption explicit by using an assertion. But I can\u2019t easily place an assertion into aternary expression, so first I\u2019ll reformulate it as an if\u00adthen statement.class Customer...applyDiscount(aNumber) {  if (!this.discountRate) return aNumber;  else return aNumber \u00ad (this.discountRate * aNumber);}Now I can easily add the assertion.class Customer...applyDiscount(aNumber) {  if (!this.discountRate) return aNumber;  else {    assert(this.discountRate >= 0);    return aNumber \u00ad (this.discountRate * aNumber);  }}In this case, I\u2019d rather put this assertion into the setting method. If the assertion fails inapplyDiscount, my first puzzle is how it got into the field in the first place.class Customer...set discountRate(aNumber) {  assert(null === aNumber || aNumber >= 0);  this._discountRate = aNumber;}An assertion like this can be particularly valuable if it\u2019s hard to spot the error source\u2014which may be an errant minus sign in some input data or some inversion elsewhere inthe code.There is a real danger of overusing assertions. I don\u2019t use assertions to check everythingthat I think is true, but only to check things that need to be true. Duplication is aparticular problem, as it\u2019s common to tweak these kinds of conditions. So I find it\u2019sessential to remove any duplication in these conditions, usually by a liberal use ofExtract Function (106).I only use assertions for things that are programmer errors. If I\u2019m reading data from anexternal source, any value checking should be a first\u00adclass part of the program, not anassertion\u2014unless I\u2019m really confident in the external source. Assertions are a last resortto help track bugs\u2014though, ironically, I only use them when I think they should neverfail.Modules and their functions are the building blocks of our software. APIs are the jointsthat we use to plug them together. Making these APIs easy to understand and use isimportant but also difficult: I need to refactor them as I learn how to improve them.A good API clearly separates any functions that update data from those that only readdata. If I see them combined, I use Separate Query from Modifier (306) to tease themapart. I can unify functions that only vary due to a value with Parameterize Function(310). Some parameters, however, are really just a signal of an entirely differentbehavior and are best excised with Remove Flag Argument (314).Data structures are often unpacked unnecessarily when passed between functions; Iprefer to keep them together with Preserve Whole Object (319). Decisions on whatshould be passed as a parameter, and what can be resolved by the called function, areones I often need to revisit with Replace Parameter with Query (324) and ReplaceQuery with Parameter (327).A class is a common form of module. I prefer my objects to be as immutable as possible,so I use Remove Setting Method (331) whenever I can. Often, when a caller asks for anew object, I need more flexibility than a simple constructor gives, which I can get byusing Replace Constructor with Factory Function (334).The last two refactorings address the difficulty of breaking down a particularly complexfunction that passes a lot of data around. I can turn that function into an object withReplace Function with Command (337), which makes it easier to use Extract Function(106) on the function\u2019s body. If I later simplify the function and no longer need it as acommand object, I turn it back into a function with Replace Command with Function(344)."
    },
    "SEPARATE QUERY FROM MODIFIER": {
        "Mechanics": "Copy the function, name it as a query.Look into the function to see what is returned. If the query is used to populate avariable, the variable\u2019s name should provide a good clue.Remove any side effects from the new query function.Run static checks.Find each call of the original method. If that call uses the return value, replace theoriginal call with a call to the query and insert a call to the original method below it.Test after each change.Remove return values from original.Test.Often after doing this there will be duplication between the query and the originalmethod that can be tidied up.",
        "Example": "Here is a function that scans a list of names for a miscreant. If it finds one, it returnsthe name of the bad guy and sets off the alarms. It only does this for the first miscreantit finds (I guess one is enough).function alertForMiscreant (people) {  for (const p of people) {    if (p === \"Don\") {      setOffAlarms();      return \"Don\";    }    if (p === \"John\") {      setOffAlarms();      return \"John\";    }  }  return \"\";}I begin by copying the function, naming it after the query aspect of the function.function findMiscreant (people) {  for (const p of people) {    if (p === \"Don\") {      setOffAlarms();      return \"Don\";    }    if (p === \"John\") {      setOffAlarms();      return \"John\";    }  }  return \"\";}I remove the side effects from this new query.function findMiscreant (people) {  for (const p of people) {    if (p === \"Don\") {      setOffAlarms();      return \"Don\";    }    if (p === \"John\") {      setOffAlarms();      return \"John\";    }  }  return \"\";}I now go to each caller and replace it with a call to the query, followed by a call to themodifier. Soconst found = alertForMiscreant(people);changes toconst found = findMiscreant(people);alertForMiscreant(people);I now remove the return values from the modifier.function alertForMiscreant (people) {  for (const p of people) {    if (p === \"Don\") {      setOffAlarms();      return;    }    if (p === \"John\") {      setOffAlarms();      return;    }  }  return;}Now I have a lot of duplication between the original modifier and the new query, so Ican use Substitute Algorithm (195) so that the modifier uses the query.function alertForMiscreant (people) {  if (findMiscreant(people) !== \"\") setOffAlarms();}"
    },
    "PARAMETERIZE FUNCTION": {
        "Mechanics": "Select one of the similar methods.Use Change Function Declaration (124) to add any literals that need to turn intoparameters.For each caller of the function, add the literal value.Test.Change the body of the function to use the new parameters. Test after each change.For each similar function, replace the call with a call to the parameterized function.Test after each one.If the original parameterized function doesn\u2019t work for a similar function, adjust itfor the new function before moving on to the next.",
        "Example": "An obvious example is something like this:function tenPercentRaise(aPerson) {  aPerson.salary = aPerson.salary.multiply(1.1);}function fivePercentRaise(aPerson) {  aPerson.salary = aPerson.salary.multiply(1.05);}Hopefully it\u2019s obvious that I can replace these withfunction raise(aPerson, factor) {  aPerson.salary = aPerson.salary.multiply(1 + factor);}But it can be a bit more involved than that. Consider this code:function baseCharge(usage) {  if (usage < 0) return usd(0);  const amount =        bottomBand(usage) * 0.03        + middleBand(usage) * 0.05        + topBand(usage) * 0.07;  return usd(amount);}function bottomBand(usage) {  return Math.min(usage, 100);}function middleBand(usage) {  return usage > 100 ? Math.min(usage, 200) \u00ad 100 : 0;}function topBand(usage) {  return usage > 200 ? usage \u00ad 200 : 0;}Here the logic is clearly pretty similar\u2014but is it similar enough to support creating aparameterized method for the bands? It is, but may be a touch less obvious than thetrivial case above.When looking to parameterize some related functions, my approach is to take one ofthe functions and add parameters to it, with an eye to the other cases. With range\u00adoriented things like this, usually the place to start is with the middle range. So I\u2019ll workon middleBand to change it to use parameters, and then adjust other callers to fit.middleBand uses two literal values: 100 and 200. These represent the bottom and topof this middle band. I begin by using Change Function Declaration (124) to add themto the call. While I\u2019m at it, I\u2019ll also change the name of the function to something thatmakes sense with the parameterization.function withinBand(usage, bottom, top) {  return usage > 100 ? Math.min(usage, 200) \u00ad 100 : 0;}function baseCharge(usage) {  if (usage < 0) return usd(0);  const amount =        bottomBand(usage) * 0.03        + withinBand(usage, 100, 200) * 0.05        + topBand(usage) * 0.07;  return usd(amount);}I replace each literal with a reference to the parameter:function withinBand(usage, bottom, top) {  return usage > bottom ? Math.min(usage, 200) \u00ad bottom : 0;}then:function withinBand(usage, bottom, top) {  return usage > bottom ? Math.min(usage, top) \u00ad bottom : 0;}I replace the call to the bottom band with a call to the newly parameterized function.function baseCharge(usage) {  if (usage < 0) return usd(0);  const amount =        withinBand(usage, 0, 100) * 0.03        + withinBand(usage, 100, 200) * 0.05        + topBand(usage) * 0.07;  return usd(amount);}function bottomBand(usage) {  return Math.min(usage, 100);}To replace the call to the top band, I need to make use of infinity.function baseCharge(usage) {  if (usage < 0) return usd(0);  const amount =        withinBand(usage, 0, 100) * 0.03        + withinBand(usage, 100, 200) * 0.05        + withinBand(usage, 200, Infinity) * 0.07;  return usd(amount);}function topBand(usage) {  return usage > 200 ? usage \u00ad 200 : 0;}With the logic working the way it does now, I could remove the initial guard clause. Butalthough it\u2019s logically unnecessary now, I like to keep it as it documents how to handlethat case."
    },
    "REMOVE FLAG ARGUMENT": {
        "Mechanics": "Create an explicit function for each value of the parameter.If the main function has a clear dispatch conditional, use Decompose Conditional(260) to create the explicit functions. Otherwise, create wrapping functions.For each caller that uses a literal value for the parameter, replace it with a call to theexplicit function.",
        "Example": "Looking through some code, I see calls to calculate a delivery date for a shipment. Someof the calls look likeaShipment.deliveryDate = deliveryDate(anOrder, true);and some look likeaShipment.deliveryDate = deliveryDate(anOrder, false);Faced with code like this, I immediately begin to wonder about the meaning of theboolean value. What is it doing?The body of deliveryDate looks like this:function deliveryDate(anOrder, isRush) {  if (isRush) {    let deliveryTime;    if ([\"MA\", \"CT\"]     .includes(anOrder.deliveryState)) deliveryTime = 1;    else if ([\"NY\", \"NH\"].includes(anOrder.deliveryState)) deliveryTime = 2;    else deliveryTime = 3;    return anOrder.placedOn.plusDays(1 + deliveryTime);  }  else {    let deliveryTime;    if ([\"MA\", \"CT\", \"NY\"].includes(anOrder.deliveryState)) deliveryTime = 2;    else if ([\"ME\", \"NH\"] .includes(anOrder.deliveryState)) deliveryTime = 3;    else deliveryTime = 4;    return anOrder.placedOn.plusDays(2 + deliveryTime);  }}Here, the caller is using a literal boolean value to determine which code should run\u2014aclassic flag argument. But the whole point of using a function is to follow the caller\u2019sinstructions, so it is better to clarify the caller\u2019s intent with explicit functions.In this case, I can do this by using Decompose Conditional (260), which gives me this:function deliveryDate(anOrder, isRush) {  if (isRush) return rushDeliveryDate(anOrder);  else        return regularDeliveryDate(anOrder);}function rushDeliveryDate(anOrder) {    let deliveryTime;    if ([\"MA\", \"CT\"]     .includes(anOrder.deliveryState)) deliveryTime = 1;    else if ([\"NY\", \"NH\"].includes(anOrder.deliveryState)) deliveryTime = 2;    else deliveryTime = 3;    return anOrder.placedOn.plusDays(1 + deliveryTime);}function regularDeliveryDate(anOrder) {    let deliveryTime;    if ([\"MA\", \"CT\", \"NY\"].includes(anOrder.deliveryState)) deliveryTime = 2;    else if ([\"ME\", \"NH\"] .includes(anOrder.deliveryState)) deliveryTime = 3;    else deliveryTime = 4;    return anOrder.placedOn.plusDays(2 + deliveryTime);}The two new functions capture the intent of the call better, so I can replace each call ofaShipment.deliveryDate = deliveryDate(anOrder, true);withaShipment.deliveryDate = rushDeliveryDate(anOrder);and similarly with the other case.When I\u2019ve replaced all the callers, I remove deliveryDate.A flag argument isn\u2019t just the presence of a boolean value; it\u2019s that the boolean is setwith a literal rather than data. If all the callers of deliveryDate were like this:const isRush = determineIfRush(anOrder);aShipment.deliveryDate = deliveryDate(anOrder, isRush);then I\u2019d have no problem with deliveryDate\u2019s signature (although I\u2019d still want toapply Decompose Conditional (260)).It may be that some callers use the argument as a flag argument by setting it with aliteral, while others set the argument with data. In this case, I\u2019d still use Remove FlagArgument, but not change the data callers and not remove deliveryDate at the end.That way I support both interfaces for the different uses.Decomposing the conditional like this is a good way to carry out this refactoring, but itonly works if the dispatch on the parameter is the outer part of the function (or I caneasily refactor it to make it so). It\u2019s also possible that the parameter is used in a muchmore tangled way, such as this alternative version of deliveryDate:function deliveryDate(anOrder, isRush) {  let result;  let deliveryTime;  if (anOrder.deliveryState === \"MA\" || anOrder.deliveryState === \"CT\")    deliveryTime = isRush? 1 : 2;  else if (anOrder.deliveryState === \"NY\" || anOrder.deliveryState === \"NH\") {    deliveryTime = 2;    if (anOrder.deliveryState === \"NH\" && !isRush)      deliveryTime = 3;  }  else if (isRush)    deliveryTime = 3;  else if (anOrder.deliveryState === \"ME\")    deliveryTime = 3;  else    deliveryTime = 4;  result = anOrder.placedOn.plusDays(2 + deliveryTime);  if (isRush) result = result.minusDays(1);  return result;}In this case, teasing out isRush into a top\u00adlevel dispatch conditional is likely morework than I fancy. So instead, I can layer functions over the deliveryDate:function rushDeliveryDate   (anOrder) {return deliveryDate(anOrder, true);}function regularDeliveryDate(anOrder) {return deliveryDate(anOrder, false);}These wrapping functions are essentially partial applications of deliveryDate,although they are defined in program text rather than by composition of functions.I can then do the same replacement of callers that I did with the decomposedconditional earlier on. If there aren\u2019t any callers using the parameter as data, I like torestrict its visibility or rename it to a name that conveys that it shouldn\u2019t be useddirectly (e.g., deliveryDateHelperOnly)."
    },
    "PRESERVE WHOLE OBJECT": {
        "Mechanics": "Create an empty function with the desired parameters.Give the function an easily searchable name so it can be replaced at the end.Fill the body of the new function with a call to the old function, mapping from thenew parameters to the old ones.Run static checks.Adjust each caller to use the new function, testing after each change.This may mean that some code that derives the parameter isn\u2019t needed, so can fallto Remove Dead Code (237).Once all original callers have been changed, use Inline Function (115) on the originalfunction.Change the name of the new function and all its callers.",
        "Example": "Consider a room monitoring system. It compares its daily temperature range with arange in a predefined heating plan.caller...const low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;if (!aPlan.withinRange(low, high))  alerts.push(\"room temperature went outside range\");class HeatingPlan...withinRange(bottom, top) {  return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRang}Instead of unpacking the range information when I pass it in, I can pass in the wholerange object.I begin by stating the interface I want as an empty function.class HeatingPlan...xxNEWwithinRange(aNumberRange) {}Since I intend it to replace the existing withinRange, I name it the same but with aneasily replaceable prefix.I then add the body of the function, which relies on calling the existing withinRange.The body thus consists of a mapping from the new parameter to the existing ones.class HeatingPlan...xxNEWwithinRange(aNumberRange) {  return this.withinRange(aNumberRange.low, aNumberRange.high);}Now I can begin the serious work, taking the existing function calls and having themcall the new function.caller...const low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))  alerts.push(\"room temperature went outside range\");When I\u2019ve changed the calls, I may see that some of the earlier code isn\u2019t neededanymore, so I wield Remove Dead Code (237).caller...const low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))  alerts.push(\"room temperature went outside range\");I replace these one at a time, testing after each change.Once I\u2019ve replaced them all, I can use Inline Function (115) on the original function.class HeatingPlan...xxNEWwithinRange(aNumberRange) {  return (aNumberRange.low >= this._temperatureRange.low) &&    (aNumberRange.high <= this._temperatureRange.high);}And I finally remove that ugly prefix from the new function and all its callers. The prefixmakes it a simple global replace, even if I don\u2019t have a robust rename support in myeditor.class HeatingPlan...withinRange(aNumberRange) {  return (aNumberRange.low >= this._temperatureRange.low) &&    (aNumberRange.high <= this._temperatureRange.high);}caller...if (!aPlan.withinRange(aRoom.daysTempRange))  alerts.push(\"room temperature went outside range\");",
        "Example: A Variation to Create the New Function": "In the above example, I wrote the code for the new function directly. Most of the time,that\u2019s pretty simple and the easiest way to go. But there is a variation on this that\u2019soccasionally useful\u2014which can allow me to compose the new function entirely fromrefactorings.I start with a caller of the existing function.caller...const low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;if (!aPlan.withinRange(low, high))  alerts.push(\"room temperature went outside range\");I want to rearrange the code so I can create the new function by using Extract Function(106) on some existing code. The caller code isn\u2019t quite there yet, but I can get there byusing Extract Variable (119) a few times. First, I disentangle the call to the old functionfrom the conditional.caller...const low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;const isWithinRange = aPlan.withinRange(low, high);if (!isWithinRange)  alerts.push(\"room temperature went outside range\");I then extract the input parameter.caller...const tempRange = aRoom.daysTempRange;const low = tempRange.low;const high = tempRange.high;const isWithinRange = aPlan.withinRange(low, high);if (!isWithinRange)  alerts.push(\"room temperature went outside range\");With that done, I can now use Extract Function (106) to create the new function.caller...const tempRange = aRoom.daysTempRange;const isWithinRange = xxNEWwithinRange(aPlan, tempRange);if (!isWithinRange)  alerts.push(\"room temperature went outside range\");top level...function xxNEWwithinRange(aPlan, tempRange) {  const low = tempRange.low;  const high = tempRange.high;  const isWithinRange = aPlan.withinRange(low, high);  return isWithinRange;}Since the original function is in a different context (the HeatingPlan class), I need touse Move Function (198).caller...const tempRange = aRoom.daysTempRange;const isWithinRange = aPlan.xxNEWwithinRange(tempRange);if (!isWithinRange)  alerts.push(\"room temperature went outside range\");class HeatingPlan...xxNEWwithinRange(tempRange) {  const low = tempRange.low;  const high = tempRange.high;  const isWithinRange = this.withinRange(low, high);  return isWithinRange;}I then continue as before, replacing other callers and inlining the old function into thenew one. I would also inline the variables I extracted to provide the clean separation forextracting the new function.Because this variation is entirely composed of refactorings, it\u2019s particularly handy whenI have a refactoring tool with robust extract and inline operations."
    },
    "REPLACE PARAMETER WITH QUERY": {
        "Mechanics": "If necessary, use Extract Function (106) on the calculation of the parameter.Replace references to the parameter in the function body with references to theexpression that yields the parameter. Test after each change.Use Change Function Declaration (124) to remove the parameter.",
        "Example": "I most often use Replace Parameter with Query when I\u2019ve done some other refactoringsthat make a parameter no longer needed. Consider this code.class Order...get finalPrice() {  const basePrice = this.quantity * this.itemPrice;  let discountLevel;  if (this.quantity > 100) discountLevel = 2;  else discountLevel = 1;  return this.discountedPrice(basePrice, discountLevel);}discountedPrice(basePrice, discountLevel) {  switch (discountLevel) {    case 1: return basePrice * 0.95;    case 2: return basePrice * 0.9;  }}When I\u2019m simplifying a function, I\u2019m keen to apply Replace Temp with Query (178),which would lead me toclass Order...get finalPrice() {  const basePrice = this.quantity * this.itemPrice;  return this.discountedPrice(basePrice, this.discountLevel);}get discountLevel() {  return (this.quantity > 100) ? 2 : 1;}Once I\u2019ve done this, there\u2019s no need to pass the result of discountLevel todiscountedPrice\u2014it can just as easily make the call itself.I replace any reference to the parameter with a call to the method instead.class Order...discountedPrice(basePrice, discountLevel) {  switch (this.discountLevel) {    case 1: return basePrice * 0.95;    case 2: return basePrice * 0.9;  }}I can then use Change Function Declaration (124) to remove the parameter.class Order...get finalPrice() {  const basePrice = this.quantity * this.itemPrice;  return this.discountedPrice(basePrice, this.discountLevel);}discountedPrice(basePrice, discountLevel) {  switch (this.discountLevel) {    case 1: return basePrice * 0.95;    case 2: return basePrice * 0.9;  }}"
    },
    "REPLACE QUERY WITH PARAMETER": {
        "Mechanics": "Use Extract Variable (119) on the query code to separate it from the rest of thefunction body.Apply Extract Function (106) to the body code that isn\u2019t the call to the query.Give the new function an easily searchable name, for later renaming.Use Inline Variable (123) to get rid of the variable you just created.Apply Inline Function (115) to the original function.Rename the new function to that of the original.",
        "Example": "Consider a simple, yet annoying, control system for temperature. It allows the user toselect a temperature on a thermostat\u2014but only sets the target temperature within arange determined by a heating plan.class HeatingPlan...get targetTemperature() {  if      (thermostat.selectedTemperature >  this._max) return this._max;  else if (thermostat.selectedTemperature <  this._min) return this._min;  else return thermostat.selectedTemperature;}caller...if      (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat();else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool();else setOff();As a user of such a system, I might be annoyed to have my desires overridden by theheating plan rules, but as a programmer I might be more concerned about how thetargetTemperature function has a dependency on a global thermostat object. I canbreak this dependency by moving it to a parameter.My first step is to use Extract Variable (119) on the parameter that I want to have in myfunction.class HeatingPlan...get targetTemperature() {  const selectedTemperature = thermostat.selectedTemperature;  if      (selectedTemperature >  this._max) return this._max;  else if (selectedTemperature <  this._min) return this._min;  else return selectedTemperature;}That makes it easy to apply Extract Function (106) on the entire body of the functionexcept for the bit that figures out the parameter.class HeatingPlan...get targetTemperature() {  const selectedTemperature = thermostat.selectedTemperature;  return this.xxNEWtargetTemperature(selectedTemperature);}xxNEWtargetTemperature(selectedTemperature) {  if      (selectedTemperature >  this._max) return this._max;  else if (selectedTemperature <  this._min) return this._min;  else return selectedTemperature;}I then inline the variable I just extracted, which leaves the function as a simple call.class HeatingPlan...get targetTemperature() {  return this.xxNEWtargetTemperature(thermostat.selectedTemperature);}I can now use Inline Function (115) on this method.caller...if      (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) >         thermostat.currentTemperature)  setToHeat();else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) <         thermostat.currentTemperature)  setToCool();else  setOff();I take advantage of the easily searchable name of the new function to rename it byremoving the prefix.caller...if      (thePlan.targetTemperature(thermostat.selectedTemperature) >         thermostat.currentTemperature)  setToHeat();else if (thePlan.targetTemperature(thermostat.selectedTemperature) <         thermostat.currentTemperature)  setToCool();else  setOff();class HeatingPlan...targetTemperature(selectedTemperature) {  if      (selectedTemperature >  this._max) return this._max;  else if (selectedTemperature <  this._min) return this._min;  else return selectedTemperature;}As is often the case with this refactoring, the calling code looks more unwieldy thanbefore. Moving a dependency out of a module pushes the responsibility of dealing withthat dependency back to the caller. That\u2019s the trade\u00adoff for the reduced coupling.But removing the coupling to the thermostat object isn\u2019t the only gain I\u2019ve made withthis refactoring. The HeatingPlan class is immutable\u2014its fields are set in theconstructor with no methods to alter them. (I\u2019ll save you the effort of looking at thewhole class; just trust me on this.) Given an immutable heating plan, by moving thethermostat reference out of the function body I\u2019ve also made targetTemperaturereferentially transparent. Every time I call targetTemperature on the same object,with the same argument, I will get the same result. If all the methods of the heatingplan have referential transparency, that makes this class much easier to test and reasonabout.A problem with JavaScript\u2019s class model is that it\u2019s impossible to enforce an immutableclass\u2014there\u2019s always a way to get at an object\u2019s data. But writing a class to signal andencourage immutability is often good enough. Creating classes that have thischaracteristic is often a sound strategy and Replace Query with Parameter is a handytool for doing this."
    },
    "REMOVE SETTING METHOD": {
        "Mechanics": "If the value that\u2019s being set isn\u2019t provided to the constructor, use Change FunctionDeclaration (124) to add it. Add a call to the setting method within the constructor.If you wish to remove several setting methods, add all their values to theconstructor at once. This simplifies the later steps.Remove each call of a setting method outside of the constructor, using the newconstructor value instead. Test after each one.If you can\u2019t replace the call to the setter by creating a new object (because you areupdating a shared reference object), abandon the refactoring.Use Inline Function (115) on the setting method. Make the field immutable ifpossible.Test.",
        "Example": "I have a simple person class.class Person...get name()    {return this._name;}set name(arg) {this._name = arg;}get id()    {return this._id;}set id(arg) {this._id = arg;}At the moment, I create a new object with code like this:const martin = new Person();martin.name = \"martin\";martin.id = \"1234\";The name of a person may change after it\u2019s created, but the ID does not. To make thisclear, I want to remove the setting method for ID.I still need to set the ID initially, so I\u2019ll use Change Function Declaration (124) to add itto the constructor.class Person...constructor(id) {  this.id = id;}I then adjust the creation script to set the ID via the constructor.const martin = new Person(\"1234\");martin.name = \"martin\";martin.id = \"1234\";I do this in each place I create a person, testing after each change.When they are all done, I can apply Inline Function (115) to the setting method.class Person...constructor(id) {  this._id = id;}get name()    {return this._name;}set name(arg) {this._name = arg;}get id()    {return this._id;}set id(arg) {this._id = arg;}"
    },
    "REPLACE CONSTRUCTOR WITH FACTORY FUNCTION": {
        "Mechanics": "Create a factory function, its body being a call to the constructor.Replace each call to the constructor with a call to the factory function.Test after each change.Limit the constructor\u2019s visibility as much as possible.",
        "Example": "A quick but wearisome example uses kinds of employees. Consider an employee class:class Employee...constructor (name, typeCode) {  this._name = name;  this._typeCode = typeCode;}get name() {return this._name;}get type() {  return Employee.legalTypeCodes[this._typeCode];}static get legalTypeCodes() {  return {\"E\": \"Engineer\", \"M\": \"Manager\", \"S\": \"Salesman\"};}This is used fromcaller...candidate = new Employee(document.name, document.empType);andcaller...const leadEngineer = new Employee(document.leadEngineer, 'E');My first step is to create the factory function. Its body is a simple delegation to theconstructor.top level...function createEmployee(name, typeCode) {  return new Employee(name, typeCode);}I then find the callers of the constructor and change them, one at a time, to use thefactory function instead.The first one is obvious:caller...candidate = createEmployee(document.name, document.empType);With the second case, I could use the new factory function like this:caller...const leadEngineer = createEmployee(document.leadEngineer, 'E');But I don\u2019t like using the type code here\u2014it\u2019s generally a bad smell to pass a code as aliteral string. So I prefer to create a new factory function that embeds the kind ofemployee I want into its name.caller...const leadEngineer = createEngineer(document.leadEngineer);top level...function createEngineer(name) {  return new Employee(name, 'E');}"
    },
    "REPLACE FUNCTION WITH COMMAND": {
        "Mechanics": "Create an empty class for the function. Name it based on the function.Use Move Function (198) to move the function to the empty class.Keep the original function as a forwarding function until at least the end of therefactoring.Follow any convention the language has for naming commands. If there is noconvention, choose a generic name for the command\u2019s execute function, such as\u201cexecute\u201d or \u201ccall\u201d.Consider making a field for each argument, and move these arguments to theconstructor.",
        "Example": "The JavaScript language has many faults, but one of its great decisions was to makefunctions first\u00adclass entities. I thus don\u2019t have to go through all the hoops of creatingcommands for common tasks that I need to do in languages without this facility. Butthere are still times when a command is the right tool for the job.One of these cases is breaking up a complex function so I can better understand andmodify it. To really show the value of this refactoring, I need a long and complicatedfunction\u2014but that would take too long to write, let alone for you to read. Instead, I\u2019ll gowith a function that\u2019s short enough not to need it. This one scores points for aninsurance application:function score(candidate, medicalExam, scoringGuide) {  let result = 0;  let healthLevel = 0;  let highMedicalRiskFlag = false;  if (medicalExam.isSmoker) {    healthLevel += 10;    highMedicalRiskFlag = true;  }  let certificationGrade = \"regular\";  if (scoringGuide.stateWithLowCertification(candidate.originState)) {    certificationGrade = \"low\";    result \u00ad= 5;  }  // lots more code like this  result \u00ad= Math.max(healthLevel \u00ad 5, 0);  return result;}I begin by creating an empty class and then Move Function (198) to move the functioninto it.function score(candidate, medicalExam, scoringGuide) {  return new Scorer().execute(candidate, medicalExam, scoringGuide);}  class Scorer {    execute (candidate, medicalExam, scoringGuide) {      let result = 0;      let healthLevel = 0;      let highMedicalRiskFlag = false;      if (medicalExam.isSmoker) {        healthLevel += 10;        highMedicalRiskFlag = true;      }      let certificationGrade = \"regular\";      if (scoringGuide.stateWithLowCertification(candidate.originState)) {        certificationGrade = \"low\";        result \u00ad= 5;      }      // lots more code like this      result \u00ad= Math.max(healthLevel \u00ad 5, 0);      return result;    }  }Most of the time, I prefer to pass arguments to a command on the constructor and havethe execute method take no parameters. While this matters less for a simpledecomposition scenario like this, it\u2019s very handy when I want to manipulate thecommand with a more complicated parameter setting lifecycle or customizations.Different command classes can have different parameters but be mixed together whenqueued for execution.I can do these parameters one at a time.function score(candidate, medicalExam, scoringGuide) {  return new Scorer(candidate).execute(candidate, medicalExam, scoringGuide);}class Scorer...constructor(candidate){  this._candidate = candidate;}execute (candidate, medicalExam, scoringGuide) {  let result = 0;  let healthLevel = 0;  let highMedicalRiskFlag = false;  if (medicalExam.isSmoker) {    healthLevel += 10;    highMedicalRiskFlag = true;  }  let certificationGrade = \"regular\";  if (scoringGuide.stateWithLowCertification(this._candidate.originState)) {    certificationGrade = \"low\";    result \u00ad= 5;  }  // lots more code like this  result \u00ad= Math.max(healthLevel \u00ad 5, 0);  return result;}I continue with the other parametersfunction score(candidate, medicalExam, scoringGuide) {  return new Scorer(candidate, medicalExam, scoringGuide).execute();}class Scorer...constructor(candidate, medicalExam, scoringGuide){  this._candidate = candidate;  this._medicalExam = medicalExam;  this._scoringGuide = scoringGuide;}execute () {  let result = 0;  let healthLevel = 0;  let highMedicalRiskFlag = false;  if (this._medicalExam.isSmoker) {    healthLevel += 10;    highMedicalRiskFlag = true;  }  let certificationGrade = \"regular\";  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState))    certificationGrade = \"low\";    result \u00ad= 5;  }  // lots more code like this  result \u00ad= Math.max(healthLevel \u00ad 5, 0);  return result;}That completes Replace Function with Command, but the whole point of doing thisrefactoring is to allow me to break down the complicated functions\u2014so let me outlinesome steps to achieve that. My next move here is to change all the local variables intofields. Again, I do these one at a time.class Scorer...constructor(candidate, medicalExam, scoringGuide){  this._candidate = candidate;  this._medicalExam = medicalExam;  this._scoringGuide = scoringGuide;}execute () {  this._result = 0;  let healthLevel = 0;  let highMedicalRiskFlag = false;  if (this._medicalExam.isSmoker) {    healthLevel += 10;    highMedicalRiskFlag = true;  }  let certificationGrade = \"regular\";  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState))    certificationGrade = \"low\";    this._result \u00ad= 5;  }  // lots more code like this  this._result \u00ad= Math.max(healthLevel \u00ad 5, 0);  return this._result;}I repeat this for all the local variables. (This is one of those refactorings that I felt wassufficiently simple that I haven\u2019t given it an entry in the catalog. I feel slightly guiltyabout this.)class Scorer...constructor(candidate, medicalExam, scoringGuide){  this._candidate = candidate;  this._medicalExam = medicalExam;  this._scoringGuide = scoringGuide;}execute () {  this._result = 0;  this._healthLevel = 0;  this._highMedicalRiskFlag = false;  if (this._medicalExam.isSmoker) {    this._healthLevel += 10;    this._highMedicalRiskFlag = true;  }  this._certificationGrade = \"regular\";  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState))    this._certificationGrade = \"low\";    this._result \u00ad= 5;  }  // lots more code like this  this._result \u00ad= Math.max(this._healthLevel \u00ad 5, 0);  return this._result;}Now I\u2019ve moved all the function\u2019s state to the command object, I can use refactoringslike Extract Function (106) without getting tangled up in all the variables and theirscopes.class Scorer...execute () {  this._result = 0;  this._healthLevel = 0;  this._highMedicalRiskFlag = false;  this.scoreSmoking();  this._certificationGrade = \"regular\";  if (this._scoringGuide.stateWithLowCertification(this._candidate.originState))    this._certificationGrade = \"low\";    this._result \u00ad= 5;  }  // lots more code like this  this._result \u00ad= Math.max(this._healthLevel \u00ad 5, 0);  return this._result;  }scoreSmoking() {  if (this._medicalExam.isSmoker) {    this._healthLevel += 10;    this._highMedicalRiskFlag = true;  }}This allows me to treat the command similarly to how I\u2019d deal with a nested function.Indeed, when doing this refactoring in JavaScript, using nested functions would be areasonable alternative to using a command. I\u2019d still use a command for this, partlybecause I\u2019m more familiar with commands and partly because with a command I canwrite tests and debugging calls against the subfunctions."
    },
    "REPLACE COMMAND WITH FUNCTION": {
        "Mechanics": "Apply Extract Function (106) to the creation of the command and the call to thecommand\u2019s execution method.This creates the new function that will replace the command in due course.For each method called by the command\u2019s execution method, apply Inline Function(115).If the supporting function returns a value, use Extract Variable (119) on the callfirst and then Inline Function (115).Use Change Function Declaration (124) to put all the parameters of the constructorinto the command\u2019s execution method instead.For each field, alter the references in the command\u2019s execution method to use theparameter instead. Test after each change.Inline the constructor call and command\u2019s execution method call into the caller(which is the replacement function).Test.Apply Remove Dead Code (237) to the command class.",
        "Example": "I\u2019ll begin with this small command object:class ChargeCalculator {  constructor (customer, usage, provider){    this._customer = customer;    this._usage = usage;    this._provider = provider;  }  get baseCharge() {    return this._customer.baseRate * this._usage;  }  get charge() {    return this.baseCharge + this._provider.connectionCharge;  }}It is used by code like this:caller...monthCharge = new ChargeCalculator(customer, usage, provider).charge;The command class is small and simple enough to be better off as a function.I begin by using Extract Function (106) to wrap the class creation and invocation.caller...monthCharge = charge(customer, usage, provider);top level...function charge(customer, usage, provider) {  return new ChargeCalculator(customer, usage, provider).charge;}I have to decide how to deal with any supporting functions, in this case baseCharge.My usual approach for a function that returns a value is to first Extract Variable (119)on that value.class ChargeCalculator...get baseCharge() {  return this._customer.baseRate * this._usage;}get charge() {  const baseCharge = this.baseCharge;  return baseCharge + this._provider.connectionCharge;}Then, I use Inline Function (115) on the supporting function.class ChargeCalculator...get charge() {  const baseCharge = this._customer.baseRate * this._usage;  return baseCharge + this._provider.connectionCharge;}I now have all the processing in a single function, so my next step is to move the datapassed to the constructor to the main method. I first use Change Function Declaration(124) to add all the constructor parameters to the charge method.class ChargeCalculator...constructor (customer, usage, provider){  this._customer = customer;  this._usage = usage;  this._provider = provider;}charge(customer, usage, provider) {  const baseCharge = this._customer.baseRate * this._usage;  return baseCharge + this._provider.connectionCharge;}top level...function charge(customer, usage, provider) {  return new ChargeCalculator(customer, usage, provider)                      .charge(customer, usage, provider);}Now I can alter the body of charge to use the passed parameters instead. I can do thisone at a time.class ChargeCalculator...constructor (customer, usage, provider){  this._customer = customer;  this._usage = usage;  this._provider = provider;}charge(customer, usage, provider) {  const baseCharge = customer.baseRate * this._usage;  return baseCharge + this._provider.connectionCharge;}I don\u2019t have to remove the assignment to this._customer in the constructor, as itwill just be ignored. But I prefer to do it since that will make a test fail if I misschanging a use of field to the parameter. (And if a test doesn\u2019t fail, I should consideradding a new test.)I repeat this for the other parameters, ending up withclass ChargeCalculator...charge(customer, usage, provider) {  const baseCharge = customer.baseRate * usage;  return baseCharge + provider.connectionCharge;}Once I\u2019ve done all of these, I can inline into the top\u00adlevel charge function. This is aspecial kind of Inline Function (115), as it\u2019s inlining both the constructor and methodcall together.top level...function charge(customer, usage, provider) {  const baseCharge = customer.baseRate * usage;  return baseCharge + provider.connectionCharge;}The command class is now dead code, so I\u2019ll use Remove Dead Code (237) to give it anhonorable burial.In this final chapter, I\u2019ll turn to one of the best known features of object\u00adorientedprogramming: inheritance. Like any powerful mechanism, it is both very useful andeasy to misuse, and it\u2019s often hard to see the misuse until it\u2019s in the rear\u00adview mirror.Often, features need to move up or down the inheritance hierarchy. Several refactoringsdeal with that: Pull Up Method (350), Pull Up Field (353), Pull Up Constructor Body(355), Push Down Method (359), and Push Down Field (361). I can add and removeclasses from the hierarchy with Extract Superclass (375), Remove Subclass (369), andCollapse Hierarchy (380). I may want to add a subclass to replace a field that I\u2019m usingto trigger different behavior based on its value; I do this with Replace Type Code withSubclasses (362).Inheritance is a powerful tool, but sometimes it gets used in the wrong place\u2014or theplace it\u2019s used in becomes wrong. In that case, I use Replace Subclass with Delegate(381) or Replace Superclass with Delegate (399) to turn inheritance into delegation."
    },
    "PULL UP METHOD": {
        "Mechanics": "Inspect methods to ensure they are identical.If they do the same thing, but are not identical, refactor them until they haveidentical bodies.Check that all method calls and field references inside the method body refer tofeatures that can be called from the superclass.If the methods have different signatures, use Change Function Declaration (124) toget them to the one you want to use on the superclass.Create a new method in the superclass. Copy the body of one of the methods over toit.Run static checks.Delete one subclass method.Test.Keep deleting subclass methods until they are all gone.",
        "Example": "I have two subclass methods that do the same thing.class Employee extends Party...get annualCost() {  return this.monthlyCost * 12;}class Department extends Party...get totalAnnualCost() {  return this.monthlyCost * 12;}I look at both classes and see that they refer to the monthlyCost property which isn\u2019tdefined on the superclass, but is present in both subclasses. Since I\u2019m in a dynamiclanguage, I\u2019m OK; if I were in a static language, I\u2019d need to define an abstract methodon Party.The methods have different names, so I Change Function Declaration (124) to makethem the same.class Department...get annualCost() {  return this.monthlyCost * 12;}I copy the method from one subclass and paste it into the superclass.class Party...get annualCost() {  return this.monthlyCost * 12;}In a static language, I\u2019d compile to ensure that all the references were OK. That won\u2019thelp me here, so I first remove annualCost from Employee, test, and then remove itfrom Department.That completes the refactoring, but does leave a question. annualCost callsmonthlyCost, but monthlyCost doesn\u2019t appear in the Party class. It all works,because JavaScript is a dynamic language\u2014but there is value in signaling thatsubclasses of Party should provide an implementation for monthlyCost, particularlyif more subclasses get added later on. A good way to provide this signal is a trap methodlike this:class Party...get monthlyCost() {  throw new SubclassResponsibilityError();}I call such an error a subclass responsibility error as that was the name used inSmalltalk."
    },
    "PULL UP FIELD": {
        "Mechanics": "Inspect all users of the candidate field to ensure they are used in the same way.If the fields have different names, use Rename Field (244) to give them the samename.Create a new field in the superclass.The new field will need to be accessible to subclasses (protected in commonlanguages).Delete the subclass fields.Test."
    },
    "PULL UP CONSTRUCTOR BODY": {
        "Mechanics": "Define a superclass constructor, if one doesn\u2019t already exist. Ensure it\u2019s called bysubclass constructors.Use Slide Statements (223) to move any common statements to just after the supercall.Remove the common code from each subclass and put it in the superclass. Add tothe super call any constructor parameters referenced in the common code.Test.If there is any common code that cannot move to the start of the constructor, useExtract Function (106) followed by Pull Up Method (350).",
        "Example": "I start with the following code:class Party {}class Employee extends Party {  constructor(name, id, monthlyCost) {    super();    this._id = id;    this._name = name;    this._monthlyCost = monthlyCost;  }  // rest of class...class Department extends Party {  constructor(name, staff){    super();    this._name = name;    this._staff = staff;  }  // rest of class...The common code here is the assignment of the name. I use Slide Statements (223) tomove the assignment in Employee next to the call to super():class Employee extends Party {  constructor(name, id, monthlyCost) {    super();    this._name = name;    this._id = id;    this._monthlyCost = monthlyCost;  }  // rest of class...With that tested, I move the common code to the superclass. Since that code contains areference to a constructor argument, I pass that in as a parameter.class Party...constructor(name){  this._name = name;}class Employee...constructor(name, id, monthlyCost) {  super(name);  this._id = id;  this._monthlyCost = monthlyCost;}class Department...constructor(name, staff){  super(name);  this._staff = staff;}Run the tests, and I\u2019m done.Most of the time, constructor behavior will work like this: Do the common elementsfirst (with a super call), then do extra work that the subclass needs. Occasionally,however, there is some common behavior later.Consider this example:class Employee...constructor (name) {...}get isPrivileged() {...}assignCar() {...}class Manager extends Employee...constructor(name, grade) {  super(name);  this._grade = grade;  if (this.isPrivileged) this.assignCar(); // every subclass does this}get isPrivileged() {  return this._grade > 4;}The wrinkle here comes from the fact that the call to isPrivileged can\u2019t be madeuntil after the grade field is assigned, and that can only be done in the subclass.In this case, I do Extract Function (106) on the common code:class Manager...constructor(name, grade) {  super(name);  this._grade = grade;  this.finishConstruction();}finishConstruction() {  if (this.isPrivileged) this.assignCar();}Then, I use Pull Up Method (350) to move it to the superclass.class Employee...finishConstruction() {  if (this.isPrivileged) this.assignCar();}"
    },
    "PUSH DOWN METHOD": {
        "Mechanics": "Copy the method into every subclass that needs it.Remove the method from the superclass.Test.Remove the method from each superclass that doesn\u2019t need it.Test."
    },
    "PUSH DOWN FIELD": {
        "Mechanics": "Declare field in all subclasses that need it.Remove the field from the superclass.Test.Remove the field from all subclasses that don\u2019t need it.Test."
    },
    "REPLACE TYPE CODE WITH SUBCLASSES": {
        "Mechanics": "Self\u00adencapsulate the type code field.Pick one type code value. Create a subclass for that type code. Override the typecode getter to return the literal type code value.Create selector logic to map from the type code parameter to the new subclass.With direct inheritance, use Replace Constructor with Factory Function (334) andput the selector logic in the factory. With indirect inheritance, the selector logic maystay in the constructor.Test.Repeat creating the subclass and adding to the selector logic for each type codevalue. Test after each change.Remove the type code field.Test.Use Push Down Method (359) and Replace Conditional with Polymorphism (272)on any methods that use the type code accessors. Once all are replaced, you canremove the type code accessors.",
        "Example": "I\u2019ll start with this overused employee example:class Employee...constructor(name, type){  this.validateType(type);  this._name = name;  this._type = type;}validateType(arg) {  if (![\"engineer\", \"manager\", \"salesman\"].includes(arg))    throw new Error(`Employee cannot be of type ${arg}`);}toString() {return `${this._name} (${this._type})`;}My first step is to use Encapsulate Variable (132) to self\u00adencapsulate the type code.class Employee...get type() {return this._type;}toString() {return `${this._name} (${this.type})`;}Note that toString uses the new getter by removing the underscore.I pick one type code, the engineer, to start with. I use direct inheritance, subclassing theemployee class itself. The employee subclass is simple\u2014just overriding the type codegetter with the appropriate literal value.class Engineer extends Employee {  get type() {return \"engineer\";}}Although JavaScript constructors can return other objects, things will get messy if I tryto put selector logic in there, since that logic gets intertwined with field initialization. SoI use Replace Constructor with Factory Function (334) to create a new space for it.function createEmployee(name, type) {  return new Employee(name, type);}To use the new subclass, I add selector logic into the factory.function createEmployee(name, type) {  switch (type) {    case \"engineer\": return new Engineer(name, type);  }  return new Employee(name, type);}I test to ensure that worked out correctly. But, because I\u2019m paranoid, I then alter thereturn value of the engineer\u2019s override and test again to ensure the test fails. That way Iknow the subclass is being used. I correct the return value and continue with the othercases. I can do them one at a time, testing after each change.class Salesman extends Employee {  get type() {return \"salesman\";}}class Manager extends Employee {  get type() {return \"manager\";}}function createEmployee(name, type) {  switch (type) {    case \"engineer\": return new Engineer(name, type);    case \"salesman\": return new Salesman(name, type);    case \"manager\":  return new Manager (name, type);  }  return new Employee(name, type);}Once I\u2019m done with them all, I can remove the type code field and the superclassgetting method (the ones in the subclasses remain).class Employee...constructor(name, type){  this.validateType(type);  this._name = name;  this._type = type;}get type() {return this._type;}toString() {return `${this._name} (${this.type})`;}After testing to ensure all is still well, I can remove the validation logic, since the switchis effectively doing the same thing.class Employee...constructor(name, type){  this.validateType(type);  this._name = name;}function createEmployee(name, type) {  switch (type) {    case \"engineer\": return new Engineer(name, type);    case \"salesman\": return new Salesman(name, type);    case \"manager\":  return new Manager (name, type);    default: throw new Error(`Employee cannot be of type ${type}`);  }  return new Employee(name, type);}The type argument to the constructor is now useless, so it falls victim to ChangeFunction Declaration (124).class Employee...constructor(name, type){  this._name = name;}function createEmployee(name, type) {  switch (type) {    case \"engineer\": return new Engineer(name, type);    case \"salesman\": return new Salesman(name, type);    case \"manager\":  return new Manager (name, type);    default: throw new Error(`Employee cannot be of type ${type}`);  }}I still have the type code accessors on the subclasses\u2014get type. I\u2019ll usually want toremove these too, but that may take a bit of time due to other methods that depend onthem. I\u2019ll use Replace Conditional with Polymorphism (272) and Push Down Method(359) to deal with these. At some point, I\u2019ll have no code that uses the type getters, so Iwill subject them to the tender mercies of Remove Dead Code (237).",
        "Example: Using Indirect Inheritance": "Let\u2019s go back to the starting case\u2014but this time, I already have existing subclasses forpart\u00adtime and full\u00adtime employees, so I can\u2019t subclass from Employee for the typecodes. Another reason to not use direct inheritance is keeping the ability to change thetype of employee.class Employee...constructor(name, type){  this.validateType(type);  this._name = name;  this._type = type;}validateType(arg) {  if (![\"engineer\", \"manager\", \"salesman\"].includes(arg))    throw new Error(`Employee cannot be of type ${arg}`);}get type()    {return this._type;}set type(arg) {this._type = arg;}get capitalizedType() {  return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase()}toString() {  return `${this._name} (${this.capitalizedType})`;}This time toString is a bit more complicated, to allow me to illustrate somethingshortly.My first step is to use Replace Primitive with Object (174) on the type code.class EmployeeType {  constructor(aString) {    this._value = aString;  }  toString() {return this._value;}}class Employee...constructor(name, type){  this.validateType(type);  this._name = name;  this.type = type;}validateType(arg) {  if (![\"engineer\", \"manager\", \"salesman\"].includes(arg))    throw new Error(`Employee cannot be of type ${arg}`);}get typeString()    {return this._type.toString();}get type()    {return this._type;}set type(arg) {this._type = new EmployeeType(arg);}get capitalizedType() {  return this.typeString.charAt(0).toUpperCase()    + this.typeString.substr(1).toLowerCase();}toString() {  return `${this._name} (${this.capitalizedType})`;}I then apply the usual mechanics of Replace Type Code with Subclasses to the employeetype.class Employee...set type(arg) {this._type = Employee.createEmployeeType(arg);}  static createEmployeeType(aString) {    switch(aString) {      case \"engineer\": return new Engineer();      case \"manager\": return new Manager ();      case \"salesman\": return new Salesman();      default: throw new Error(`Employee cannot be of type ${aString}`);    }  }class EmployeeType {}class Engineer extends EmployeeType {  toString() {return \"engineer\";}}class Manager extends EmployeeType {  toString() {return \"manager\";}}class Salesman extends EmployeeType {  toString() {return \"salesman\";}}If I were leaving it at that, I could remove the empty EmployeeType. But I prefer toleave it there as it makes explicit the relationship between the various subclasses. It\u2019salso a handy spot for moving other behavior there, such as the capitalization logic Itossed into the example specifically to illustrate this point.class Employee...toString() {  return `${this._name} (${this.type.capitalizedName})`;}class EmployeeType...get capitalizedName() {  return this.toString().charAt(0).toUpperCase()    + this.toString().substr(1).toLowerCase();}For those familiar with the first edition of the book, this example essentially supersedesthe Replace Type Code with State/Strategy. I now think of that refactoring as ReplaceType Code with Subclasses using indirect inheritance, so didn\u2019t consider it worth itsown entry in the catalog. (I never liked the name anyway.)"
    },
    "REMOVE SUBCLASS": {
        "Mechanics": "Use Replace Constructor with Factory Function (334) on the subclass constructor.If the clients of the constructors use a data field to decide which subclass to create,put that decision logic into a superclass factory method.If any code tests against the subclass\u2019s types, use Extract Function (106) on the typetest and Move Function (198) to move it to the superclass. Test after each change.Create a field to represent the subclass type.Change the methods that refer to the subclass to use the new type field.Delete the subclass.Test.Often, this refactoring is used on a group of subclasses at once\u2014in which case carry outthe steps to encapsulate them (add factory function, move type tests) first, thenindividually fold them into the superclass.",
        "Example": "I\u2019ll start with this stump of subclasses:class Person...constructor(name) {  this._name = name;}get name()    {return this._name;}get genderCode() {return \"X\";}// snipclass Male extends Person {  get genderCode() {return \"M\";}}class Female extends Person {  get genderCode() {return \"F\";}}If that\u2019s all that a subclass does, it\u2019s not really worth having. But before I remove thesesubclasses, it\u2019s usually worth checking to see if there\u2019s any subclass\u00addependent behaviorin the clients that should be moved in there. In this case, I don\u2019t find anything worthkeeping the subclasses for.client...const numberOfMales = people.filter(p => p instanceof Male).length;Whenever I want to change how I represent something, I try to first encapsulate thecurrent representation to minimize the impact on any client code. When it comes tocreating subclasses, the way to encapsulate is to use Replace Constructor with FactoryFunction (334). In this case, there\u2019s a couple of ways I could make the factory.The most direct way is to create a factory method for each constructor.function createPerson(name) {  return new Person(name);}function createMale(name) {  return new Male(name);}function createFemale(name) {  return new Female(name);}But although that\u2019s the direct choice, objects like this are often loaded from a sourcethat uses the gender codes directly.function loadFromInput(data) {  const result = [];  data.forEach(aRecord => {    let p;    switch (aRecord.gender) {      case 'M': p = new Male(aRecord.name); break;      case 'F': p = new Female(aRecord.name); break;      default: p = new Person(aRecord.name);    }    result.push(p);  });  return result;}In that case, I find it better to use Extract Function (106) on the selection logic forwhich class to create, and make that the factory function.function createPerson(aRecord) {  let p;  switch (aRecord.gender) {    case 'M': p = new Male(aRecord.name); break;    case 'F': p = new Female(aRecord.name); break;    default: p = new Person(aRecord.name);  }  return p;}function loadFromInput(data) {  const result = [];  data.forEach(aRecord => {    result.push(createPerson(aRecord));  });  return result;}While I\u2019m there, I\u2019ll clean up those two functions. I\u2019ll use Inline Variable (123) oncreatePerson:function createPerson(aRecord) {  switch (aRecord.gender) {    case 'M': return new Male  (aRecord.name);    case 'F': return new Female(aRecord.name);    default:  return new Person(aRecord.name);  }}and Replace Loop with Pipeline (231) on loadFromInput:function loadFromInput(data) {  return data.map(aRecord => createPerson(aRecord));}The factory encapsulates the creation of the subclasses, but there is also the use ofinstanceof\u2014which never smells good. I use Extract Function (106) on the typecheck.client...const numberOfMales = people.filter(p => isMale(p)).length;function isMale(aPerson) {return aPerson instanceof Male;}Then I use Move Function (198) to move it into Person.class Person...get isMale() {return this instanceof Male;}client...const numberOfMales = people.filter(p => p.isMale).length;With that refactoring done, all knowledge of the subclasses is now safely encased withinthe superclass and the factory function. (Usually I\u2019m wary of a superclass referring to asubclass, but this code isn\u2019t going to last until my next cup of tea, so I\u2019m not going worryabout it.)I now add a field to represent the difference between the subclasses; since I\u2019m using acode loaded from elsewhere, I might as well just use that.class Person...constructor(name, genderCode) {  this._name = name;  this._genderCode = genderCode || \"X\";}get genderCode() {return this._genderCode;}When initializing it, I set it to the default case. (As a side note, although most peoplecan be classified as male or female, there are people who can\u2019t. It\u2019s a common modelingmistake to forget that.)I then take the male case and fold its logic into the superclass. This involves modifyingthe factory to return a Person and modifying any instanceof tests to use the gendercode field.function createPerson(aRecord) {  switch (aRecord.gender) {    case 'M': return new Person(aRecord.name, \"M\");    case 'F': return new Female(aRecord.name);    default:  return new Person(aRecord.name);  }}class Person...get isMale() {return \"M\" === this._genderCode;}I test, remove the male subclass, test again, and repeat for the female subclass.function createPerson(aRecord) {  switch (aRecord.gender) {    case 'M': return new Person(aRecord.name, \"M\");    case 'F': return new Person(aRecord.name, \"F\");    default:  return new Person(aRecord.name);  }}I find the lack of symmetry with the gender code to be annoying. A future reader of thecode will always wonder about this lack of symmetry. So I prefer to change the code tomake it symmetrical\u2014if I can do it without introducing any other complexity, which isthe case here.function createPerson(aRecord) {  switch (aRecord.gender) {    case 'M': return new Person(aRecord.name, \"M\");    case 'F': return new Person(aRecord.name, \"F\");    default:  return new Person(aRecord.name, \"X\");  }}class Person...constructor(name, genderCode) {  this._name = name;  this._genderCode = genderCode || \"X\";}"
    },
    "EXTRACT SUPERCLASS": {
        "Mechanics": "Create an empty superclass. Make the original classes its subclasses.If needed, use Change Function Declaration (124) on the constructors.Test.One by one, use Pull Up Constructor Body (355), Pull Up Method (350), and PullUp Field (353) to move common elements to the superclass.Examine remaining methods on the subclasses. See if there are common parts. If so,use Extract Function (106) followed by Pull Up Method (350).Check clients of the original classes. Consider adjusting them to use the superclassinterface.",
        "Example": "I\u2019m pondering these two classes, they share some common functionality\u2014their nameand the notions of annual and monthly costs:class Employee {  constructor(name, id, monthlyCost) {    this._id = id;    this._name = name;    this._monthlyCost = monthlyCost;  }  get monthlyCost() {return this._monthlyCost;}  get name() {return this._name;}  get id() {return this._id;}  get annualCost() {    return this.monthlyCost * 12;  }}class Department {  constructor(name, staff){    this._name = name;    this._staff = staff;  }  get staff() {return this._staff.slice();}  get name() {return this._name;}  get totalMonthlyCost() {    return this.staff      .map(e => e.monthlyCost)      .reduce((sum, cost) => sum + cost);  }  get headCount() {    return this.staff.length;  }  get totalAnnualCost() {    return this.totalMonthlyCost * 12;  }}I can make the common behavior more explicit by extracting a common superclassfrom them.I begin by creating an empty superclass and letting them both extend from it.class Party {}class Employee extends Party {  constructor(name, id, monthlyCost) {    super();    this._id = id;    this._name = name;    this._monthlyCost = monthlyCost;  }  // rest of class...class Department extends Party {  constructor(name, staff){    super();    this._name = name;    this._staff = staff;  }  // rest of class...When doing Extract Superclass, I like to start with the data, which in JavaScriptinvolves manipulating the constructor. So I start with Pull Up Field (353) to pull up thename.class Party...constructor(name){  this._name = name;}class Employee...constructor(name, id, monthlyCost) {  super(name);  this._id = id;  this._monthlyCost = monthlyCost;}class Department...constructor(name, staff){  super(name);  this._staff = staff;}As I get data up to the superclass, I can also apply Pull Up Method (350) on associatedmethods. First, the name:class Party...get name() {return this._name;}class Employee...get name() {return this._name;}class Department...get name() {return this._name;}I have two methods with similar bodies.class Employee...get annualCost() {  return this.monthlyCost * 12;}class Department...get totalAnnualCost() {  return this.totalMonthlyCost * 12;}The methods they use, monthlyCost and totalMonthlyCost, have different namesand different bodies\u2014but do they represent the same intent? If so, I should use ChangeFunction Declaration (124) to unify their names.class Department...get totalAnnualCost() {  return this.monthlyCost * 12;}get monthlyCost() { ... }I then do a similar renaming to the annual costs:class Department...get annualCost() {  return this.monthlyCost * 12;}I can now apply Pull Up Method (350) to the annual cost methods.class Party...get annualCost() {  return this.monthlyCost * 12;}class Employee...get annualCost() {  return this.monthlyCost * 12;}class Department...get annualCost() {  return this.monthlyCost * 12;}"
    },
    "COLLAPSE HIERARCHY": {
        "Mechanics": "Choose which one to remove.I choose based on which name makes most sense in the future. If neither name isbest, I\u2019ll pick one arbitrarily.Use Pull Up Field (353), Push Down Field (361), Pull Up Method (350), and PushDown Method (359) to move all the elements into a single class.Adjust any references to the victim to change them to the class that will stay.Remove the empty class.Test."
    },
    "REPLACE SUBCLASS WITH DELEGATE": {
        "Mechanics": "If there are many callers for the constructors, apply Replace Constructor withFactory Function (334).Create an empty class for the delegate. Its constructor should take any subclass\u00adspecific data as well as, usually, a back\u00adreference to the superclass.Add a field to the superclass to hold the delegate.Modify the creation of the subclass so that it initializes the delegate field with aninstance of the delegate.This can be done in the factory function, or in the constructor if the constructor canreliably tell whether to create the correct delegate.Choose a subclass method to move to the delegate class.Use Move Function (198) to move it to the delegate class. Don\u2019t remove the source\u2019sdelegating code.If the method needs elements that should move to the delegate, move them. If itneeds elements that should stay in the superclass, add a field to the delegate thatrefers to the superclass.If the source method has callers outside the class, move the source\u2019s delegating codefrom the subclass to the superclass, guarding it with a check for the presence of thedelegate. If not, apply Remove Dead Code (237).If there\u2019s more than one subclass, and you start duplicating code within them, useExtract Superclass (375). In this case, any delegating methods on the source super\u00adclass no longer need a guard if the default behavior is moved to the delegatesuperclass.Test.Repeat until all the methods of the subclass are moved.Find all callers of the subclasses\u2019s constructor and change them to use thesuperclass constructor.Test.Use Remove Dead Code (237) on the subclass.",
        "Example": "I have a class that makes a booking for a show.class Booking...constructor(show, date) {  this._show = show;  this._date = date;}There is a subclass for premium booking that takes into account various extras that areavailable.class PremiumBooking extends Booking...constructor(show, date, extras) {  super(show, date);  this._extras = extras;}There are quite a few changes that the premium booking makes to what it inherits fromthe superclass. As is typical with this kind of programming\u00adby\u00addifference, in some casesthe subclass overrides methods on the superclass, in others it adds new methods thatare only relevant for the subclass. I won\u2019t go into all of them, but I will pick out a fewinteresting cases.First, there is a simple override. Regular bookings offer a talkback after the show, butonly on nonpeak days.class Booking...get hasTalkback() {  return this._show.hasOwnProperty('talkback') && !this.isPeakDay;}Premium bookings override this to offer talkbacks on all days.class PremiumBooking...get hasTalkback() {  return this._show.hasOwnProperty('talkback');}Determining the price is a similar override, with a twist that the premium method callsthe superclass method.class Booking...get basePrice() {  let result = this._show.price;  if (this.isPeakDay) result += Math.round(result * 0.15);  return result;}class PremiumBooking...get basePrice() {  return Math.round(super.basePrice + this._extras.premiumFee);}The last example is where the premium booking offers a behavior that isn\u2019t present onthe superclass.class PremiumBooking...get hasDinner() {  return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;}Inheritance works well for this example. I can understand the base class without havingto understand the subclass. The subclass is defined just by saying how it differs fromthe base case\u2014both reducing duplication and clearly communicating what are thedifferences it\u2019s introducing.Actually, it isn\u2019t quite as perfect as the previous paragraph implies. There are things inthe superclass structure that only make sense due to the subclass\u2014such as methodsthat have been factored in such a way as to make it easier to override just the rightkinds of behavior. So although most of the time I can modify the base class withouthaving to understand subclasses, there are occasions where such mindful ignorance ofthe subclasses will lead me to breaking a subclass by modifying the superclass.However, if these occasions are not too common, the inheritance pays off\u2014provided Ihave good tests to detect a subclass breakage.So why would I want to change such a happy situation by using Replace Subclass withDelegate? Inheritance is a tool that can only be used once\u2014so if I have another reasonto use inheritance, and I think it will benefit me more than the premium bookingsubclass, I\u2019ll need to handle premium bookings a different way. Also, I may need tochange from the default booking to the premium booking dynamically\u2014i.e., support amethod like aBooking.bePremium(). In some cases, I can avoid this by creating awhole new object (a common example is where an HTTP request loads new data fromthe server). But sometimes, I need to modify a data structure and not rebuild it fromscratch, and it is difficult to just replace a single booking that\u2019s referred to from manydifferent places. In such situations, it can be useful to allow a booking to switch fromdefault to premium and back again.When these needs crop up, I need to apply Replace Subclass with Delegate. I haveclients call the constructors of the two classes to make the bookings:booking clientaBooking = new Booking(show,date);premium clientaBooking = new PremiumBooking(show, date, extras);Removing subclasses will alter all of this, so I like to encapsulate the constructor callswith Replace Constructor with Factory Function (334).top level...function createBooking(show, date) {  return new Booking(show, date);}function createPremiumBooking(show, date, extras) {  return new PremiumBooking (show, date, extras);}booking clientaBooking = createBooking(show, date);premium clientaBooking = createPremiumBooking(show, date, extras);I now make the new delegate class. Its constructor parameters are those parametersthat are only used in the subclass, together with a back\u00adreference to the booking object.I\u2019ll need this because several subclass methods require access to data stored in thesuperclass. Inheritance makes this easy to do, but with a delegate I need a back\u00adreference.class PremiumBookingDelegate...constructor(hostBooking, extras) {  this._host = hostBooking;  this._extras = extras;}I now connect the new delegate to the booking object. I do this by modifying the factoryfunction for premium bookings.top level...function createPremiumBooking(show, date, extras) {  const result = new PremiumBooking (show, date, extras);  result._bePremium(extras);  return result;}class Booking..._bePremium(extras) {  this._premiumDelegate = new PremiumBookingDelegate(this, extras);}I use a leading underscore on _bePremium to indicate that it shouldn\u2019t be part of thepublic interface for Booking. Of course, if the point of doing this refactoring is to allowa booking to mutate to premium, it can be a public method.Alternatively, I can do all the connections in the constructor for Booking. In order todo that, I need some way to signal to the constructor that we have a premium booking.That could be an extra parameter, or just the use of extras if I can be sure that it isalways present when used with a premium booking. Here, I prefer the explicitness ofdoing this through the factory function.With the structures set up, it\u2019s time to start moving the behavior. The first case I\u2019llconsider is the simple override of hasTalkback. Here\u2019s the existing code:class Booking...get hasTalkback() {  return this._show.hasOwnProperty('talkback') && !this.isPeakDay;}class PremiumBooking...get hasTalkback() {  return this._show.hasOwnProperty('talkback');}I use Move Function (198) to move the subclass method to the delegate. To make it fitits home, I route any access to superclass data with a call to _host.class PremiumBookingDelegate...get hasTalkback() {  return this._host._show.hasOwnProperty('talkback');}class PremiumBooking...get hasTalkback() {  return this._premiumDelegate.hasTalkback;}I test to ensure everything is working, then delete the subclass method:class PremiumBooking...get hasTalkback() {  return this._premiumDelegate.hasTalkback;}I run the tests at this point, expecting some to fail.Now I finish the move by adding dispatch logic to the superclass method to use thedelegate if it is present.class Booking...get hasTalkback() {  return (this._premiumDelegate)    ? this._premiumDelegate.hasTalkback    : this._show.hasOwnProperty('talkback') && !this.isPeakDay;}The next case I\u2019ll look at is the base price.class Booking...get basePrice() {  let result = this._show.price;  if (this.isPeakDay) result += Math.round(result * 0.15);  return result;}class PremiumBooking...get basePrice() {  return Math.round(super.basePrice + this._extras.premiumFee);}This is almost the same, but there is a wrinkle in the form of the pesky call on super(which is pretty common in these kinds of subclass extension cases). When I move thesubclass code to the delegate, I\u2019ll need to call the parent case\u2014but I can\u2019t just callthis._host._basePrice without getting into an endless recursion.I have a couple of options here. One is to apply Extract Function (106) on the basecalculation to allow me to separate the dispatch logic from price calculation. (The restof the move is as before.)class Booking...get basePrice() {  return (this._premiumDelegate)    ? this._premiumDelegate.basePrice    : this._privateBasePrice;}get _privateBasePrice() {  let result = this._show.price;  if (this.isPeakDay) result += Math.round(result * 0.15);  return result;}class PremiumBookingDelegate...get basePrice() {  return Math.round(this._host._privateBasePrice + this._extras.premiumFee);}Alternatively, I can recast the delegate\u2019s method as an extension of the base method.class Booking...get basePrice() {  let result = this._show.price;  if (this.isPeakDay) result += Math.round(result * 0.15);  return (this._premiumDelegate)    ? this._premiumDelegate.extendBasePrice(result)    : result;}class PremiumBookingDelegate...extendBasePrice(base) {  return Math.round(base + this._extras.premiumFee);}Both work reasonably here; I have a slight preference for the latter as it\u2019s a bit smaller.The last case is a method that only exists on the subclass.class PremiumBooking...get hasDinner() {  return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;}I move it from the subclass to the delegate:class PremiumBookingDelegate...get hasDinner() {  return this._extras.hasOwnProperty('dinner') && !this._host.isPeakDay;}I then add dispatch logic to Booking:class Booking...get hasDinner() {  return (this._premiumDelegate)    ? this._premiumDelegate.hasDinner    : undefined;}In JavaScript, accessing a property on an object where it isn\u2019t defined returnsundefined, so I do that here. (Although my every instinct is to have it raise an error,which would be the case in other object\u00adoriented dynamic languages I\u2019m used to.)Once I\u2019ve moved all the behavior out of the subclass, I can change the factory method toreturn the superclass\u2014and, once I\u2019ve run tests to ensure all is well, delete the subclass.top level...function createPremiumBooking(show, date, extras) {  const result = new PremiumBooking (show, date, extras);  result._bePremium(extras);  return result;}class PremiumBooking extends Booking ...This is one of those refactorings where I don\u2019t feel that refactoring alone improves thecode. Inheritance handles this situation very well, whereas using delegation involvesadding dispatch logic, two\u00adway references, and thus extra complexity. The refactoringmay still be worthwhile, since the advantage of a mutable premium status, or a need touse inheritance for other purposes, may outweigh the disadvantage of losinginheritance.",
        "Example: Replacing a Hierarchy": "The previous example showed using Replace Subclass with Delegate on a singlesubclass, but I can do the same thing with an entire hierarchy.function createBird(data) {  switch (data.type) {    case 'EuropeanSwallow':      return new EuropeanSwallow(data);    case 'AfricanSwallow':      return new AfricanSwallow(data);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrot(data);    default:      return new Bird(data);  }}class Bird {  constructor(data) {    this._name = data.name;    this._plumage = data.plumage;  }  get name()    {return this._name;}  get plumage() {    return this._plumage || \"average\";  }  get airSpeedVelocity() {return null;}}class EuropeanSwallow extends Bird {  get airSpeedVelocity() {return 35;}}class AfricanSwallow extends Bird {  constructor(data) {    super (data);    this._numberOfCoconuts = data.numberOfCoconuts;  }  get airSpeedVelocity() {    return 40 \u00ad 2 * this._numberOfCoconuts;  }}class NorwegianBlueParrot extends Bird {  constructor(data) {    super (data);    this._voltage = data.voltage;    this._isNailed = data.isNailed;  }  get plumage() {    if (this._voltage > 100) return \"scorched\";    else return this._plumage || \"beautiful\";  }  get airSpeedVelocity() {    return (this._isNailed) ? 0 : 10 + this._voltage / 10;  }}The system will shortly be making a big difference between birds tagged in the wild andthose tagged in captivity. That difference could be modeled as two subclasses for Bird:WildBird and CaptiveBird. However, I can only use inheritance once, so if I wantto use subclasses for wild versus captive, I\u2019ll have to remove them for the species.When several subclasses are involved, I\u2019ll tackle them one at a time, starting with asimple one\u2014in this case, EuropeanSwallow. I create an empty delegate class for thedelegate.class EuropeanSwallowDelegate {}I don\u2019t put in any data or back\u00adreference parameters yet. For this example, I\u2019ll introducethem as I need them.I need to decide where to handle the initialization of the delegate field. Here, since Ihave all the information in the single data argument to the constructor, I decide to do itin the constructor. Since there are several delegates I could add, I make a function toselect the correct one based on the type code in the document.class Bird...constructor(data) {  this._name = data.name;  this._plumage = data.plumage;  this._speciesDelegate = this.selectSpeciesDelegate(data);}  selectSpeciesDelegate(data) {    switch(data.type) {      case 'EuropeanSwallow':        return new EuropeanSwallowDelegate();      default: return null;    }  }Now I have the structure set up, I can apply Move Function (198) to the Europeanswallow\u2019s air speed velocity.class EuropeanSwallowDelegate...get airSpeedVelocity() {return 35;}class EuropeanSwallow...get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}I change airSpeedVelocity on the superclass to call a delegate, if present.class Bird...get airSpeedVelocity() {  return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;}I remove the subclass.class EuropeanSwallow extends Bird {  get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}}top level...function createBird(data) {  switch (data.type) {    case 'EuropeanSwallow':      return new EuropeanSwallow(data);    case 'AfricanSwallow':      return new AfricanSwallow(data);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrot(data);    default:      return new Bird(data);  }}Next I\u2019ll tackle the African swallow. I create a class; this time, the constructor needs thedata document.class AfricanSwallowDelegate...constructor(data) {  this._numberOfCoconuts = data.numberOfCoconuts;}class Bird...selectSpeciesDelegate(data) {  switch(data.type) {    case 'EuropeanSwallow':      return new EuropeanSwallowDelegate();    case 'AfricanSwallow':      return new AfricanSwallowDelegate(data);    default: return null;  }}I use Move Function (198) on airSpeedVelocity.class AfricanSwallowDelegate...get airSpeedVelocity() {  return 40 \u00ad 2 * this._numberOfCoconuts;}class AfricanSwallow...get airSpeedVelocity() {  return this._speciesDelegate.airSpeedVelocity;}I can now remove the African swallow subclass.class AfricanSwallow extends Bird {  // all of the body ...  }function createBird(data) {  switch (data.type) {    case 'AfricanSwallow':      return new AfricanSwallow(data);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrot(data);    default:      return new Bird(data);  }}Now for the Norwegian blue. Creating the class and moving the air speed velocity usesthe same steps as before, so I\u2019ll just show the result.class Bird...selectSpeciesDelegate(data) {  switch(data.type) {    case 'EuropeanSwallow':      return new EuropeanSwallowDelegate();    case 'AfricanSwallow':      return new AfricanSwallowDelegate(data);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrotDelegate(data);    default: return null;  }}class NorwegianBlueParrotDelegate...constructor(data) {  this._voltage = data.voltage;  this._isNailed = data.isNailed;}get airSpeedVelocity() {  return (this._isNailed) ? 0 : 10 + this._voltage / 10;}All well and good, but the Norwegian blue overrides the plumage property, which Ididn\u2019t have to deal with for the other cases. The initial Move Function (198) is simpleenough, albeit with the need to modify the constructor to put in a back\u00adreference to thebird.class NorwegianBlueParrot...get plumage() {  return this._speciesDelegate.plumage;}class NorwegianBlueParrotDelegate...get plumage() {  if (this._voltage > 100) return \"scorched\";  else return this._bird._plumage || \"beautiful\";}constructor(data, bird) {  this._bird = bird;  this._voltage = data.voltage;  this._isNailed = data.isNailed;}class Bird...selectSpeciesDelegate(data) {  switch(data.type) {    case 'EuropeanSwallow':      return new EuropeanSwallowDelegate();    case 'AfricanSwallow':      return new AfricanSwallowDelegate(data);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrotDelegate(data, this);    default: return null;  }}The tricky step is how to remove the subclass method for plumage. If I doclass Bird...get plumage() {  if (this._speciesDelegate)    return this._speciesDelegate.plumage;  else    return this._plumage || \"average\";}then I\u2019ll get a bunch of errors because there is no plumage property on the otherspecies\u2019 delegate classes.I could use a more precise conditional:class Bird...get plumage() {  if (this._speciesDelegate instanceof NorwegianBlueParrotDelegate)    return this._speciesDelegate.plumage;  else    return this._plumage || \"average\";}But I hope that smells as much of decomposing parrot to you as it does to me. It\u2019salmost never a good idea to use an explicit class check like this.Another option is to implement the default case on the other delegates.class Bird...get plumage() {  if (this._speciesDelegate)    return this._speciesDelegate.plumage;  else    return this._plumage || \"average\";}class EuropeanSwallowDelegate...get plumage() {  return this._bird._plumage || \"average\";}class AfricanSwallowDelegate...get plumage() {  return this._bird._plumage || \"average\";}But this duplicates the default method for plumage. And if that\u2019s not bad enough, I alsoget some bonus duplication in the constructors to assign the back\u00adreference.The solution to the duplication is, naturally, inheritance\u2014I apply Extract Superclass(375) to the species delegates:class SpeciesDelegate {  constructor(data, bird) {    this._bird = bird;  }  get plumage() {    return this._bird._plumage || \"average\";  }class EuropeanSwallowDelegate extends SpeciesDelegate {class AfricanSwallowDelegate extends SpeciesDelegate {  constructor(data, bird) {    super(data,bird);    this._numberOfCoconuts = data.numberOfCoconuts;  }class NorwegianBlueParrotDelegate extends SpeciesDelegate {  constructor(data, bird) {    super(data, bird);    this._voltage = data.voltage;    this._isNailed = data.isNailed;  }Indeed, now I have a superclass, I can move any default behavior from Bird toSpeciesDelegate by ensuring there\u2019s always something in the speciesDelegatefield.class Bird...selectSpeciesDelegate(data) {  switch(data.type) {    case 'EuropeanSwallow':      return new EuropeanSwallowDelegate(data, this);    case 'AfricanSwallow':      return new AfricanSwallowDelegate(data, this);    case 'NorweigianBlueParrot':      return new NorwegianBlueParrotDelegate(data, this);    default: return new SpeciesDelegate(data, this);  }}// rest of bird's code...get plumage() {return this._speciesDelegate.plumage;}get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}class SpeciesDelegate...get airSpeedVelocity() {return null;}I like this, as it simplifies the delegating methods on Bird. I can easily see whichbehavior is delegated to the species delegate and which stays behind.Here\u2019s the final state of these classes:function createBird(data) {  return new Bird(data);}class Bird {  constructor(data) {    this._name = data.name;    this._plumage = data.plumage;    this._speciesDelegate = this.selectSpeciesDelegate(data);  }  get name()    {return this._name;}  get plumage() {return this._speciesDelegate.plumage;}  get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity;}  selectSpeciesDelegate(data) {    switch(data.type) {      case 'EuropeanSwallow':        return new EuropeanSwallowDelegate(data, this);      case 'AfricanSwallow':        return new AfricanSwallowDelegate(data, this);      case 'NorweigianBlueParrot':        return new NorwegianBlueParrotDelegate(data, this);      default: return new SpeciesDelegate(data, this);    }  }  // rest of bird's code...}class SpeciesDelegate {  constructor(data, bird) {    this._bird = bird;  }  get plumage() {    return this._bird._plumage || \"average\";  }  get airSpeedVelocity() {return null;}}class EuropeanSwallowDelegate extends SpeciesDelegate {  get airSpeedVelocity() {return 35;}}class AfricanSwallowDelegate extends SpeciesDelegate {  constructor(data, bird) {    super(data,bird);    this._numberOfCoconuts = data.numberOfCoconuts;  }  get airSpeedVelocity() {    return 40 \u00ad 2 * this._numberOfCoconuts;  }}class NorwegianBlueParrotDelegate extends SpeciesDelegate {  constructor(data, bird) {    super(data, bird);    this._voltage = data.voltage;    this._isNailed = data.isNailed;  }  get airSpeedVelocity() {    return (this._isNailed) ? 0 : 10 + this._voltage / 10;  }  get plumage() {    if (this._voltage > 100) return \"scorched\";    else return this._bird._plumage || \"beautiful\";  }}This example replaces the original subclasses with a delegate, but there is still a verysimilar inheritance structure in SpeciesDelegate. Have I gained anything from thisrefactoring, other than freeing up inheritance on Bird? The species inheritance is nowmore tightly scoped, covering just the data and functions that vary due to the species.Any code that\u2019s the same for all species remains on Bird and its future subclasses.I could apply the same idea of creating a superclass delegate to the booking exampleearlier. This would allow me to replace those methods on Booking that have dispatchlogic with simple calls to the delegate and letting its inheritance sort out the dispatch.However, it\u2019s nearly dinner time, so I\u2019ll leave that as an exercise for the reader.These examples illustrate that the phrase \u201cFavor object composition over classinheritance\u201d might better be said as \u201cFavor a judicious mixture of composition andinheritance over either alone\u201d\u2014but I fear that is not as catchy."
    },
    "REPLACE SUPERCLASS WITH DELEGATE": {
        "Mechanics": "Create a field in the subclass that refers to the superclass object. Initialize thisdelegate reference to a new instance.For each element of the superclass, create a forwarding function in the subclass thatforwards to the delegate reference. Test after forwarding each consistent group.Most of the time you can test after each function that\u2019s forwarded, but, for example,get/set pairs can only be tested once both have been moved.When all superclass elements have been overridden with forwarders, remove theinheritance link."
    }
}