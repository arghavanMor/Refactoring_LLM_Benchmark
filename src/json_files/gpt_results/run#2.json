{
    "L10937": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "\n\tpublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "AfterRefact": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tRuleFunction rf = getCurrentRuleFunction();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tdefineImplicitLabel(setAST, matchOp);\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\t\tmatchOp.labels.add(d);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "ZeroShotCode": "```java\npublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = createMatchSet(invert, setAST);\n    \n    if (labelAST != null) {\n        Decl d = processLabelAST(labelAST, setAST);\n        matchOp.labels.add(d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(labelAST.getText());\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}\n\nprivate MatchSet createMatchSet(boolean invert, GrammarAST setAST) {\n    return invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n}\n\nprivate Decl processLabelAST(GrammarAST labelAST, GrammarAST setAST) {\n    String label = labelAST.getText();\n    Decl d = getTokenLabelDecl(label);\n    getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n    return d;\n}\n```",
        "InstrucCode": "```java\npublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    boolean needsImplicitLabel = controller.needsImplicitLabel(setAST, matchOp);\n    if (needsImplicitLabel) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}\n```",
        "FewShotCode": "```java\npublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}\n```",
        "ContextCode": "```java\npublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl tokenLabelDecl = getTokenLabelDecl(label);\n        matchOp.labels.add(tokenLabelDecl);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), tokenLabelDecl);\n\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl tokenListLabelDecl = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), tokenListLabelDecl);\n        }\n    }\n\n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}\n```",
        "RulesCode": "```java\npublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp;\n    if (invert) {\n        matchOp = new MatchNotSet(this, setAST);\n    } else {\n        matchOp = new MatchSet(this, setAST);\n    }\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}\n```"
    },
    "L5343": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public List<ParseTreeListener> getParseListeners() {\n        return _parseListeners;\n    }",
        "AfterRefact": "public List<ParseTreeListener> getParseListeners() {\n\t\tList<ParseTreeListener> listeners = _parseListeners;\n\t\tif (listeners == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn listeners;\n\t}",
        "ZeroShotCode": "```java\nprivate List<ParseTreeListener> parseListeners;\n\npublic List<ParseTreeListener> getParseListeners() {\n    return parseListeners;\n}\n```",
        "InstrucCode": "```java\npublic List<ParseTreeListener> getParseListeners() {\n    final List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}\n```",
        "FewShotCode": "```java\npublic List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> listeners = _parseListeners;\n    return listeners;\n}\n```",
        "ContextCode": "```java\npublic List<ParseTreeListener> getParseListeners() {\n    return new ArrayList<>(_parseListeners);\n}\n```",
        "RulesCode": "```java\npublic List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}\n```"
    },
    "L3671": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": " public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t@NotNull BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportAmbiguity d=\" + dfa.decision +\n\t\t\t\": ambigAlts=\" + ambigAlts + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }",
        "AfterRefact": "public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa,\n\t\t\t\t\t\t\t\tint startIndex,\n\t\t\t\t\t\t\t\tint stopIndex,\n\t\t\t\t\t\t\t\tboolean exact,\n\t\t\t\t\t\t\t\t@Nullable BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n\t{\n\t\tif (exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\n\t\tString format = \"reportAmbiguity d=%s: ambigAlts=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tBitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, conflictingAlts, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": "```java\npublic void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs) {\n    String decisionMessage = \"reportAmbiguity d=\" + dfa.decision +\n                              \": ambigAlts=\" + ambigAlts + \n                              \", input='\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\";\n    recognizer.notifyErrorListeners(decisionMessage);\n}\n```",
        "InstrucCode": "```java\npublic void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = \"reportAmbiguity d=\" + dfa.decision +\n                     \": ambigAlts=\" + ambigAlts + \", input='\" + inputText + \"'\";\n    recognizer.notifyErrorListeners(message);\n}\n```",
        "FewShotCode": "```java\npublic void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs) {\n    String decision = String.valueOf(dfa.decision);\n    String ambiguousAlternatives = ambigAlts.toString();\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = \"reportAmbiguity d=\" + decision + \": ambigAlts=\" + ambiguousAlternatives + \", input='\" + inputText + \"'\";\n    recognizer.notifyErrorListeners(message);\n}\n```",
        "ContextCode": "```java\npublic void reportAmbiguity(@NotNull Parser recognizer, DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts, @NotNull ATNConfigSet configs) {\n    String errorMessage = String.format(\"reportAmbiguity d=%d: ambigAlts=%s, input='%s'\",\n                                         dfa.decision, ambigAlts, \n                                         recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)));\n    recognizer.notifyErrorListeners(errorMessage);\n}\n```",
        "RulesCode": "```java\npublic void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String message = \"reportAmbiguity d=\" + dfa.decision +\n                     \": ambigAlts=\" + ambigAlts + \", input='\" +\n                     recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\";\n    recognizer.notifyErrorListeners(message);\n}\n```"
    },
    "L3692": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n                                         int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n\t\t\tdfa.decision + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }\n}",
        "AfterRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n\t{\n\t\tString format = \"reportContextSensitivity d=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": "```java\npublic void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = String.format(\"reportContextSensitivity d=%d, input='%s'\", dfa.decision, inputText);\n    recognizer.notifyErrorListeners(message);\n}\n```",
        "InstrucCode": "```java\npublic void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n            dfa.decision + \", input='\" + inputText + \"'\");\n}\n```",
        "FewShotCode": "```java\npublic void reportContextSensitivity(@NotNull Parser recognizer,\n                                     @NotNull DFA dfa,\n                                     int startIndex, \n                                     int stopIndex,\n                                     @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String errorMessage = \"reportContextSensitivity d=\" + dfa.decision + \", input='\" + inputText + \"'\";\n    recognizer.notifyErrorListeners(errorMessage);\n}\n```",
        "ContextCode": "```java\npublic void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, \n                                      int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = String.format(\"reportContextSensitivity d=%d, input='%s'\", dfa.decision, inputText);\n    recognizer.notifyErrorListeners(message);\n}\n```",
        "RulesCode": "```java\npublic void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String errorMessage = \"reportContextSensitivity d=\" + dfa.decision + \", input='\" +\n                          recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\";\n    recognizer.notifyErrorListeners(errorMessage);\n}\n```"
    },
    "L7413": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "AfterRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\n\t\t\tassert s.decision + 1 >= g.decisionLOOK.size();\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        \n        IntervalSet[] look;\n        if (s.nonGreedy) { \n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        \n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        assert disjoint(look) : \"LL(1) condition failed for decision \" + s.decision;\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n\n        // Introduced assertion to validate assumption regarding non-greedy decisions\n        assert s.nonGreedy || !s.nonGreedy : \"Non-greedy decisions cannot be LL(1)\";\n\n        if (s.nonGreedy) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        \n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n\n        assert(s.getNumberOfTransitions() >= 0); // Assertion for non-negative number of transitions\n\n        if (s.nonGreedy) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}\n```",
        "ContextCode": "```java\nprotected void processParser() {\n    g.decisionLOOK = new ArrayList<>(g.atn.getNumberOfDecisions() + 1);\n    \n    for (DecisionState state : g.atn.decisionToState) {\n        logDecisionInformation(state);\n        IntervalSet[] lookaheadSets = calculateLookahead(state);\n        \n        Utils.setSize(g.decisionLOOK, state.decision + 1);\n        g.decisionLOOK.set(state.decision, lookaheadSets);\n        \n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(lookaheadSets));\n    }\n}\n\nprivate void logDecisionInformation(DecisionState state) {\n    g.tool.log(\"LL1\", \"\\nDECISION \" + state.decision + \" in rule \" + g.getRule(state.ruleIndex).name);\n}\n\nprivate IntervalSet[] calculateLookahead(DecisionState state) {\n    if (state.nonGreedy) {\n        return new IntervalSet[state.getNumberOfTransitions() + 1];\n    } else {\n        LL1Analyzer analyzer = new LL1Analyzer(g.atn);\n        IntervalSet[] lookahead = analyzer.getDecisionLookahead(state);\n        g.tool.log(\"LL1\", \"look=\" + Arrays.toString(lookahead));\n        return lookahead;\n    }\n}\n```",
        "RulesCode": "```java\nprotected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if (s.nonGreedy) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n        \n        // Introduced assertion\n        assert look != null : \"Lookahead should not be null for decision \" + s.decision;\n    }\n}\n```"
    },
    "L10037": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tIntervalSet enterLook = altLookSets[1];\n\t\tIntervalSet exitLook = altLookSets[2];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "AfterRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tassert altLookSets.length == 2;\n\t\tIntervalSet enterLook = altLookSets[0];\n\t\tIntervalSet exitLook = altLookSets[1];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "ZeroShotCode": "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n    \n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets != null && altLookSets.length > 2 : \"altLookSets should not be null and must have more than two elements\";\n    \n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```",
        "InstrucCode": "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    assert star != null; // Ensure starRoot.atnState is of type StarLoopEntryState\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    \n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets != null && altLookSets.length > 2; // Ensure altLookSets is valid and contains required elements\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```",
        "FewShotCode": "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    assert(enterLook != null); // Assertion to ensure enterLook is not null\n    assert(exitLook != null); // Assertion to ensure exitLook is not null\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```",
        "ContextCode": "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n    \n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    decision = star.decision;\n\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```",
        "RulesCode": "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\n    // Introduce assertion to validate loopExpr or other relevant properties\n    assert loopExpr != null : \"loopExpr should not be null after initialization\";\n}\n```"
    },
    "L1927": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(\"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tATNConfigSet closure = s.configs;\n\t\t\tDFAState target = null;\n\t\t\tif ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {\n\t\t\t\ttarget = s.edges[t - MIN_DFA_EDGE];\n\t\t\t\tif (target == ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (debug && target != null) {\n\t\t\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (target == null) {\n\t\t\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t\t\t// if we don't find an existing DFA state\n\t\t\t\t// Fill reach starting from closure, following t transitions\n\t\t\t\tgetReachableConfigSet(input, closure, reach, t);\n\n\t\t\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t\t\t// we reached state associated with closure for sure, so\n\t\t\t\t\t// make sure it's defined. worst case, we define s0 from\n\t\t\t\t\t// start state configs.\n\t\t\t\t\t@NotNull\n\t\t\t\t\tDFAState from = s != null ? s : addDFAState(closure);\n\t\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t\t// cause a failover from DFA later.\n\t\t\t\t\taddDFAEdge(from, t, ERROR);\n\t\t\t\t\tbreak; // stop when we can't match any more char\n\t\t\t\t}\n\n\t\t\t\t// Add an edge from s to target DFA found/created for reach\n\t\t\t\ttarget = addDFAEdge(s, t, reach);\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}",
        "AfterRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(Locale.getDefault(), \"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tDFAState target = getExistingTargetState(s, t);\n\t\t\tif (target == null) {\n\t\t\t\ttarget = computeTargetState(input, s, t);\n\t\t\t}\n\n\t\t\tif (target == ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\t@Nullable\n\tprotected DFAState getExistingTargetState(@NotNull DFAState s, int t) {\n\t\tif (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tDFAState target = s.edges[t - MIN_DFA_EDGE];\n\t\tif (debug && target != null) {\n\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link #ERROR}.\n\t */\n\t@NotNull\n\tprotected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {\n\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tgetReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t// cause a failover from DFA later.\n\t\t\taddDFAEdge(s, t, ERROR);\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ERROR;\n\t\t}\n\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn addDFAEdge(s, t, reach);\n\t}",
        "ZeroShotCode": "```java\nprotected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n        }\n\n        DFAState target = getTargetState(s, t);\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, s.configs, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull\n                DFAState from = s != null ? s : addDFAState(s.configs);\n                addDFAEdge(from, t, ERROR);\n                break; // stop when we can't match any more char\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}\n\nprivate DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}\n```",
        "InstrucCode": "```java\nprotected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = findTargetState(s, t);\n        \n        if (target == null) {\n            target = createTargetState(input, closure, t, s);\n            if (target == ERROR) break;\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}\n\nprivate DFAState findTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug && target != null) {\n                System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}\n\nprivate DFAState createTargetState(@NotNull CharStream input, ATNConfigSet closure, int t, DFAState s) {\n    ATNConfigSet reach = new OrderedATNConfigSet();\n    getReachableConfigSet(input, closure, reach, t);\n\n    if (reach.isEmpty()) {\n        @NotNull DFAState from = (s != null) ? s : addDFAState(closure);\n        addDFAEdge(from, t, ERROR);\n        return ERROR;\n    }\n    \n    return addDFAEdge(s, t, reach);\n}\n```",
        "FewShotCode": "```java\nprotected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n        }\n\n        DFAState target = getDFAState(s, t);\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, s.configs, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull\n                DFAState from = s != null ? s : addDFAState(s.configs);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}\n\nprivate DFAState getDFAState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}\n```",
        "ContextCode": "```java\nprotected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState currentDFAState = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\n\", currentDFAState.configs);\n        }\n\n        ATNConfigSet closure = currentDFAState.configs;\n        DFAState target = getDFAEdgeTarget(currentDFAState, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull DFAState from = currentDFAState != null ? currentDFAState : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n            target = addDFAEdge(currentDFAState, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n        currentDFAState = target;\n    }\n\n    return failOrAccept(prevAccept, input, currentDFAState.configs, t);\n}\n\nprivate DFAState getDFAEdgeTarget(DFAState state, int t) {\n    if (state.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = state.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug) {\n                System.out.println(\"reuse state \" + state.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}\n```",
        "RulesCode": "```java\nprotected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0;\n\n    while (true) {\n        ATNConfigSet closure = s.configs;\n        DFAState target = getTargetState(s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull\n                DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}\n\nprivate DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n        return target;\n    }\n    return null;\n}\n```"
    },
    "L540": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t DFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t boolean exact,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // method implementation here\n}\n```",
        "InstrucCode": "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // Method implementation\n}\n```",
        "FewShotCode": "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, int startIndex, int stopIndex,\n                     @NotNull BitSet ambiguousAlts,\n                     @NotNull ATNConfigSet configs);\n```",
        "ContextCode": "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa,\n                     int startIndex,\n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // Implement method logic here\n}\n```",
        "RulesCode": "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, \n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts);\n```"
    },
    "L561": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t @Nullable BitSet conflictingAlts,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Method implementation goes here\n}\n```",
        "InstrucCode": "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Function implementation here\n}\n```",
        "FewShotCode": "```java\nvoid reportFullContext(@NotNull Parser recognizer,\n                       @NotNull DFA dfa,\n                       int startIndex, \n                       int stopIndex,\n                       @NotNull ATNConfigSet configs);\n```",
        "ContextCode": "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Implementation code here\n}\n```",
        "RulesCode": "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs,\n                                  @NotNull CustomParameter addedParam) {\n    // Method body\n}\n```"
    },
    "L5431": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\t\tif (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n\t}",
        "AfterRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\n\t\tif (_buildParseTrees && _parentctx != null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\t_parentctx.addChild(retctx);\n\t\t}\n\t}",
        "ZeroShotCode": "```java\npublic void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    \n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}\n```",
        "InstrucCode": "```java\npublic void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null && _ctx != _parentctx) {\n        do {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        } while (_ctx != _parentctx);\n    } else {\n        _ctx = _parentctx;\n    }\n\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}\n```",
        "FewShotCode": "```java\npublic void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (hasParseListeners()) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}\n\nprivate boolean hasParseListeners() {\n    return _parseListeners != null;\n}\n```",
        "ContextCode": "```java\npublic void unrollRecursionContexts(ParserRuleContext parentCtx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext returnCtx = _ctx; // save current ctx (return value)\n\n    // Unroll to restore _ctx to its state before the recursive method call\n    if (_parseListeners != null) {\n        while (_ctx != parentCtx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = parentCtx;\n    }\n    \n    // Hook into tree\n    returnCtx.parent = parentCtx;\n    if (_buildParseTrees) {\n        parentCtx.addChild(returnCtx); // add return ctx into invoking rule's tree\n    }\n}\n```",
        "RulesCode": "```java\npublic void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null || _ctx == _parentctx) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}\n```"
    },
    "L3844": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "AfterRefact": " public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "ZeroShotCode": "```java\npublic void consume() {\n    boolean skipEofCheck = p >= 0 ? (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size()) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}\n```",
        "InstrucCode": "```java\npublic void consume() {\n    boolean skipEofCheck = (p >= 0) ? (fetchedEOF ? (p < tokens.size() - 1) : (p < tokens.size())) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}\n```",
        "FewShotCode": "```java\npublic void consume() {\n    boolean skipEofCheck = (p < 0) ? false : (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size());\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}\n```",
        "ContextCode": "```java\npublic void consume() {\n    if (isAtEOF()) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}\n\nprivate boolean isAtEOF() {\n    if (p < 0) {\n        return false; // not yet initialized\n    }\n\n    boolean isEOF = fetchedEOF ? p >= tokens.size() - 1 : p >= tokens.size();\n    return !isEOF && LA(1) == EOF;\n}\n```",
        "RulesCode": "```java\npublic void consume() {\n    boolean skipEofCheck = (p >= 0) ? (fetchedEOF ? (p < tokens.size() - 1) : (p < tokens.size())) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}\n```"
    },
    "L3168": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates.\n\t\t */\n\t\tif (skippedStopStates == null) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "AfterRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates, or when the current symbol is EOF.\n\t\t */\n\t\tif (skippedStopStates == null && t != Token.EOF) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tboolean treatEofAsEpsilon = t == Token.EOF;\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "ZeroShotCode": "```java\nprotected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n    \n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && \n        (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}\n```",
        "InstrucCode": "```java\nprotected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}\n```",
        "FewShotCode": "```java\nprotected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    // First figure out where we can reach on input t\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}\n```",
        "ContextCode": "```java\nprotected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) {\n        System.out.println(\"in computeReachSet, starting closure: \" + closure);\n    }\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = new ArrayList<>();\n\n    for (ATNConfig c : closure) {\n        if (debug) {\n            System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n        }\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = determineReachSet(intermediate, skippedStopStates, fullCtx);\n    \n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}\n\nprivate ATNConfigSet determineReachSet(ATNConfigSet intermediate, List<ATNConfig> skippedStopStates, boolean fullCtx) {\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            return intermediate;\n        }\n    }\n\n    ATNConfigSet reach = new ATNConfigSet(fullCtx);\n    Set<ATNConfig> closureBusy = new HashSet<>();\n    for (ATNConfig c : intermediate) {\n        closure(c, reach, closureBusy, false, fullCtx);\n    }\n    return reach;\n}\n```",
        "RulesCode": "```java\nprotected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}\n```"
    },
    "L10263": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenDisplayNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": "```java\npublic String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n\n    while (!work.isEmpty()) {\n        ATNState s = work.remove(0);\n        if (marked.contains(s)) continue;\n        marked.add(s);\n        processState(s, buf, work);\n    }\n    return buf.toString();\n}\n\nprivate void processState(ATNState s, StringBuilder buf, List<ATNState> work) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (!(s instanceof RuleStopState)) {\n            addFollowState(t, work);\n        }\n        appendTransition(buf, t, s);\n    }\n}\n\nprivate void addFollowState(Transition t, List<ATNState> work) {\n    if (t instanceof RuleTransition) {\n        work.add(((RuleTransition) t).followState);\n    } else {\n        work.add(t.target);\n    }\n}\n\nprivate void appendTransition(StringBuilder buf, Transition t, ATNState s) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append('\\n');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition) t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition) t;\n        boolean not = st instanceof NotSetTransition;\n        if (g.isLexer()) {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n        } else {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n        }\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition) t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n    }\n}\n```",
        "InstrucCode": "```java\npublic String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        \n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don't add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            buf.append(getStateString(s));\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else if (t instanceof RuleTransition) {\n                buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else if (t instanceof ActionTransition) {\n                ActionTransition a = (ActionTransition) t;\n                buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition) t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n                } else {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n                }\n            } else if (t instanceof AtomTransition) {\n                AtomTransition a = (AtomTransition) t;\n                String label = g.getTokenDisplayName(a.label);\n                buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else {\n                buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n            }\n        }\n    }\n    return buf.toString();\n}\n```",
        "FewShotCode": "```java\npublic String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    StringBuilder buf = new StringBuilder();\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don't add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition)t).followState);\n                else work.add(t.target);\n            }\n            buf.append(getStateString(s));\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else if (t instanceof RuleTransition) {\n                buf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else if (t instanceof ActionTransition) {\n                ActionTransition a = (ActionTransition)t;\n                buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition)t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n                } else {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n                }\n            } else if (t instanceof AtomTransition) {\n                AtomTransition a = (AtomTransition)t;\n                String label = g.getTokenDisplayName(a.label);\n                buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n            } else {\n                buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n            }\n        }\n    }\n    return buf.toString();\n}\n```",
        "ContextCode": "```java\npublic String asString() {\n    if (start == null) return null;\n    \n    marked = new HashSet<>();\n    work = new ArrayList<>();\n    work.add(start);\n    \n    StringBuilder buf = new StringBuilder();\n    \n    while (!work.isEmpty()) {\n        ATNState currentState = work.remove(0);\n        if (marked.contains(currentState)) continue;\n        \n        marked.add(currentState);\n        int numberOfTransitions = currentState.getNumberOfTransitions();\n        \n        for (int i = 0; i < numberOfTransitions; i++) {\n            Transition transition = currentState.transition(i);\n            processTransition(transition, currentState, buf);\n            \n            if (!(currentState instanceof RuleStopState)) {\n                addFollowStateToWork(transition, work);\n            }\n        }\n    }\n    \n    return buf.toString();\n}\n\nprivate void processTransition(Transition transition, ATNState currentState, StringBuilder buf) {\n    buf.append(getStateString(currentState));\n    \n    if (transition instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(transition.target)).append('\\n');\n    } else if (transition instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) transition).ruleIndex).name)\n            .append(\"->\").append(getStateString(transition.target)).append('\\n');\n    } else if (transition instanceof ActionTransition) {\n        buf.append(\"-\").append(transition.toString())\n            .append(\"->\").append(getStateString(transition.target)).append('\\n');\n    } else if (transition instanceof SetTransition) {\n        handleSetTransition((SetTransition) transition, buf);\n    } else if (transition instanceof AtomTransition) {\n        handleAtomTransition((AtomTransition) transition, buf);\n    } else {\n        buf.append(\"-\").append(transition.toString())\n            .append(\"->\").append(getStateString(transition.target)).append('\\n');\n    }\n}\n\nprivate void handleSetTransition(SetTransition setTransition, StringBuilder buf) {\n    boolean not = setTransition instanceof NotSetTransition;\n    String label = g.isLexer() ? (not ? \"~\" : \"\") + setTransition.toString() \n                                : (not ? \"~\" : \"\") + setTransition.label().toString(g.getTokenNames());\n    buf.append(\"-\").append(label)\n        .append(\"->\").append(getStateString(setTransition.target)).append('\\n');\n}\n\nprivate void handleAtomTransition(AtomTransition atomTransition, StringBuilder buf) {\n    String label = g.getTokenDisplayName(atomTransition.label);\n    buf.append(\"-\").append(label)\n        .append(\"->\").append(getStateString(atomTransition.target)).append('\\n');\n}\n\nprivate void addFollowStateToWork(Transition transition, List<ATNState> work) {\n    if (transition instanceof RuleTransition) {\n        work.add(((RuleTransition) transition).followState);\n    } else {\n        work.add(transition.target);\n    }\n}\n```",
        "RulesCode": "```java\npublic String asString() {\n\tif (start == null) return null;\n\tmarked = new HashSet<ATNState>();\n\n\twork = new ArrayList<ATNState>();\n\twork.add(start);\n\n\tStringBuilder buf = new StringBuilder();\n\tATNState s;\n\n\twhile (!work.isEmpty()) {\n\t\ts = work.remove(0);\n\t\tif (marked.contains(s)) continue;\n\t\tint n = s.getNumberOfTransitions();\n\t\tmarked.add(s);\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif (!(s instanceof RuleStopState)) { // don't add follow states to work\n\t\t\t\tif (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n\t\t\t\telse work.add(t.target);\n\t\t\t}\n\t\t\tbuf.append(getStateString(s));\n\t\t\tbuf.append(getTransitionString(t, s));\n\t\t}\n\t}\n\treturn buf.toString();\n}\n\nprivate String getTransitionString(Transition t, ATNState s) {\n\tStringBuilder result = new StringBuilder();\n\tif (t instanceof EpsilonTransition) {\n\t\tresult.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t} else if (t instanceof RuleTransition) {\n\t\tresult.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t} else if (t instanceof ActionTransition) {\n\t\tActionTransition a = (ActionTransition) t;\n\t\tresult.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t} else if (t instanceof SetTransition) {\n\t\tSetTransition st = (SetTransition) t;\n\t\tboolean not = st instanceof NotSetTransition;\n\t\tif (g.isLexer()) {\n\t\t\tresult.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t} else {\n\t\t\tresult.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t}\n\t} else if (t instanceof AtomTransition) {\n\t\tAtomTransition a = (AtomTransition) t;\n\t\tString label = g.getTokenDisplayName(a.label);\n\t\tresult.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t} else {\n\t\tresult.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t}\n\treturn result.toString();\n}\n```"
    },
    "L102630": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "AfterRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "ZeroShotCode": "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    }\n\n    return stateStr;\n}\n```",
        "InstrucCode": "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    }\n\n    return stateStr;\n}\n```",
        "FewShotCode": "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    } else {\n        stateStr = \"s\" + n;\n    }\n    \n    return stateStr;\n}\n```",
        "ContextCode": "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String baseStateStr = \"s\" + n;\n\n    if (s instanceof RuleStartState || s instanceof RuleStopState) {\n        String ruleName = g.getRule(s.ruleIndex).name;\n        return (s instanceof RuleStartState) ? \"RuleStart_\" + ruleName + \"_\" + n : \"RuleStop_\" + ruleName + \"_\" + n;\n    }\n\n    if (s instanceof StarBlockStartState) {\n        return \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        return \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        return \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        return \"BlockEnd_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        return \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        return \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        return \"StarLoopEntry_\" + n;\n    }\n\n    return baseStateStr;\n}\n```",
        "RulesCode": "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    }\n\n    return stateStr;\n}\n```"
    },
    "L15668": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addStopStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n\nprivate void addStopStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}\n\nprivate void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}\n\nprivate void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = isLexer ? \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\" \n                                       : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}\n```",
        "InstrucCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // Define stop states first; seems to be a bug in DOT where doublecircle\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) continue;\n        if (d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null) continue;\n                if (target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n```",
        "FewShotCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // define stop states first; seems to be a bug in DOT where doublecircle\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) continue;\n        if (d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null) continue;\n                if (target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n```",
        "ContextCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addAcceptStates(dot, dfa);\n    addNonAcceptStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n\nprivate void addAcceptStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (!state.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + state.stateNumber);\n        st.add(\"label\", getStateLabel(state));\n        dot.add(\"states\", st);\n    }\n}\n\nprivate void addNonAcceptStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.isAcceptState || state.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + state.stateNumber);\n        st.add(\"label\", getStateLabel(state));\n        dot.add(\"states\", st);\n    }\n}\n\nprivate void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.edges != null) {\n            for (int i = 0; i < state.edges.length; i++) {\n                DFAState target = state.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                String label = getEdgeLabelForState(i, isLexer);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + state.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}\n\nprivate String getEdgeLabelForState(int i, boolean isLexer) {\n    int ttype = i - 1; // shift up for EOF as -1 for parser\n    if (isLexer) {\n        return \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\";\n    } else if (grammar != null) {\n        return grammar.getTokenDisplayName(ttype);\n    }\n    return String.valueOf(ttype);\n}\n```",
        "RulesCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // Define states\n    for (DFAState d : dfa.states.keySet()) {\n        ST st;\n        if (d.isAcceptState) {\n            st = stlib.getInstanceOf(\"stopstate\");\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            st = stlib.getInstanceOf(\"state\");\n        } else {\n            continue;\n        }\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    // Define edges\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = isLexer ? \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n```"
    },
    "L156680": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = isLexer ? \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n```",
        "InstrucCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = isLexer ? \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n```",
        "FewShotCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(d.isAcceptState ? \"stopstate\" : \"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = isLexer ? \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\" : \n                        (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n```",
        "ContextCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) {\n        return null;\n    }\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addAcceptStates(dfa, dot);\n    addNonAcceptStates(dfa, dot);\n    addEdges(dfa, dot, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}\n\nprivate void addAcceptStates(DFA dfa, ST dot) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + state.stateNumber);\n            st.add(\"label\", getStateLabel(state));\n            dot.add(\"states\", st);\n        }\n    }\n}\n\nprivate void addNonAcceptStates(DFA dfa, ST dot) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (!state.isAcceptState && state.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + state.stateNumber);\n            st.add(\"label\", getStateLabel(state));\n            dot.add(\"states\", st);\n        }\n    }\n}\n\nprivate void addEdges(DFA dfa, ST dot, boolean isLexer) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.edges != null) {\n            for (int i = 0; i < state.edges.length; i++) {\n                DFAState target = state.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) {\n                    continue;\n                }\n                String label = getEdgeLabel(i, isLexer);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + state.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}\n\nprivate String getEdgeLabel(int i, boolean isLexer) {\n    int ttype = i - 1; // we shift up for EOF as -1 for parser\n    if (isLexer) {\n        return \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\";\n    }\n    return grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype);\n}\n```",
        "RulesCode": "```java\npublic String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState && d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // adjusting for EOF\n                    String label = isLexer ? \"'\" + getEdgeLabel(String.valueOf((char) i)) + \"'\" : \n                                             (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    return Utils.sortLinesInString(dot.render());\n}\n```"
    },
    "L3347": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(ATNConfig config,\n\t\t\t\t\t\t\tATNConfigSet configs,\n\t\t\t\t\t\t\tSet<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_dfa != null && _dfa.isPrecedenceDfa()) {\n\t\t\t\t\t\tint outermostPrecedenceReturn = ((EpsilonTransition)t).outermostPrecedenceReturn();\n\t\t\t\t\t\tif (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {\n\t\t\t\t\t\t\tc.setPrecedenceFilterSuppressed(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        \n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                \n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n                                       depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n                \n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting,\n                                     fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon)\n{\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n                                        depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting,\n                                     fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}\n```",
        "ContextCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState state = config.state;\n\n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean shouldCollectPredicates = !(transition instanceof ActionTransition) && collectPredicates;\n        ATNConfig nextConfig = getEpsilonTarget(config, transition, shouldCollectPredicates, depth == 0, fullCtx, treatEofAsEpsilon);\n        \n        if (nextConfig != null) {\n            if (!transition.isEpsilon() && !closureBusy.add(nextConfig)) {\n                continue;\n            }\n\n            int currentDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(nextConfig)) {\n                    continue;\n                }\n\n                nextConfig.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                currentDepth = Math.max(currentDepth - 1, Integer.MIN_VALUE);\n                \n                if (debug) {\n                    System.out.println(\"dips into outer ctx: \" + nextConfig);\n                }\n            } else if (transition instanceof RuleTransition) {\n                if (currentDepth >= 0) {\n                    currentDepth++;\n                }\n            }\n\n            closureCheckingStopState(nextConfig, configs, closureBusy, shouldCollectPredicates, fullCtx, currentDepth, treatEofAsEpsilon);\n        }\n    }\n}\n```",
        "RulesCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}\n```"
    },
    "L2755": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof AbstractPredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void _LOOK(@NotNull ATNState s,\n                    @Nullable ATNState stopState,\n                    @Nullable PredictionContext ctx,\n                    @NotNull IntervalSet look,\n                    @NotNull Set<ATNConfig> lookBusy,\n                    @NotNull BitSet calledRuleStack,\n                    boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        handleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, look, stopState, calledRuleStack, seeThruPreds, addEOF);\n        return;\n    }\n\n    processTransitions(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n}\n\nprivate void handleStopState(@Nullable PredictionContext ctx, @NotNull IntervalSet look, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n}\n\nprivate void handleRuleStopState(@Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                  @Nullable ATNState stopState, @NotNull BitSet calledRuleStack,\n                                  boolean seeThruPreds, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n\n    if (ctx != PredictionContext.EMPTY) {\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}\n\nprivate void processTransitions(@NotNull ATNState s, @Nullable ATNState stopState,\n                                @Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                boolean seeThruPreds, boolean addEOF) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            processRuleTransition((RuleTransition) t, stopState, ctx, look, lookBusy, calledRuleStack, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            processPredicateTransition(t, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            processOtherTransitions(t, look);\n        }\n    }\n}\n\nprivate void processRuleTransition(RuleTransition t, @Nullable ATNState stopState,\n                                    @Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                    @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                    boolean addEOF) {\n    if (calledRuleStack.get(t.target.ruleIndex)) {\n        return;\n    }\n\n    PredictionContext newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n    try {\n        calledRuleStack.set(t.target.ruleIndex);\n        _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } finally {\n        calledRuleStack.clear(t.target.ruleIndex);\n    }\n}\n\nprivate void processPredicateTransition(Transition t, @Nullable ATNState stopState,\n                                        @Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                        @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                        boolean seeThruPreds, boolean addEOF) {\n    if (seeThruPreds) {\n        _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } else {\n        look.add(HIT_PRED);\n    }\n}\n\nprivate void processOtherTransitions(Transition t, @NotNull IntervalSet look) {\n    IntervalSet set = t.label();\n    if (set != null) {\n        if (t instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        look.addAll(set);\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```",
        "ContextCode": "```java\nprotected void look(@NotNull ATNState state,\n                    @Nullable ATNState stopState,\n                    @Nullable PredictionContext context,\n                    @NotNull IntervalSet lookahead,\n                    @NotNull Set<ATNConfig> lookBusy,\n                    @NotNull BitSet calledRuleStack,\n                    boolean seeThroughPredicates, boolean addEOF) {\n    \n    ATNConfig config = new ATNConfig(state, 0, context);\n    if (!lookBusy.add(config)) return;\n\n    handleStopState(state, stopState, context, lookahead, addEOF);\n\n    if (state instanceof RuleStopState) {\n        handleRuleStopState(context, stopState, lookahead, calledRuleStack, seeThroughPredicates, addEOF);\n        return;\n    }\n\n    processTransitions(state, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n}\n\nprivate void handleStopState(@NotNull ATNState state,\n                              @Nullable ATNState stopState,\n                              @Nullable PredictionContext context,\n                              @NotNull IntervalSet lookahead,\n                              boolean addEOF) {\n    if (state == stopState) {\n        if (context == null) {\n            lookahead.add(Token.EPSILON);\n        } else if (context.isEmpty() && addEOF) {\n            lookahead.add(Token.EOF);\n        }\n    }\n}\n\nprivate void handleRuleStopState(@Nullable PredictionContext context,\n                                  @Nullable ATNState stopState,\n                                  @NotNull IntervalSet lookahead,\n                                  @NotNull BitSet calledRuleStack,\n                                  boolean seeThroughPredicates,\n                                  boolean addEOF) {\n    if (context == null) {\n        lookahead.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookahead.add(Token.EOF);\n    }\n\n    if (context != PredictionContext.EMPTY) {\n        for (int i = 0; i < context.size(); i++) {\n            ATNState returnState = atn.states.get(context.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                look(returnState, stopState, context.getParent(i), lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}\n\nprivate void processTransitions(@NotNull ATNState state,\n                                @Nullable ATNState stopState,\n                                @Nullable PredictionContext context,\n                                @NotNull IntervalSet lookahead,\n                                @NotNull Set<ATNConfig> lookBusy,\n                                @NotNull BitSet calledRuleStack,\n                                boolean seeThroughPredicates,\n                                boolean addEOF) {\n    int numberOfTransitions = state.getNumberOfTransitions();\n    for (int i = 0; i < numberOfTransitions; i++) {\n        Transition transition = state.transition(i);\n        handleTransition(transition, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    }\n}\n\nprivate void handleTransition(Transition transition,\n                              @Nullable ATNState stopState,\n                              @Nullable PredictionContext context,\n                              @NotNull IntervalSet lookahead,\n                              @NotNull Set<ATNConfig> lookBusy,\n                              @NotNull BitSet calledRuleStack,\n                              boolean seeThroughPredicates,\n                              boolean addEOF) {\n    if (transition instanceof RuleTransition) {\n        processRuleTransition((RuleTransition) transition, stopState, context, lookahead, calledRuleStack, seeThroughPredicates, addEOF);\n    } else if (transition instanceof PredicateTransition) {\n        processPredicateTransition(transition, stopState, context, lookahead, seeThroughPredicates, addEOF);\n    } else if (transition.isEpsilon()) {\n        look(transition.target, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } else if (transition instanceof WildcardTransition) {\n        lookahead.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n    } else {\n        processOtherTransitions(transition, lookahead);\n    }\n}\n\nprivate void processRuleTransition(RuleTransition transition,\n                                    @Nullable ATNState stopState,\n                                    @Nullable PredictionContext context,\n                                    @NotNull IntervalSet lookahead,\n                                    @NotNull BitSet calledRuleStack,\n                                    boolean seeThroughPredicates,\n                                    boolean addEOF) {\n    if (calledRuleStack.get(transition.target.ruleIndex)) return;\n\n    PredictionContext newContext = SingletonPredictionContext.create(context, transition.followState.stateNumber);\n\n    try {\n        calledRuleStack.set(transition.target.ruleIndex);\n        look(transition.target, stopState, newContext, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } finally {\n        calledRuleStack.clear(transition.target.ruleIndex);\n    }\n}\n\nprivate void processPredicateTransition(Transition transition,\n                                        @Nullable ATNState stopState,\n                                        @Nullable PredictionContext context,\n                                        @NotNull IntervalSet lookahead,\n                                        boolean seeThroughPredicates,\n                                        boolean addEOF) {\n    if (seeThroughPredicates) {\n        look(transition.target, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } else {\n        lookahead.add(HIT_PRED);\n    }\n}\n\nprivate void processOtherTransitions(Transition transition,\n                                     @NotNull IntervalSet lookahead) {\n    IntervalSet set = transition.label();\n    if (set != null) {\n        if (transition instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        lookahead.addAll(set);\n    }\n}\n```",
        "RulesCode": "```java\nprotected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState || (s instanceof RuleStopState && (ctx == null || (ctx.isEmpty() && addEOF)))) {\n        look.add(ctx == null ? Token.EPSILON : Token.EOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState && ctx != PredictionContext.EMPTY) {\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n        return;\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```"
    },
    "L13228": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tFileReader fr = new FileReader(fullFile);\n\t\t\tBufferedReader br = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  ioe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\treturn tokens;\n\t}",
        "AfterRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\tFileReader fr = null;\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tfr = new FileReader(fullFile);\n\t\t\tbr = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token type: \"+tokenTypeS,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t\ttokenType = Token.INVALID_TOKEN_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ( br!=null ) br.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t\t  ioe);\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}",
        "ZeroShotCode": "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        String tokenDef;\n        int lineNum = 1;\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n        \n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokenDef, tokens, tokenDefPattern, lineNum);\n            lineNum++;\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    return tokens;\n}\n\nprivate void processTokenDefinition(String tokenDef, Map<String, Integer> tokens, Pattern tokenDefPattern, int lineNum) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    \n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (!tokenDef.isEmpty()) { \n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR, vocabName + CodeGenerator.VOCAB_FILE_EXTENSION, \" bad token def: \" + tokenDef, lineNum);\n    }\n}\n```",
        "InstrucCode": "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n        int lineNum = 1;\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) { // ignore blank lines\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \" + tokenDef,\n                                          lineNum);\n                }\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n                              fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              e);\n    }\n    return tokens;\n}\n```",
        "FewShotCode": "```java\npublic Map<String,Integer> load() {\n    File fullFile = getImportedVocabFile();\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    int lineNum = 1;\n\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) { // ignore blank lines\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \" + tokenDef,\n                                          lineNum);\n                }\n            }\n            tokenDef = br.readLine();\n        }\n\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n                              fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              e);\n    }\n    return tokens;\n}\n```",
        "ContextCode": "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    \n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        String tokenDef;\n        int lineNum = 1;\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n        \n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokenDef, lineNum++, tokens, tokenDefPattern);\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    \n    return tokens;\n}\n\nprivate void processTokenDefinition(String tokenDef, int lineNum, Map<String, Integer> tokens, Pattern tokenDefPattern) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (!tokenDef.isEmpty()) {\n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                \" bad token def: \" + tokenDef,\n                lineNum);\n    }\n}\n```",
        "RulesCode": "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n        int lineNum = 1;\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else if (tokenDef.length() > 0) { // ignore blank lines\n                tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                      vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                      \" bad token def: \" + tokenDef,\n                                      lineNum);\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n                              fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              e);\n    }\n    return tokens;\n}\n```"
    },
    "L8024": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i - 1).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\");\n\t\t\tfor (int j=1; j<=nintervals; j++) {\n\t\t\t\tif ( j>1 ) buf.append(\", \");\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tUUID uuid = ATNSimulator.toUUID(data, p);\n\t\tp += 8;\n\t\tif (!uuid.equals(ATNSimulator.SERIALIZED_UUID)) {\n\t\t\tString reason = String.format(Locale.getDefault(), \"Could not deserialize ATN with UUID %s (expected %s).\", uuid, ATNSimulator.SERIALIZED_UUID);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tif (ruleIndex == Character.MAX_VALUE) {\n\t\t\t\truleIndex = -1;\n\t\t\t}\n\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n\t\t\t\tif (arg2 == Character.MAX_VALUE) {\n\t\t\t\t\targ2 = -1;\n\t\t\t\t}\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\");\n\t\t\tboolean containsEof = data[p++] != 0;\n\t\t\tif (containsEof) {\n\t\t\t\tbuf.append(getTokenName(Token.EOF));\n\t\t\t}\n\n\t\t\tfor (int j=0; j<nintervals; j++) {\n\t\t\t\tif ( containsEof || j>0 ) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t}\n\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": "```java\npublic String decode(char[] data) {\n    data = data.clone();\n    adjustData(data);\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    validateVersion(data, p);\n    p += 2; // Increment p by the number of consumed items\n\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\n\");\n    \n    int nstates = ATNSimulator.toInt(data[p++]);\n    decodeStates(data, buf, p, nstates);\n    p += nstates * 2 + 1; // Adjust for number of states processed\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    p += numNonGreedyStates; // Adjust for non-greedy states\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    decodeRules(data, buf, p, nrules);\n    p += nrules * (g.isLexer() ? 3 : 1); // Adjust for rules processed\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    decodeModes(data, buf, p, nmodes);\n    p += nmodes; // Adjust for modes processed\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    decodeSets(data, buf, p, nsets);\n    p += nsets; // Adjust for sets processed\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    decodeEdges(data, buf, p, nedges);\n    p += nedges * 6; // Adjust for edges processed\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    decodeDecisions(data, buf, p, ndecisions);\n\n    return buf.toString();\n}\n\nprivate void adjustData(char[] data) {\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char) (data[i] - 2);\n    }\n}\n\nprivate void validateVersion(char[] data, int p) {\n    int version = ATNSimulator.toInt(data[p]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n}\n\nprivate void decodeStates(char[] data, StringBuilder buf, int p, int nstates) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(ATNState.serializationNames.get(stype)).append(\" \").append(ruleIndex).append(getStateArg(data, p, stype)).append(\"\\n\");\n        p += getArgCount(stype);\n    }\n}\n\nprivate String getStateArg(char[] data, int p, int stype) {\n    if (stype == ATNState.LOOP_END) {\n        return \" \" + ATNSimulator.toInt(data[p++]);\n    } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n        return \" \" + ATNSimulator.toInt(data[p++]);\n    }\n    return \"\";\n}\n\nprivate int getArgCount(int stype) {\n    if (stype == ATNState.LOOP_END) return 1;\n    if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) return 1;\n    return 0;\n}\n\nprivate void decodeRules(char[] data, StringBuilder buf, int p, int nrules) {\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n        }\n    }\n}\n\nprivate void decodeModes(char[] data, StringBuilder buf, int p, int nmodes) {\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n    }\n}\n\nprivate void decodeSets(char[] data, StringBuilder buf, int p, int nsets) {\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\n\");\n    }\n}\n\nprivate void decodeEdges(char[] data, StringBuilder buf, int p, int nedges) {\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\n\");\n        p += 6;\n    }\n}\n\nprivate void decodeDecisions(char[] data, StringBuilder buf, int p, int ndecisions) {\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\n\");\n    }\n}\n```",
        "InstrucCode": "```java\npublic String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i=1; i<=nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if ( stype == ATNState.INVALID_TYPE ) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if ( stype == ATNState.LOOP_END ) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\n\");\n    }\n    \n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    \n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i=0; i<nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if ( g.isLexer() ) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n        }\n    }\n    \n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i=0; i<nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n    }\n    \n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i=1; i<=nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j=1; j<=nintervals; j++) {\n            if ( j > 1 ) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\n\");\n    }\n    \n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i=1; i<=nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\n\");\n        p += 6;\n    }\n    \n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i=1; i<=ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i-1).append(\":\").append(s).append(\"\\n\");\n    }\n    \n    return buf.toString();\n}\n```",
        "FewShotCode": "```java\npublic String decode(char[] data) {\n    data = data.clone();\n    // don't adjust the first value since that's the version number\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\n\");\n    }\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n        }\n    }\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n    }\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\n\");\n    }\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\n\");\n        p += 6;\n    }\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\n\");\n    }\n    \n    return buf.toString();\n}\n```",
        "ContextCode": "```java\npublic String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char) (data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        throw new UnsupportedOperationException(\n            new InvalidClassException(ATN.class.getName(),\n                String.format(\"Could not deserialize ATN with version %d (expected %d).\",\n                version, ATNSimulator.SERIALIZED_VERSION)\n            )\n        );\n    }\n\n    appendGrammarType(buf, data, p);\n    p += 2; // Skip grammarType and maxType\n\n    int nstates = ATNSimulator.toInt(data[p++]);\n    appendStates(buf, data, nstates, p);\n    p += (nstates * 2); // Update pointer based on states\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    p += numNonGreedyStates; // Skip non-greedy states\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    appendRules(buf, data, nrules, p);\n    p += nrules * (g.isLexer() ? 3 : 1); // Update pointer based on rules\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    appendModes(buf, data, nmodes, p);\n    p += nmodes; // Update pointer based on modes\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    appendSets(buf, data, nsets, p);\n    p += nsets * 2; // Update pointer based on sets\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    appendEdges(buf, data, nedges, p);\n    p += nedges * 6; // Update pointer based on edges\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    appendDecisions(buf, data, ndecisions, p);\n\n    return buf.toString();\n}\n\nprivate void appendGrammarType(StringBuilder buf, char[] data, int p) {\n    int grammarType = ATNSimulator.toInt(data[p]);\n    int maxType = ATNSimulator.toInt(data[p + 1]);\n    buf.append(\"max type \").append(maxType).append(\"\\n\");\n}\n\nprivate void appendStates(StringBuilder buf, char[] data, int nstates, int p) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        \n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n\n        if (stype == ATNState.LOOP_END) {\n            arg = \" \" + ATNSimulator.toInt(data[p++]);\n        } else if (isBlockStart(stype)) {\n            arg = \" \" + ATNSimulator.toInt(data[p++]);\n        }\n        \n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\n\");\n    }\n}\n\nprivate boolean isBlockStart(int stype) {\n    return stype == ATNState.PLUS_BLOCK_START || \n           stype == ATNState.STAR_BLOCK_START || \n           stype == ATNState.BLOCK_START;\n}\n\nprivate void appendRules(StringBuilder buf, char[] data, int nrules, int p) {\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"rule \").append(i).append(\":\").append(s);\n        if (g.isLexer()) {\n            buf.append(\" \").append(ATNSimulator.toInt(data[p++])).append(\",\")\n               .append(ATNSimulator.toInt(data[p++]));\n        }\n        buf.append('\\n');\n    }\n}\n\nprivate void appendModes(StringBuilder buf, char[] data, int nmodes, int p) {\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n    }\n}\n\nprivate void appendSets(StringBuilder buf, char[] data, int nsets, int p) {\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\")\n               .append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\n\");\n    }\n}\n\nprivate void appendEdges(StringBuilder buf, char[] data, int nedges, int p) {\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        \n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\n\");\n        p += 6;\n    }\n}\n\nprivate void appendDecisions(StringBuilder buf, char[] data, int ndecisions, int p) {\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\n\");\n    }\n}\n```",
        "RulesCode": "```java\npublic String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\n\");\n    }\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n        }\n    }\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n    }\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\n\");\n    }\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\n\");\n        p += 6;\n    }\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\n\");\n    }\n    return buf.toString();\n}\n```"
    },
    "L9806": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.target.getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "AfterRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.getTarget().getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.getTarget().getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.getTarget().getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "ZeroShotCode": "```java\npublic void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d = createImplicitLabelDecl(ast);\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}\n\nprivate Decl createImplicitLabelDecl(GrammarAST ast) {\n    Decl d;\n    if (isSetOrWildcard(ast)) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } else if (isRuleRef(ast)) {\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n    markAsImplicit(d);\n    return d;\n}\n\nprivate boolean isSetOrWildcard(GrammarAST ast) {\n    return ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD;\n}\n\nprivate boolean isRuleRef(GrammarAST ast) {\n    return ast.getType() == ANTLRParser.RULE_REF;\n}\n\nprivate void markAsImplicit(Decl d) {\n    if (d instanceof TokenDecl) {\n        ((TokenDecl)d).isImplicit = true;\n    } else if (d instanceof RuleContextDecl) {\n        ((RuleContextDecl)d).isImplicit = true;\n    }\n}\n```",
        "InstrucCode": "```java\npublic void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { \n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl) d).isImplicit = true;\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    }\n    \n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n    op.getLabels().add(d);\n}\n```",
        "FewShotCode": "```java\npublic void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl) d).isImplicit = true;\n    } else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    }\n    op.getLabels().add(d);\n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}\n```",
        "ContextCode": "```java\npublic void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl declaration = createImplicitDeclaration(ast);\n    op.getLabels().add(declaration);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), declaration);\n}\n\nprivate Decl createImplicitDeclaration(GrammarAST ast) {\n    if (isSetOrWildcard(ast)) {\n        return createImplicitSetDecl(ast);\n    } else if (isRuleReference(ast)) {\n        return createImplicitRuleDecl(ast);\n    } else {\n        return createImplicitTokenDecl(ast);\n    }\n}\n\nprivate boolean isSetOrWildcard(GrammarAST ast) {\n    return ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD;\n}\n\nprivate boolean isRuleReference(GrammarAST ast) {\n    return ast.getType() == ANTLRParser.RULE_REF;\n}\n\nprivate Decl createImplicitSetDecl(GrammarAST ast) {\n    String implicitLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n    TokenDecl tokenDecl = (TokenDecl) getTokenLabelDecl(implicitLabel);\n    tokenDecl.isImplicit = true;\n    return tokenDecl;\n}\n\nprivate Decl createImplicitRuleDecl(GrammarAST ast) {\n    Rule rule = g.getRule(ast.getText());\n    String implicitLabel = gen.target.getImplicitRuleLabel(ast.getText());\n    String contextName = gen.target.getRuleFunctionContextStructName(rule);\n    RuleContextDecl ruleContextDecl = new RuleContextDecl(this, implicitLabel, contextName);\n    ruleContextDecl.isImplicit = true;\n    return ruleContextDecl;\n}\n\nprivate Decl createImplicitTokenDecl(GrammarAST ast) {\n    String implicitLabel = gen.target.getImplicitTokenLabel(ast.getText());\n    TokenDecl tokenDecl = (TokenDecl) getTokenLabelDecl(implicitLabel);\n    tokenDecl.isImplicit = true;\n    return tokenDecl;\n}\n```",
        "RulesCode": "```java\npublic void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n    \n    ((TokenDecl)d).isImplicit = true;\n    op.getLabels().add(d);\n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}\n```"
    },
    "L1506": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void addTransition(Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(e);\n\t}",
        "AfterRefact": "public void addTransition(Transition e) {\n\t\taddTransition(transitions.size(), e);\n\t}\n\n\tpublic void addTransition(int index, Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(Locale.getDefault(), \"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(index, e);\n\t}",
        "ZeroShotCode": "```java\npublic void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilon;\n    } else if (epsilonOnlyTransitions != isEpsilon) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n    transitions.add(e);\n}\n```",
        "InstrucCode": "```java\npublic void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n  \n    if (transitions.isEmpty() || (epsilonOnlyTransitions != isEpsilon)) {\n        if (transitions.isEmpty()) {\n            epsilonOnlyTransitions = isEpsilon;\n        } else {\n            System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n            epsilonOnlyTransitions = false;\n        }\n    }\n  \n    transitions.add(e);\n}\n```",
        "FewShotCode": "```java\npublic void addTransition(Transition e) {\n    if (isInvalidTransition(e)) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    } else if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = e.isEpsilon();\n    }\n    transitions.add(e);\n}\n\nprivate boolean isInvalidTransition(Transition e) {\n    return !transitions.isEmpty() && (epsilonOnlyTransitions != e.isEpsilon());\n}\n```",
        "ContextCode": "```java\npublic void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    \n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilon;\n    } else if (epsilonOnlyTransitions != isEpsilon) {\n        logEpsilonTransitionError();\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(e);\n}\n\nprivate void logEpsilonTransitionError() {\n    System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.%n\", stateNumber);\n}\n```",
        "RulesCode": "```java\npublic void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    \n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilon;\n    } else if (epsilonOnlyTransitions != isEpsilon) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n    \n    transitions.add(e);\n}\n```"
    },
    "L1991": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\n\", config);\n            }\n        }\n\n        if (config.context == null) {\n            configs.add(config);\n            return true;\n        }\n\n        if (config.context.hasEmptyPath()) {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n        }\n\n        if (!config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent;\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n        \n        return currentAltReachedAcceptState;\n    }\n    \n    if (!config.state.onlyHasEpsilonTransitions() && (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n```",
        "InstrucCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions() && \n        (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n```",
        "FewShotCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Don't pursue but\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions() && \n            (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n```",
        "ContextCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                          @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                          boolean speculative) {\n    logDebugInfo(config);\n\n    if (isRuleStopState(config.state)) {\n        handleRuleStopState(config, configs, currentAltReachedAcceptState);\n        return currentAltReachedAcceptState;\n    }\n\n    optimizeConfig(config, currentAltReachedAcceptState, configs);\n\n    return traverseTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n}\n\nprivate void logDebugInfo(LexerATNConfig config) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\n\", config);\n        }\n    }\n}\n\nprivate boolean isRuleStopState(ATNState state) {\n    return state instanceof RuleStopState;\n}\n\nprivate void handleRuleStopState(@NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, \n                                  boolean currentAltReachedAcceptState) {\n    if (config.context == null || config.context.hasEmptyPath()) {\n        addConfigToSet(config, configs, currentAltReachedAcceptState);\n    } else {\n        processNonEmptyContext(config, configs, currentAltReachedAcceptState);\n    }\n}\n\nprivate void addConfigToSet(LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState) {\n    if (config.context == null || config.context.isEmpty()) {\n        configs.add(config);\n    } else {\n        configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n        currentAltReachedAcceptState = true;\n    }\n}\n\nprivate void processNonEmptyContext(LexerATNConfig config, ATNConfigSet configs, \n                                     boolean currentAltReachedAcceptState) {\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            PredictionContext newContext = ctx.parent;\n            handleContextReturnState(config, configs, currentAltReachedAcceptState, ctx, newContext);\n        }\n    }\n}\n\nprivate void handleContextReturnState(LexerATNConfig config, ATNConfigSet configs, \n                                       boolean currentAltReachedAcceptState, SingletonPredictionContext ctx, \n                                       PredictionContext newContext) {\n    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n        recordEndState(config, configs, ctx);\n    } else {\n        ATNState returnState = atn.states.get(ctx.returnState);\n        LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n        currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n    }\n}\n\nprivate void recordEndState(LexerATNConfig config, ATNConfigSet configs, SingletonPredictionContext ctx) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n    }\n    configs.add(c);\n}\n\nprivate void optimizeConfig(LexerATNConfig config, boolean currentAltReachedAcceptState, \n                            ATNConfigSet configs) {\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n}\n\nprivate boolean traverseTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, \n                                    boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}\n```",
        "RulesCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n        } else if (config.context.hasEmptyPath()) {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n        } else {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Don't pursue but\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions() && \n        (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n```"
    },
    "L19910": {
        "RefactMethod": "INTRODUCE SPECIAL CASE",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        handleRuleStopState(input, config, configs);\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n\nprivate void handleRuleStopState(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs) {\n    if (debug) {\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\n\", config);\n        }\n    }\n\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n        }\n    }\n\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                    if (debug) System.out.println(\"FALLING off token \" +\n                            recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                    configs.add(c);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n}\n```",
        "InstrucCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (isRuleStopState(config.state)) {\n        if (debug) {\n            logRuleStop(config);\n        }\n\n        currentAltReachedAcceptState = handleContext(config, configs, currentAltReachedAcceptState);\n\n        return currentAltReachedAcceptState;\n    }\n\n    // Optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    currentAltReachedAcceptState = processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n    \n    return currentAltReachedAcceptState;\n}\n\nprivate boolean isRuleStopState(ATNState state) {\n    return state instanceof RuleStopState;\n}\n\nprivate void logRuleStop(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\n\", config);\n    }\n}\n\nprivate boolean handleContext(LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState) {\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            return true;\n        }\n    }\n\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    recordEmptyReturnState(config, ctx, configs);\n                    continue;\n                }\n                currentAltReachedAcceptState = processReturnState(ctx, config, newContext, configs, currentAltReachedAcceptState);\n            }\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n\nprivate void recordEmptyReturnState(LexerATNConfig config, SingletonPredictionContext ctx, ATNConfigSet configs) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n    }\n    configs.add(c);\n}\n\nprivate boolean processReturnState(SingletonPredictionContext ctx, LexerATNConfig config, PredictionContext newContext, ATNConfigSet configs, boolean currentAltReachedAcceptState) {\n    ATNState returnState = atn.states.get(ctx.returnState);\n    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n    return closure(input, c, configs, currentAltReachedAcceptState, speculative);\n}\n\nprivate boolean processTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n```",
        "FewShotCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Don't pursue but\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                                      recog.getRuleNames()[config.state.ruleIndex] +\n                                                      \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n\nclass UnknownLexerATNConfig extends LexerATNConfig {\n    @Override\n    public PredictionContext getContext() {\n        return PredictionContext.EMPTY;\n    }\n}\n\nprotected boolean isUnknown(LexerATNConfig config) {\n    return config instanceof UnknownLexerATNConfig;\n}\n```",
        "ContextCode": "```java\nprotected boolean closure(@NotNull CharStream input, \n                          @NotNull LexerATNConfig config, \n                          @NotNull ATNConfigSet configs, \n                          boolean currentAltReachedAcceptState, \n                          boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (isRuleStopState(config)) {\n        currentAltReachedAcceptState = handleRuleStopState(input, config, configs, currentAltReachedAcceptState);\n    } else {\n        processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    return currentAltReachedAcceptState;\n}\n\nprivate boolean isRuleStopState(LexerATNConfig config) {\n    return config.state instanceof RuleStopState;\n}\n\nprivate boolean handleRuleStopState(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState) {\n    logDebugForRuleStopState(config);\n\n    if (shouldAddConfigToSet(config, configs)) {\n        return true;\n    }\n\n    if (config.context != null && !config.context.isEmpty()) {\n        return handleNonEmptyContext(input, config, configs, currentAltReachedAcceptState);\n    }\n\n    configs.add(config);\n    return true;\n}\n\nprivate void logDebugForRuleStopState(LexerATNConfig config) {\n    if (debug) {\n        String message = (recog != null) \n            ? String.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config)\n            : String.format(\"closure at rule stop %s\\n\", config);\n        System.out.format(message);\n    }\n}\n\nprivate boolean shouldAddConfigToSet(LexerATNConfig config, ATNConfigSet configs) {\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            return false; // Change to false for further processing.\n        }\n    }\n    return false; // Continue normal processing.\n}\n\nprivate boolean handleNonEmptyContext(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState) {\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            PredictionContext newContext = ctx.parent;\n            if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                recordEndState(config, ctx, configs);\n            } else {\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig newConfig = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, newConfig, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n    return currentAltReachedAcceptState;\n}\n\nprivate void recordEndState(LexerATNConfig config, SingletonPredictionContext ctx, ATNConfigSet configs) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n    }\n    configs.add(c);\n}\n\nprivate void processTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n}\n```",
        "RulesCode": "```java\nprotected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent;\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}\n```"
    },
    "L2113": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (SingletonPredictionContext p : ctx) {\n\t\t\t\t\tATNState returnState = atn.states.get(p.returnState);\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\t\t\t\t\t_LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\t\t\t\t_LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    \n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void lookAhead(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                         @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n                         boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                lookAhead(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            lookAhead(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                lookAhead(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            lookAhead(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```",
        "ContextCode": "```java\nprotected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    \n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    processTransitions(s, ctx, look, lookBusy, seeThruPreds, addEOF);\n}\n\nprivate void handleRuleStopState(@Nullable PredictionContext ctx,\n                                   @NotNull IntervalSet look,\n                                   boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    } else if (ctx != PredictionContext.EMPTY) {\n        for (SingletonPredictionContext p : ctx) {\n            ATNState returnState = atn.states.get(p.returnState);\n            _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n        }\n    }\n}\n\nprivate void processTransitions(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                                @NotNull IntervalSet look, \n                                @NotNull Set<ATNConfig> lookBusy,\n                                boolean seeThruPreds, boolean addEOF) {\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            PredictionContext newContext =\n                    SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            handlePredicateTransition(t, ctx, look, seeThruPreds);\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            handleOtherTransitions(t, look);\n        }\n    }\n}\n\nprivate void handlePredicateTransition(Transition t, @Nullable PredictionContext ctx,\n                                       @NotNull IntervalSet look, boolean seeThruPreds) {\n    if (seeThruPreds) {\n        _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n    } else {\n        look.add(HIT_PRED);\n    }\n}\n\nprivate void handleOtherTransitions(Transition t, @NotNull IntervalSet look) {\n    IntervalSet set = t.label();\n    if (set != null) {\n        if (t instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        look.addAll(set);\n    }\n}\n```",
        "RulesCode": "```java\nprotected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                    SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}\n```"
    },
    "L2427": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    if (p.onlyHasEpsilonTransitions()) {\n        return;\n    }\n\n    configs.add(config, mergeCache);\n    \n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true; \n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) {\n                System.out.println(\"dips into outer ctx: \" + c);\n            }\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    \n    // Optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n\n            if (debug) {\n                System.out.println(\"dips into outer ctx: \" + c);\n            }\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    \n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c == null) continue;\n\n        int newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        }\n\n        if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}\n```",
        "ContextCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState state = config.state;\n\n    // Optimization: add config if only epsilon transitions are not present\n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean shouldContinueCollecting = !(transition instanceof ActionTransition) && collectPredicates;\n        \n        ATNConfig targetConfig = getEpsilonTarget(config, transition, shouldContinueCollecting, depth == 0, fullCtx);\n        if (targetConfig != null) {\n            int newDepth = depth;\n\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                targetConfig.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                newDepth = Math.max(newDepth - 1, Integer.MIN_VALUE);\n            } else if (transition instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(targetConfig, configs, closureBusy, shouldContinueCollecting, fullCtx, newDepth);\n        }\n    }\n}\n```",
        "RulesCode": "```java\nprotected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c != null) {\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n        }\n    }\n}\n```"
    },
    "L9795": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.target.getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.target.getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "AfterRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.getTarget().getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.getTarget().getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "ZeroShotCode": "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    initializeStateNumber(ast);\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n    \n    RuleFunction rf = factory.getCurrentRuleFunction();\n    processLabelAST(factory, labelAST, rf, ast, gen);\n    \n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n    \n    defineImplicitLabelIfNecessary(factory, ast, rf, gen);\n}\n\nprivate void initializeStateNumber(GrammarAST ast) {\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n}\n\nprivate void processLabelAST(ParserFactory factory, GrammarAST labelAST, RuleFunction rf, GrammarAST ast, CodeGenerator gen) {\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n}\n\nprivate void defineImplicitLabelIfNecessary(ParserFactory factory, GrammarAST ast, RuleFunction rf, CodeGenerator gen) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```",
        "InstrucCode": "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n\n    if (labelAST != null) {\n        handleLabelAST(factory, labelAST, ast, rf, gen);\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n\nprivate void handleLabelAST(ParserFactory factory, GrammarAST labelAST, GrammarAST ast, RuleFunction rf, CodeGenerator gen) {\n    String label = labelAST.getText();\n    if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n        factory.defineImplicitLabel(ast, this);\n        String listLabel = gen.target.getListLabel(label);\n        RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n        rf.addContextDecl(ast.getAltLabel(), l);\n    } else {\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```",
        "FewShotCode": "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(ast.getText());\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    if (labelAST != null) {\n        // for x=r, define <rule-context-type> x and list_x\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```",
        "ContextCode": "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    \n    initializeStateNumber(ast);\n    this.name = ast.getText();\n    \n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n    \n    defineContextLabels(factory, labelAST, gen);\n    handleActionExpressions(ast, factory);\n    defineImplicitLabelIfRequired(factory, ast, gen);\n}\n\nprivate void initializeStateNumber(GrammarAST ast) {\n    if (ast.atnState != null) {\n        stateNumber = ast.atnState.stateNumber;\n    }\n}\n\nprivate void defineContextLabels(ParserFactory factory, GrammarAST labelAST, CodeGenerator gen) {\n    if (labelAST != null) {\n        RuleFunction rf = factory.getCurrentRuleFunction();\n        String label = labelAST.getText();\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl listDecl = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), listDecl);\n        } else {\n            RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n            labels.add(contextDecl);\n            rf.addContextDecl(ast.getAltLabel(), contextDecl);\n        }\n    }\n}\n\nprivate void handleActionExpressions(GrammarAST ast, ParserFactory factory) {\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, factory.getCurrentRuleFunction(), arg.token, arg);\n    }\n}\n\nprivate void defineImplicitLabelIfRequired(ParserFactory factory, GrammarAST ast, CodeGenerator gen) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n        labels.add(contextDecl);\n        factory.getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), contextDecl);\n    }\n}\n```",
        "RulesCode": "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
    },
    "L9861": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.target.getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "AfterRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.getTarget().getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "ZeroShotCode": "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; \n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = initializeTokens(g);\n    tokenNames = initializeTokenNames(g);\n    ruleNames = g.rules.keySet();\n    superClass = initializeSuperClass(g);\n}\n\nprivate Map<String, Integer> initializeTokens(Grammar g) {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n    return tokens;\n}\n\nprivate String[] initializeTokenNames(Grammar g) {\n    String[] tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        tokenNames[i] = formatTokenName(tokenNames[i], gen);\n    }\n    return tokenNames;\n}\n\nprivate String formatTokenName(String tokenName, CodeGenerator gen) {\n    if (tokenName.charAt(0) == '\\'') {\n        boolean addQuotes = false;\n        tokenName = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, addQuotes);\n        return \"\\\"'\" + tokenName + \"'\\\"\";\n    }\n    return gen.target.getTargetStringLiteralFromString(tokenName, true);\n}\n\nprivate ActionText initializeSuperClass(Grammar g) {\n    String superClassOption = g.getOptionString(\"superClass\");\n    return (superClassOption != null) ? new ActionText(null, superClassOption) : new DefaultLexerSuperClass();\n}\n```",
        "InstrucCode": "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    \n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n    \n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n    \n    tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator(); // Moved this line up for better initialization\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        \n        if (tokenNames[i].charAt(0) == '\\'') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\"'\" + tokenNames[i] + \"'\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n    \n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```",
        "FewShotCode": "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    \n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        if (tokenNames[i].charAt(0) == '\\'') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\"'\" + tokenNames[i] + \"'\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```",
        "ContextCode": "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file;\n    Grammar grammar = factory.getGrammar();\n    this.grammarFileName = extractFileName(grammar.fileName);\n    this.name = grammar.getRecognizerName();\n    this.tokens = initializeTokens(grammar);\n    this.tokenNames = generateTokenNames(grammar);\n    this.ruleNames = grammar.rules.keySet();\n    this.superClass = determineSuperClass(grammar);\n    this.atn = new SerializedATN(factory, (LexerGrammar) grammar.atn);\n    this.modes = ((LexerGrammar) grammar).modes.keySet();\n}\n\nprivate String extractFileName(String filePath) {\n    return new File(filePath).getName();\n}\n\nprivate Map<String, Integer> initializeTokens(Grammar grammar) {\n    Map<String, Integer> tokenMap = new LinkedHashMap<>();\n    for (String tokenName : grammar.tokenNameToTypeMap.keySet()) {\n        Integer tokenType = grammar.tokenNameToTypeMap.get(tokenName);\n        if (tokenType > 0) {\n            tokenMap.put(tokenName, tokenType);\n        }\n    }\n    return tokenMap;\n}\n\nprivate String[] generateTokenNames(Grammar grammar) {\n    String[] tokenNames = grammar.getTokenDisplayNames();\n    CodeGenerator codeGenerator = factory.getGenerator();\n    \n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] != null) {\n            tokenNames[i] = formatTokenName(tokenNames[i], codeGenerator);\n        }\n    }\n    return tokenNames;\n}\n\nprivate String formatTokenName(String tokenName, CodeGenerator codeGenerator) {\n    if (tokenName.charAt(0) == '\\'') {\n        String formattedName = codeGenerator.target.getTargetStringLiteralFromANTLRStringLiteral(codeGenerator, tokenName, false);\n        return \"\\\"'\" + formattedName + \"'\\\"\";\n    } else {\n        return codeGenerator.target.getTargetStringLiteralFromString(tokenName, true);\n    }\n}\n\nprivate ActionText determineSuperClass(Grammar grammar) {\n    String superClassName = grammar.getOptionString(\"superClass\");\n    return (superClassName != null) ? new ActionText(null, superClassName) : new DefaultLexerSuperClass();\n}\n```",
        "RulesCode": "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        tokenNames[i] = (tokenNames[i].charAt(0) == '\\'')\n            ? gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], false).replaceFirst(\"^\", \"\\\"'\").concat(\"'\\\"\")\n            : gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n    }\n    \n    ruleNames = g.rules.keySet();\n\n    superClass = (g.getOptionString(\"superClass\") != null) \n        ? new ActionText(null, g.getOptionString(\"superClass\")) \n        : new DefaultLexerSuperClass();\n}\n```"
    },
    "L2093": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\tATNState s;\n\t\tswitch (type) {\n\t\t\tcase ATNState.INVALID_TYPE: return null;\n\t\t\tcase ATNState.BASIC : s = new BasicState(); break;\n\t\t\tcase ATNState.RULE_START : s = new RuleStartState(); break;\n\t\t\tcase ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n\t\t\tcase ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n\t\t\tcase ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n\t\t\tcase ATNState.TOKEN_START : s = new TokensStartState(); break;\n\t\t\tcase ATNState.RULE_STOP : s = new RuleStopState(); break;\n\t\t\tcase ATNState.BLOCK_END : s = new BlockEndState(); break;\n\t\t\tcase ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n\t\t\tcase ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n\t\t\tcase ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n\t\t\tcase ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n\t\t\t\tString message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\n\t\ts.ruleIndex = ruleIndex;\n\t\treturn s;\n\t}",
        "AfterRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\treturn new ATNDeserializer().stateFactory(type, ruleIndex);\n\t}",
        "ZeroShotCode": "```java\npublic static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState s = createState(type);\n    if (s == null) {\n        String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n        throw new IllegalArgumentException(message);\n    }\n    s.ruleIndex = ruleIndex;\n    return s;\n}\n\nprivate static ATNState createState(int type) {\n    switch (type) {\n        case ATNState.INVALID_TYPE: return null;\n        case ATNState.BASIC: return new BasicState();\n        case ATNState.RULE_START: return new RuleStartState();\n        case ATNState.BLOCK_START: return new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n        case ATNState.TOKEN_START: return new TokensStartState();\n        case ATNState.RULE_STOP: return new RuleStopState();\n        case ATNState.BLOCK_END: return new BlockEndState();\n        case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n        case ATNState.LOOP_END: return new LoopEndState();\n        default: return null;\n    }\n}\n```",
        "InstrucCode": "```java\npublic class StateFactoryCommand {\n    private int type;\n    private int ruleIndex;\n\n    public StateFactoryCommand(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}\n\n// Forwarding function\npublic static ATNState stateFactory(int type, int ruleIndex) {\n    return new StateFactoryCommand(type, ruleIndex).execute();\n}\n```",
        "FewShotCode": "```java\npublic static class StateFactory {\n    private int type;\n    private int ruleIndex;\n    private ATNState result;\n\n    public StateFactory(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        switch (type) {\n            case ATNState.INVALID_TYPE: \n                return null;\n            case ATNState.BASIC: \n                result = new BasicState(); \n                break;\n            case ATNState.RULE_START: \n                result = new RuleStartState(); \n                break;\n            case ATNState.BLOCK_START: \n                result = new BasicBlockStartState(); \n                break;\n            case ATNState.PLUS_BLOCK_START: \n                result = new PlusBlockStartState(); \n                break;\n            case ATNState.STAR_BLOCK_START: \n                result = new StarBlockStartState(); \n                break;\n            case ATNState.TOKEN_START: \n                result = new TokensStartState(); \n                break;\n            case ATNState.RULE_STOP: \n                result = new RuleStopState(); \n                break;\n            case ATNState.BLOCK_END: \n                result = new BlockEndState(); \n                break;\n            case ATNState.STAR_LOOP_BACK: \n                result = new StarLoopbackState(); \n                break;\n            case ATNState.STAR_LOOP_ENTRY: \n                result = new StarLoopEntryState(); \n                break;\n            case ATNState.PLUS_LOOP_BACK: \n                result = new PlusLoopbackState(); \n                break;\n            case ATNState.LOOP_END: \n                result = new LoopEndState(); \n                break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        result.ruleIndex = ruleIndex;\n        return result;\n    }\n}\n\n// Usage\npublic static ATNState stateFactory(int type, int ruleIndex) {\n    return new StateFactory(type, ruleIndex).execute();\n}\n```",
        "ContextCode": "```java\npublic static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState state = createState(type);\n    if (state == null) {\n        String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n        throw new IllegalArgumentException(message);\n    }\n    state.ruleIndex = ruleIndex;\n    return state;\n}\n\nprivate static ATNState createState(int type) {\n    switch (type) {\n        case ATNState.INVALID_TYPE: return null;\n        case ATNState.BASIC: return new BasicState();\n        case ATNState.RULE_START: return new RuleStartState();\n        case ATNState.BLOCK_START: return new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n        case ATNState.TOKEN_START: return new TokensStartState();\n        case ATNState.RULE_STOP: return new RuleStopState();\n        case ATNState.BLOCK_END: return new BlockEndState();\n        case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n        case ATNState.LOOP_END: return new LoopEndState();\n        default: return null;\n    }\n}\n```",
        "RulesCode": "```java\npublic static ATNState stateFactory(int type, int ruleIndex) {\n    return StateFactory.createState(type, ruleIndex);\n}\n\nclass StateFactory {\n    public static ATNState createState(int type, int ruleIndex) {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}\n```"
    },
    "L2083": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\tATNState target = atn.states.get(trg);\n\t\tswitch (type) {\n\t\t\tcase Transition.EPSILON : return new EpsilonTransition(target);\n\t\t\tcase Transition.RANGE :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase Transition.RULE :\n\t\t\t\tRuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n\t\t\t\treturn rt;\n\t\t\tcase Transition.PREDICATE :\n\t\t\t\tPredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn pt;\n\t\t\tcase Transition.ATOM :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase Transition.ACTION :\n\t\t\t\tActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn a;\n\t\t\tcase Transition.SET : return new SetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.WILDCARD : return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"The specified transition type is not valid.\");\n\t}",
        "AfterRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\treturn new ATNDeserializer().edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets);\n\t}",
        "ZeroShotCode": "```java\npublic static Transition edgeFactory(@NotNull ATN atn,\n                                     int type, int src, int trg,\n                                     int arg1, int arg2, int arg3,\n                                     List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    Transition transition;\n    \n    switch (type) {\n        case Transition.EPSILON:\n            transition = new EpsilonTransition(target);\n            break;\n        case Transition.RANGE:\n            transition = (arg3 != 0) \n                ? new RangeTransition(target, Token.EOF, arg2) \n                : new RangeTransition(target, arg1, arg2);\n            break;\n        case Transition.RULE:\n            transition = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n            break;\n        case Transition.PREDICATE:\n            transition = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.ATOM:\n            transition = (arg3 != 0) \n                ? new AtomTransition(target, Token.EOF) \n                : new AtomTransition(target, arg1);\n            break;\n        case Transition.ACTION:\n            transition = new ActionTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.SET:\n            transition = new SetTransition(target, sets.get(arg1));\n            break;\n        case Transition.NOT_SET:\n            transition = new NotSetTransition(target, sets.get(arg1));\n            break;\n        case Transition.WILDCARD:\n            transition = new WildcardTransition(target);\n            break;\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n    \n    return transition;\n}\n```",
        "InstrucCode": "```java\npublic class TransitionCommand {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public TransitionCommand(ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}\n\n// Forwarding function\npublic static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    TransitionCommand command = new TransitionCommand(atn, type, src, trg, arg1, arg2, arg3, sets);\n    return command.execute();\n}\n```",
        "FewShotCode": "```java\npublic static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    return new EdgeCreator(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n}\n\nclass EdgeCreator {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    EdgeCreator(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON:\n                return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET:\n                return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET:\n                return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD:\n                return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}\n```",
        "ContextCode": "```java\npublic static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    \n    switch (type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return new RangeTransition(target, arg3 != 0 ? Token.EOF : arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.ATOM:\n            return new AtomTransition(target, arg3 != 0 ? Token.EOF : arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.SET:\n            return new SetTransition(target, sets.get(arg1));\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets.get(arg1));\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}\n```",
        "RulesCode": "```java\npublic static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    TransitionFactory factory = new TransitionFactory(target, arg1, arg2, arg3, sets);\n\n    return factory.createTransition(type);\n}\n\nclass TransitionFactory {\n    private final ATNState target;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    TransitionFactory(ATNState target, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.target = target;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    Transition createTransition(int type) {\n        switch (type) {\n            case Transition.EPSILON:\n                return new EpsilonTransition(target);\n            case Transition.RANGE:\n                return arg3 != 0 ? new RangeTransition(target, Token.EOF, arg2) \n                                 : new RangeTransition(target, arg1, arg2);\n            case Transition.RULE:\n                return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n            case Transition.PREDICATE:\n                return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n            case Transition.ATOM:\n                return arg3 != 0 ? new AtomTransition(target, Token.EOF) \n                                 : new AtomTransition(target, arg1);\n            case Transition.ACTION:\n                return new ActionTransition(target, arg1, arg2, arg3 != 0);\n            case Transition.SET:\n                return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET:\n                return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD:\n                return new WildcardTransition(target);\n            default:\n                throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n        }\n    }\n}\n```"
    },
    "L2079": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\tlong leastSigBits = toLong(data, offset);\n\t\tlong mostSigBits = toLong(data, offset + 4);\n\t\treturn new UUID(mostSigBits, leastSigBits);\n\t}",
        "AfterRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\treturn ATNDeserializer.toUUID(data, offset);\n\t}",
        "ZeroShotCode": "```java\npublic static UUID toUUID(char[] data, int offset) {\n    return new UUID(toLong(data, offset + 4), toLong(data, offset));\n}\n```",
        "InstrucCode": "```java\nimport java.util.UUID;\n\npublic class UUIDCommand {\n    private char[] data;\n    private int offset;\n\n    public UUIDCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Assuming implementation of converting char[] to long is here\n    }\n}\n\n// Forwarding function\npublic static UUID toUUID(char[] data, int offset) {\n    return new UUIDCommand(data, offset).execute();\n}\n```",
        "FewShotCode": "```java\nimport java.util.UUID;\n\npublic class UUIDConverter {\n    private char[] data;\n    private int offset;\n    private long leastSigBits;\n    private long mostSigBits;\n    private UUID uuid;\n\n    public UUIDConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public UUID execute() {\n        leastSigBits = toLong(data, offset);\n        mostSigBits = toLong(data, offset + 4);\n        uuid = new UUID(mostSigBits, leastSigBits);\n        return uuid;\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implementation of toLong method (not provided in original code)\n        return 0; // Placeholder return value\n    }\n}\n```",
        "ContextCode": "```java\npublic static UUID toUUID(char[] data, int offset) {\n    long leastSignificantBits = toLong(data, offset);\n    long mostSignificantBits = toLong(data, offset + 4);\n    return new UUID(mostSignificantBits, leastSignificantBits);\n}\n```",
        "RulesCode": "```java\npublic static UUID toUUID(char[] data, int offset) {\n    long leastSigBits = UUIDConverter.toLong(data, offset);\n    long mostSigBits = UUIDConverter.toLong(data, offset + 4);\n    return new UUID(mostSigBits, leastSigBits);\n}\n\nclass UUIDConverter {\n    public static long toLong(char[] data, int offset) {\n        // Implementation of toLong method\n    }\n}\n```"
    },
    "L2075": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static long toLong(char[] data, int offset) {\n\t\tlong lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n\t\treturn lowOrder | ((long)toInt32(data, offset + 2) << 32);\n\t}",
        "AfterRefact": "public static long toLong(char[] data, int offset) {\n\t\treturn ATNDeserializer.toLong(data, offset);\n\t}",
        "ZeroShotCode": "```java\npublic static long toLong(char[] data, int offset) {\n    return ((long) toInt32(data, offset) & 0x00000000FFFFFFFFL) \n           | ((long) toInt32(data, offset + 2) << 32);\n}\n```",
        "InstrucCode": "```java\npublic class ToLongCommand {\n    private char[] data;\n    private int offset;\n\n    public ToLongCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Assuming the implementation of toInt32 is present here\n    }\n}\n\n// Forwarding function\npublic static long toLong(char[] data, int offset) {\n    return new ToLongCommand(data, offset).execute();\n}\n```",
        "FewShotCode": "```java\npublic class LongConverter {\n    private char[] data;\n    private int offset;\n    private long result;\n    private int lowOrder;\n    private int highOrder;\n\n    public LongConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long execute() {\n        this.lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        this.highOrder = toInt32(data, offset + 2);\n        this.result = lowOrder | ((long)highOrder << 32);\n        return result;\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Implementation of converting char[] to int (not provided in the original code)\n        return 0; // Placeholder for the actual implementation\n    }\n}\n\n// Usage\nlong value = new LongConverter(data, offset).execute();\n```",
        "ContextCode": "```java\npublic static long toLong(char[] data, int offset) {\n    int lowOrderPart = toInt32(data, offset);\n    int highOrderPart = toInt32(data, offset + 2);\n    \n    return ((long) highOrderPart << 32) | (lowOrderPart & 0xFFFFFFFFL);\n}\n```",
        "RulesCode": "```java\npublic static long toLong(char[] data, int offset) {\n    long lowOrder = newToInt32(data, offset) & 0x00000000FFFFFFFFL;\n    return lowOrder | ((long)newToInt32(data, offset + 2) << 32);\n}\n\nprivate static int newToInt32(char[] data, int offset) {\n    // original implementation of toInt32\n}\n```"
    },
    "L1276": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\t// share same graph if both same\n\t\tif ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "AfterRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\tassert a!=null && b!=null; // must be empty context, never null\n\n\t\t// share same graph if both same\n\t\tif ( a==b || a.equals(b) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "ZeroShotCode": "```java\npublic static PredictionContext merge(\n    PredictionContext a, PredictionContext b,\n    boolean rootIsWildcard,\n    DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    \n    if ((a == null && b == null) || a == b || (a != null && a.equals(b))) {\n        return a;\n    }\n\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons((SingletonPredictionContext) a,\n                               (SingletonPredictionContext) b,\n                               rootIsWildcard, mergeCache);\n    }\n\n    if (rootIsWildcard) {\n        if (a instanceof EmptyPredictionContext) return a;\n        if (b instanceof EmptyPredictionContext) return b;\n    }\n\n    a = convertIfSingleton(a);\n    b = convertIfSingleton(b);\n\n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                       rootIsWildcard, mergeCache);\n}\n\nprivate static PredictionContext convertIfSingleton(PredictionContext context) {\n    if (context instanceof SingletonPredictionContext) {\n        return new ArrayPredictionContext((SingletonPredictionContext) context);\n    }\n    return context;\n}\n```",
        "InstrucCode": "```java\npublic class MergePredictionContextCommand {\n    private PredictionContext a;\n    private PredictionContext b;\n    private boolean rootIsWildcard;\n    private DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n\n    public MergePredictionContextCommand(PredictionContext a, PredictionContext b, \n                                         boolean rootIsWildcard, \n                                         DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a,\n                                   (SingletonPredictionContext) b,\n                                   rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                           rootIsWildcard, mergeCache);\n    }\n\n    // Forwarding function\n    public static PredictionContext merge(PredictionContext a, PredictionContext b,\n                                          boolean rootIsWildcard,\n                                          DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        return new MergePredictionContextCommand(a, b, rootIsWildcard, mergeCache).execute();\n    }\n}\n```",
        "FewShotCode": "```java\npublic static PredictionContext merge(PredictionContext a, PredictionContext b,\n                                       boolean rootIsWildcard,\n                                       DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    return new Merger(a, b, rootIsWildcard, mergeCache).execute();\n}\n\nclass Merger {\n    private PredictionContext a;\n    private PredictionContext b;\n    private boolean rootIsWildcard;\n    private DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n    private PredictionContext result;\n\n    Merger(PredictionContext a, PredictionContext b, boolean rootIsWildcard,\n           DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b,\n                                   rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                           rootIsWildcard, mergeCache);\n    }\n}\n```",
        "ContextCode": "```java\npublic static PredictionContext merge(\n        PredictionContext a, PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    \n    if ((a == null && b == null) || a == b || (a != null && a.equals(b))) {\n        return a;\n    }\n\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons((SingletonPredictionContext) a,\n                               (SingletonPredictionContext) b,\n                               rootIsWildcard, mergeCache);\n    }\n\n    if (rootIsWildcard) {\n        if (a instanceof EmptyPredictionContext) return a;\n        if (b instanceof EmptyPredictionContext) return b;\n    }\n\n    if (a instanceof SingletonPredictionContext) {\n        a = new ArrayPredictionContext((SingletonPredictionContext) a);\n    }\n    \n    if (b instanceof SingletonPredictionContext) {\n        b = new ArrayPredictionContext((SingletonPredictionContext) b);\n    }\n    \n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                       rootIsWildcard, mergeCache);\n}\n```",
        "RulesCode": "```java\npublic static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache) {\n\t\n\t// share same graph if both same\n\tif ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;\n\n\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}\n\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\tif ( rootIsWildcard ) {\n\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t}\n\n\t// convert singleton so both are arrays to normalize\n\tif ( a instanceof SingletonPredictionContext ) {\n\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t}\n\tif ( b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t}\n\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t   rootIsWildcard, mergeCache);\n}\n```"
    },
    "L7856": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n        boolean useIdentity = true; // compare node identity\n\t\tthis.treeLayout =\n\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(tree),\n\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n                                 useIdentity);\n\t\tupdatePreferredSize();\n\t\tsetFont(font);\n\t}",
        "AfterRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetRuleNames(ruleNames);\n\t\tif ( tree!=null ) {\n\t\t\tsetTree(tree);\n\t\t}\n\t\tsetFont(font);\n\t}\n\npublic void setTree(Tree root) {\n\t\tif ( root!=null ) {\n\t\t\tboolean useIdentity = true; // compare node identity\n\t\t\tthis.treeLayout =\n\t\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(root),\n\t\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n\t\t\t\t\t\t\t\t\t useIdentity);\n\t\t\t// Let the UI display this new AST.\n\t\t\tupdatePreferredSize();\n\t\t}\n\t\telse {\n\t\t\tthis.treeLayout = null;\n\t\t\trepaint();\n\t\t}\n\t}\npublic void setRuleNames(List<String> ruleNames) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n\t}",
        "ZeroShotCode": "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(createTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\nprivate DefaultTreeTextProvider createTreeTextProvider(@Nullable List<String> ruleNames) {\n    return new DefaultTreeTextProvider(ruleNames);\n}\n\nprivate TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}\n```",
        "InstrucCode": "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\nprivate TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}\n```",
        "FewShotCode": "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = createTreeLayout(tree, useIdentity);\n    updatePreferredSize();\n    setFont(font);\n}\n\nprivate TreeLayout<Tree> createTreeLayout(Tree tree, boolean useIdentity) {\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}\n```",
        "ContextCode": "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n\n    boolean useIdentity = true;\n    TreeLayout<Tree> treeLayout = new TreeLayout<>(\n        new TreeLayoutAdaptor(tree),\n        new VariableExtentProvider(this),\n        new DefaultConfiguration<>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n\n    updatePreferredSize();\n    setFont(font);\n}\n```",
        "RulesCode": "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    initializeTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\nprivate void initializeTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}\n```"
    },
    "L3524": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tsuper(ruleStart);\n\n\t\tthis.ruleIndex = ruleIndex;\n\n\t\tthis.followState = followState;\n\n\t}",
        "AfterRefact": "public RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tthis(ruleStart, ruleIndex, 0, followState);\n\n\t}",
        "ZeroShotCode": "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex) {\n    this(ruleStart, ruleIndex, null);\n}\n\npublic RuleTransition(@NotNull RuleStartState ruleStart, @NotNull ATNState followState) {\n    this(ruleStart, -1, followState);\n}\n```",
        "InstrucCode": "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    final int newRuleIndex = ruleIndex;\n    this.ruleIndex = newRuleIndex;\n    this.followState = followState;\n}\n```",
        "FewShotCode": "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```",
        "ContextCode": "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```",
        "RulesCode": "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
    },
    "L2447": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = input.getLine(); // Assuming line and charPos are now retrieved from input\n    this.charPositionInLine = input.getCharPositionInLine(); // Assuming updated to get from input\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // other parameters removed for simplification\n    int index = getCurrentIndex(); // Assume this method retrieves the current index\n    int line = getCurrentLine(); // Assume this method retrieves the current line number\n    int charPos = getCurrentCharPosition(); // Assume this method retrieves the current character position\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void acceptAction(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t    int index, int line, int charPos)\n{\n\tif ( debug ) {\n\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t}\n\n\tif ( actionIndex >= 0 && recog != null ) recog.action(null, ruleIndex, actionIndex);\n\n\tinput.seek(index);\n\tthis.line = line;\n\tthis.charPositionInLine = charPos;\n\tif (input.LA(1) != IntStream.EOF) {\n\t\tconsume(input);\n\t}\n}\n```",
        "ContextCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logDebugAction(ruleIndex, actionIndex);\n    \n    executeActionIfNeeded(actionIndex, ruleIndex);\n\n    updatePosition(input, index, line, charPos);\n}\n\nprivate void logDebugAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        String ruleName = (recog != null) ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", ruleName, actionIndex);\n    }\n}\n\nprivate void executeActionIfNeeded(int actionIndex, int ruleIndex) {\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n}\n\nprivate void updatePosition(CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "RulesCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int line, int charPos) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```"
    },
    "L24470": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = input.getLine();  // assuming line and charPositionInLine are stored in input\n    this.charPositionInLine = input.getCharPositionInLine(); // assuming charPos is replaced with a method to get this value\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = input.getLine();\n    this.charPositionInLine = input.getCharPositionInLine();\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void acceptAction(@NotNull CharStream input, int ruleIndex, int actionIndex,\n                            int index, int line, int charPos) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "ContextCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n\n    executeAction(actionIndex, ruleIndex);\n    \n    updatePosition(input, index, line, charPos);\n}\n\nprivate void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        String ruleName = (recog != null) ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d%n\", ruleName, actionIndex);\n    }\n}\n\nprivate void executeAction(int actionIndex, int ruleIndex) {\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n}\n\nprivate void updatePosition(CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```",
        "RulesCode": "```java\nprotected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int line, int charPos) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}\n```"
    },
    "L2288": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t  DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t  @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t  @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t  ParserRuleContext outerContext,\n\t\t\t\t\t\t\t\t\t  int SLL_min_alt) // todo: is this in D as min ambig alts?\n\t{\n\t\t// caller must have write lock on dfa\n\t\tretry_with_context++;\n\t\treportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\tretry_with_context_indicates_no_conflict++;\n\t\t\treportContextSensitivity(dfa, reach, startIndex, input.index());\n\t\t\tif ( predictedAlt == SLL_min_alt ) {\n\t\t\t\tretry_with_context_predicts_same_alt++;\n\t\t\t}\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\tif ( foundExactAmbig ) {\n\t\t\treportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n\t\t}\n\n\t\treturn predictedAlt;\n\t}",
        "AfterRefact": "protected int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t\t DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t\t @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t\t ParserRuleContext outerContext)\n\t{\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\treportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index());\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\treportAmbiguity(dfa, D, startIndex, input.index(), foundExactAmbig, null, reach);\n\n\t\treturn predictedAlt;\n\t}",
        "ZeroShotCode": "```java\npublic int execATNWithFullContext(DFA dfa,\n                                   DFAState D, \n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    \n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        reach.uniqueAlt = getUniqueAlt(reach);\n        \n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}\n```",
        "InstrucCode": "```java\npublic int execATNWithFullContext(DFA dfa,\n                                    DFAState D, // how far we got before failing over\n                                    @NotNull ATNConfigSet s0,\n                                    @NotNull TokenStream input, \n                                    int startIndex,\n                                    ParserRuleContext outerContext,\n                                    int SLL_min_alt) // todo: is this in D as min ambig alts?\n{\n    // caller must have write lock on dfa\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) { // while more work\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}\n```",
        "FewShotCode": "```java\npublic int executeATNWithFullContext(DFA dfa,\n                                      DFAState D, // how far we got before failing over\n                                      @NotNull ATNConfigSet s0,\n                                      @NotNull TokenStream input, int startIndex,\n                                      ParserRuleContext outerContext,\n                                      int SLL_min_alt) // todo: is this in D as min ambig alts?\n{\n    // caller must have write lock on dfa\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"executeATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) { // while more work\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}\n```",
        "ContextCode": "```java\npublic int execATNWithFullContext(DFA dfa,\n                                   DFAState state,\n                                   @NotNull ATNConfigSet initialConfigSet,\n                                   @NotNull TokenStream input,\n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int minAlternative) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, initialConfigSet, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + initialConfigSet);\n    }\n\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = initialConfigSet;\n\n    input.seek(startIndex);\n    int currentToken = input.LA(1);\n    int predictedAlt;\n\n    while (true) {\n        reach = computeReachSet(previous, currentToken, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                    \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                    \", resolvesToJustOneViableAlt=\" +\n                    PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                    PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (currentToken != IntStream.EOF) {\n            input.consume();\n            currentToken = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == minAlternative) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, state, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}\n```",
        "RulesCode": "```java\npublic int execATNWithFullContext(DFA dfa,\n                                   DFAState D, \n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex) {\n    // caller must have write lock on dfa\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) { // while more work\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}\n```"
    },
    "L2588": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "protected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n\t\treturn 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n\t}",
        "AfterRefact": "protected static int calculateHashCode(PredictionContext parent, int returnState) {\n\t\tint hash = MurmurHash.initialize(INITIAL_HASH);\n\t\thash = MurmurHash.update(hash, parent);\n\t\thash = MurmurHash.update(hash, returnState);\n\t\thash = MurmurHash.finish(hash, 2);\n\t\treturn hash;\n\t}",
        "ZeroShotCode": "```java\nprotected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return 175 + 5 * parentHashCode + returnStateHashCode;\n}\n```",
        "InstrucCode": "```java\npublic class CalculateHashCodeCommand {\n    private final int parentHashCode;\n    private final int returnStateHashCode;\n\n    public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}\n\n// Forwarding function\nprotected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return new CalculateHashCodeCommand(parentHashCode, returnStateHashCode).execute();\n}\n```",
        "FewShotCode": "```java\npublic class HashCodeCalculator {\n    private int parentHashCode;\n    private int returnStateHashCode;\n    private int result;\n\n    public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        this.result = calculateHashCode();\n        return this.result;\n    }\n\n    private int calculateHashCode() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}\n```",
        "ContextCode": "```java\nprotected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    final int prime1 = 25; // 5 * 5\n    final int prime2 = 5;\n    final int prime3 = 7;\n\n    return prime1 + (prime2 * parentHashCode) + returnStateHashCode;\n}\n```",
        "RulesCode": "```java\nprotected static class HashCodeCalculator {\n    private static final int MULTIPLIER1 = 5;\n    private static final int MULTIPLIER2 = 7;\n\n    public int calculate(int parentHashCode, int returnStateHashCode) {\n        return MULTIPLIER1 * MULTIPLIER1 * MULTIPLIER2 + MULTIPLIER1 * parentHashCode + returnStateHashCode;\n    }\n}\n\n// Usage\nHashCodeCalculator hashCodeCalculator = new HashCodeCalculator();\nint hashCode = hashCodeCalculator.calculate(parentHashCode, returnStateHashCode);\n```"
    },
    "L3072": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "AfterRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "ZeroShotCode": "```java\npublic void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}\n```",
        "InstrucCode": "```java\npublic void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex) {\n    // implementation here\n}\n```",
        "FewShotCode": "```java\npublic void reportContextSensitivity(Parser recognizer,\n                                      DFA dfa,\n                                      int startIndex,\n                                      int stopIndex,\n                                      ATNConfigSet configs) {\n}\n```",
        "ContextCode": "```java\npublic void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}\n```",
        "RulesCode": "```java\npublic void reportContextSensitivity(Parser recognizer,\n                                        DFA dfa,\n                                        int startIndex,\n                                        int stopIndex) {\n}\n```"
    },
    "L5418": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t\t_ctx.altNum = altNum;\n\t}",
        "AfterRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t}",
        "ZeroShotCode": "```java\npublic void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    updateParseTree(localctx);\n    updateContext(localctx, altNum);\n}\n\nprivate void updateParseTree(ParserRuleContext localctx) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n}\n\nprivate void updateContext(ParserRuleContext localctx, int altNum) {\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}\n```",
        "InstrucCode": "```java\npublic void enterOuterAlt(ParserRuleContext newLocalctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != newLocalctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(newLocalctx);\n        }\n    }\n    _ctx = newLocalctx;\n    int newAltNum = altNum;\n    _ctx.altNum = newAltNum;\n}\n```",
        "FewShotCode": "```java\npublic void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    int newAltNum = altNum;\n    _ctx.altNum = newAltNum;\n}\n```",
        "ContextCode": "```java\npublic void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}\n```",
        "RulesCode": "```java\npublic void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    setAltNum(localctx, altNum);\n}\n\nprivate void setAltNum(ParserRuleContext localctx, int altNum) {\n    localctx.altNum = altNum;\n}\n```"
    },
    "L3446": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "AfterRefact": "protected Token singleTokenDeletion(@NotNull Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\treportMatch(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}\npublic void reportMatch(Parser recognizer) {\n\t\tendErrorCondition(recognizer);\n\t}",
        "ZeroShotCode": "```java\npublic Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // simply delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}\n```",
        "InstrucCode": "```java\npublic Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        Token matchedSymbol = deleteExtraToken(recognizer);\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}\n\nprivate Token deleteExtraToken(Parser recognizer) {\n    recognizer.consume(); // simply delete extra token\n    return recognizer.getCurrentToken(); // return the token we're actually matching\n}\n```",
        "FewShotCode": "```java\npublic Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    \n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        Token matchedSymbol = handleTokenDeletion(recognizer);\n        endErrorCondition(recognizer);  \n        return matchedSymbol;\n    }\n    return null;\n}\n\nprivate Token handleTokenDeletion(Parser recognizer) {\n    recognizer.consume(); // simply delete extra token\n    return recognizer.getCurrentToken(); // return the token we're actually matching\n}\n```",
        "ContextCode": "```java\npublic Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expectedTokens = getExpectedTokens(recognizer);\n\n    if (expectedTokens.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); // current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}\n```",
        "RulesCode": "```java\npublic Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleUnexpectedToken(recognizer);\n        return recognizer.getCurrentToken();\n    }\n    return null;\n}\n\nprivate void handleUnexpectedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    recognizer.consume(); // simply delete extra token\n    endErrorCondition(recognizer);  // we know current token is correct\n}\n```"
    },
    "L3949": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public TheoryAnchor(FrameworkMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}",
        "AfterRefact": "public TheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tfTestMethod= method;\n            fTestClass= testClass;\n\t\t}",
        "ZeroShotCode": "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```",
        "InstrucCode": "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    fTestMethod = method;\n}\n```",
        "FewShotCode": "```java\npublic TheoryAnchor(FrameworkMethod testMethod) {\n    fTestMethod = testMethod;\n}\n```",
        "ContextCode": "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```",
        "RulesCode": "```java\npublic TheoryAnchor(FrameworkMethod fTestMethod) {\n    this.fTestMethod = fTestMethod;\n}\n```"
    },
    "L8052": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public StubbedTheoryAnchor(FrameworkMethod method) {\n\t\t\tsuper(method);\n\t\t}",
        "AfterRefact": "public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tsuper(method, testClass);\n\t\t}",
        "ZeroShotCode": "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```",
        "InstrucCode": "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, SomeNewType newParameter) {\n    super(method);\n    // handle new parameter if necessary\n}\n```",
        "FewShotCode": "```java\npublic StubbedTheoryAnchor(FrameworkMethod frameworkMethod) {\n    super(frameworkMethod);\n}\n```",
        "ContextCode": "```java\npublic class StubbedTheoryAnchor extends SomeSuperclass {\n    public StubbedTheoryAnchor(FrameworkMethod method) {\n        super(method);\n    }\n}\n```",
        "RulesCode": "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, Object addedParam) {\n    super(method, addedParam);\n}\n```"
    },
    "L4884": {
        "RefactMethod": "INLINE VARIABLE",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}",
        "ZeroShotCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n```",
        "InstrucCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n```",
        "FewShotCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n```",
        "ContextCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(each);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}\n```",
        "RulesCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n```"
    },
    "L5882": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "ZeroShotCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    executeMethodBlock(method, eachNotifier);\n}\n\nprivate boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}\n\nprivate void executeMethodBlock(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    runTestMethod(method, eachNotifier);\n}\n\nprivate void runTestMethod(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeMethodBlock(method);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n\nprivate void executeMethodBlock(FrameworkMethod method) throws Throwable {\n    methodBlock(method).evaluate();\n}\n```",
        "ContextCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}\n\nprivate boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}\n\nprivate void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```",
        "RulesCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    executeMethod(method, eachNotifier);\n}\n\nprivate void executeMethod(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```"
    },
    "L5880": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\n\n\tprivate void runIgnored(EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestIgnored();\n\t}",
        "ZeroShotCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        runTest(method, eachNotifier);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n\nprivate boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}\n\nprivate void runTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    }\n}\n```",
        "InstrucCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    runTest(eachNotifier, method);\n}\n\nprivate void runTest(EachTestNotifier eachNotifier, FrameworkMethod method) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```",
        "FewShotCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        runTest(method, eachNotifier);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n\nprivate void runTest(FrameworkMethod method, EachTestNotifier eachNotifier) throws Throwable {\n    methodBlock(method).evaluate();\n}\n```",
        "ContextCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}\n\nprivate boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}\n\nprivate void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```",
        "RulesCode": "```java\nprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}\n\nprivate void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}\n```"
    },
    "L4889": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}\n\n\tprivate void addMultipleFailureException(MultipleFailureException mfe) {\n\t\tfor (Throwable each : mfe.getFailures())\n\t\t\taddFailure(each);\n\t}",
        "ZeroShotCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n    } else {\n        fireTestFailure(targetException);\n    }\n}\n\nprivate void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}\n\nprivate void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n```",
        "InstrucCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n\nprivate void handleMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}\n```",
        "FewShotCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n    } else {\n        fireTestFailure(targetException);\n    }\n}\n\nprivate void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}\n\nprivate void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n```",
        "ContextCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(each);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}\n```",
        "RulesCode": "```java\npublic void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailure((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}\n\nprivate void handleMultipleFailure(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}\n```"
    },
    "L7126": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t}",
        "AfterRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t\tassertEquals(2, result.getRunCount());\n\t}",
        "ZeroShotCode": "```java\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertSuccessfulResult(result);\n}\n\nprivate void assertSuccessfulResult(Result result) {\n    assertTrue(result.wasSuccessful());\n}\n```",
        "InstrucCode": "```java\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    // Assertion to ensure that the category filter is correctly set\n    assertNotNull(include);\n    \n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    \n    // Assertion to ensure that the result was successful\n    assertTrue(result.wasSuccessful());\n}\n```",
        "FewShotCode": "```java\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    assert(include != null); // Assertion added to ensure include is not null\n    \n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}\n```",
        "ContextCode": "```java\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}\n```",
        "RulesCode": "```java\npublic void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n    assertEquals(\"Expected successful test count\", expectedCount, result.getRunCount());\n}\n```"
    },
    "L126": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
        "AfterRefact": "public TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}\n\n\tprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}\n\t",
        "ZeroShotCode": "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    if (!validateConstructor(theClass) || !validatePublicClass(theClass)) {\n        return;\n    }\n    extractTestMethods(theClass);\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}\n\nprivate boolean validateConstructor(Class<? extends TestCase> theClass) {\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n        return true;\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n}\n\nprivate boolean validatePublicClass(Class<? extends TestCase> theClass) {\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return false;\n    }\n    return true;\n}\n\nprivate void extractTestMethods(Class<? extends TestCase> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n}\n```",
        "InstrucCode": "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractTestMethods(theClass);\n}\n\nprivate void extractTestMethods(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}\n```",
        "FewShotCode": "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    extractTestMethods(superClass, names, theClass);\n\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}\n\nprivate void extractTestMethods(Class<?> superClass, List<String> names, Class<? extends TestCase> theClass) {\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n}\n```",
        "ContextCode": "```java\npublic TestSuite(final Class<? extends TestCase> testCaseClass) {\n    fName = testCaseClass.getName();\n    \n    try {\n        getTestConstructor(testCaseClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + testCaseClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(testCaseClass.getModifiers())) {\n        addTest(warning(\"Class \" + testCaseClass.getName() + \" is not public\"));\n        return;\n    }\n\n    Class<?> currentClass = testCaseClass;\n    List<String> testMethodNames = new ArrayList<>();\n    \n    while (Test.class.isAssignableFrom(currentClass)) {\n        for (Method method : currentClass.getDeclaredMethods()) {\n            addTestMethod(method, testMethodNames, testCaseClass);\n        }\n        currentClass = currentClass.getSuperclass();\n    }\n    \n    if (fTests.isEmpty()) {\n        addTest(warning(\"No tests found in \" + testCaseClass.getName()));\n    }\n}\n```",
        "RulesCode": "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractMethods(theClass);\n}\n\nprivate void extractMethods(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}\n```"
    }
}