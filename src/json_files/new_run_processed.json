{
    "FOWLER_EX_PULL UP FIELD": {
        "RefactMethod": "PULL UP FIELD",
        "BeforeRefact": "class Employee {...} // Java\n\nclass Salesman extends Employee {\n  private String name;\n}\n\nclass Engineer extends Employee {\n  private String name;\n}",
        "AfterRefact": "class Employee {\n  protected String name;\n}\n\nclass Salesman extends Employee {...}\nclass Engineer extends Employee {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  protected String name;\n}",
                "class Salesman extends Employee {\n}",
                "class Engineer extends Employee {\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Employee {\n    protected String name;\n}",
                "class Salesman extends Employee {\n}",
                "class Engineer extends Employee {\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getName() {\n        return name;\n    }"
            ],
            "classes": [
                "class Employee {\n    private String name;\n\n    public Employee(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}",
                "class Salesman extends Employee {\n    public Salesman(String name) {\n        super(name);\n    }\n}",
                "class Engineer extends Employee {\n    public Engineer(String name) {\n        super(name);\n    }\n}"
            ],
            "others": [
                "```java\nabstract ",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  private String name;\n}",
                "class Salesman extends Employee {\n}",
                "class Engineer extends Employee {\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_PRESERVE WHOLE OBJECT": {
        "RefactMethod": "PRESERVE WHOLE OBJECT",
        "BeforeRefact": "const low = aRoom.daysTempRange.low;\nconst high = aRoom.daysTempRange.high;\nif (aPlan.withinRange(low, high))",
        "AfterRefact": "if (aPlan.withinRange(aRoom.daysTempRange))",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst tempRange = aRoom.daysTempRange;\nif (aPlan.withinRange(tempRange.low, tempRange.high))\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction isWithinTemperatureRange(aRoom, aPlan) {\n    const low = aRoom.daysTempRange.low;\n    const high = aRoom.daysTempRange.high;\n    return aPlan.withinRange(low, high);\n}\n\n// Example of updated usage:\nif (isWithinTemperatureRange(aRoom, aPlan)) {\n    // your code here\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst { low, high } = aRoom.daysTempRange;\nif (aPlan.withinRange(low, high)) \n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst daysTempRange = aRoom.daysTempRange;\nconst low = daysTempRange.low;\nconst high = daysTempRange.high;\nif (aPlan.withinRange(low, high))\n```"
            ]
        }
    },
    "FOWLER_EX_SPLIT PHASE": {
        "RefactMethod": "SPLIT PHASE",
        "BeforeRefact": "const orderData = orderString.split(/\\s+/);\nconst productPrice = priceList[orderData[0].split(\u201c-\u201d)[1]];\nconst orderPrice = parseInt(orderData[1]) * productPrice;",
        "AfterRefact": "const orderRecord = parseOrder(order);\nconst orderPrice = price(orderRecord, priceList);\n\nfunction parseOrder(aString) {\n  const values =  aString.split(/\\s+/);\n  return ({\n    productID: values[0].split(\u201c-\u201d)[1],\n    quantity: parseInt(values[1]),\n  });\n}\nfunction price(order, priceList) {\n  return order.quantity * priceList[order.productID];\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst orderData = splitOrderString(orderString);\nconst productPrice = getProductPrice(priceList, orderData);\nconst orderPrice = calculateOrderPrice(orderData, productPrice);\n\nfunction splitOrderString(orderString) {\n    return orderString.split(/\\\\s+/);\n}\n\nfunction getProductPrice(priceList, orderData) {\n    return priceList[orderData[0].split(\"\u2013\")[1]];\n}\n\nfunction calculateOrderPrice(orderData, productPrice) {\n    return parseInt(orderData[1]) * productPrice;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Order {\n    constructor(orderString, priceList) {\n        this.orderData = orderString.split(/\\\\s+/);\n        this.productPrice = priceList[this.orderData[0].split(\"-\")[1]];\n    }\n\n    calculateOrderPrice() {\n        return parseInt(this.orderData[1]) * this.productPrice;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n// Usage\nconst order = new Order(orderString, priceList);\nconst orderPrice = order.calculateOrderPrice();\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst [productId, quantityString] = orderString.split(/\\\\s+/);\nconst productPrice = priceList[productId.split(\"\u2013\")[1]];\nconst orderPrice = parseInt(quantityString) * productPrice;\n```"
            ]
        }
    },
    "FOWLER_EX_COLLAPSE HIERARCHY": {
        "RefactMethod": "COLLAPSE HIERARCHY",
        "BeforeRefact": "class Employee {...}\nclass Salesman extends Employee {...}",
        "AfterRefact": "class Employee {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Employee {\n    // properties and methods common to all employees\n}",
                "class Salesman extends Employee {\n    // properties and methods specific to salesmen\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Employee {\n    // Salesman specific fields and methods are now included here\n}"
            ],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Employee {\n    // Employee properties and methods\n}",
                "class Salesman extends Employee {\n    // Salesman properties and methods\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Salesman {\n    // Fields and methods from Employee class are now directly in Salesman\n}",
                "class are now directly in Salesman\n}\n```"
            ],
            "others": [
                "```java\n"
            ]
        }
    },
    "FOWLER_EX_REPLACE SUBCLASS WITH DELEGATE": {
        "RefactMethod": "REPLACE SUBCLASS WITH DELEGATE",
        "BeforeRefact": "class Order {\n  get daysToShip() {\n    return this._warehouse.daysToShip;\n  }\n}\n\nclass PriorityOrder extends Order {\n  get daysToShip() {\n    return this._priorityPlan.daysToShip;\n  }\n}",
        "AfterRefact": "class Order {\n  get daysToShip() {\n    return (this._priorityDelegate)\n      ? this._priorityDelegate.daysToShip\n      : this._warehouse.daysToShip;\n  }\n}\n\nclass PriorityOrderDelegate {\n  get daysToShip() {\n    return this._priorityPlan.daysToShip\n  }\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Order {\n  constructor(warehouse) {\n    this._warehouse = warehouse;\n  }\n\n  get daysToShip() {\n    return this._warehouse.daysToShip;\n  }\n}",
                "class PriorityOrder {\n  constructor(warehouse, priorityPlan) {\n    this._warehouse = warehouse;\n    this._priorityPlan = priorityPlan;\n  }\n\n  get daysToShip() {\n    return this._priorityPlan.daysToShip;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Order {\n  constructor(warehouse) {\n    this._warehouse = warehouse;\n    this._delegate = null; // Delegate field\n  }\n\n  get daysToShip() {\n    if (this._delegate) {\n      return this._delegate.daysToShip;\n    }\n    return this._warehouse.daysToShip;\n  }\n}",
                "class PriorityOrderDelegate {\n  constructor(priorityPlan, order) {\n    this._priorityPlan = priorityPlan;\n    this._order = order;\n  }\n\n  get daysToShip() {\n    return this._priorityPlan.daysToShip;\n  }\n}",
                "class PriorityOrder extends Order {\n  constructor(warehouse, priorityPlan) {\n    super(warehouse);\n    this._delegate = new PriorityOrderDelegate(priorityPlan, this);\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Order {\n  get daysToShip() {\n    return this._getDaysToShip();\n  }\n\n  _getDaysToShip() {\n    return this._warehouse.daysToShip;\n  }\n}",
                "class PriorityOrder extends Order {\n  _getDaysToShip() {\n    return this._priorityPlan.daysToShip;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_CHANGE REFERENCE TO VALUE": {
        "RefactMethod": "CHANGE REFERENCE TO VALUE",
        "BeforeRefact": "class Product {\n  applyDiscount(arg) {this._price.amount -= arg;}",
        "AfterRefact": "class Product {\n  applyDiscount(arg) {\n    this._price = new Money(this._price.amount - arg, this._price.currency);\n  }",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Product {\n  applyDiscount(amount) { this._price.amount -= amount; }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Product {\n  constructor(price) {\n    this._price = price;\n  }\n\n  applyDiscount(arg) {\n    this._price = new Price(this._price.amount - arg);\n  }\n}",
                "class Price {\n  constructor(amount) {\n    this.amount = amount;\n  }\n\n  equals(other) {\n    return other instanceof Price && this.amount === other.amount;\n  }\n\n  hashCode() {\n    return this.amount;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Product {\n  applyDiscount(discountAmount) {\n    this._price.amount -= discountAmount;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Product {\n  applyDiscount(arg) {\n    this._price.amount -= arg;\n  }\n}",
                "class Price {\n  constructor(amount) {\n    this.amount = amount;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\nlet product = new Product();\nproduct._price = new Price(100);\nproduct.applyDiscount(10);\n```"
            ]
        }
    },
    "FOWLER_EX_ENCAPSULATE RECORD": {
        "RefactMethod": "ENCAPSULATE RECORD",
        "BeforeRefact": "organization = {name: \u201cAcme Gooseberries\u201d, country: \u201cGB\u201d};",
        "AfterRefact": "class Organization {\n  constructor(data) {\n    this._name = data.name;\n    this._country = data.country;\n  }\n  get name()    {return this._name;}\n  set name(arg) {this._name = arg;}\n  get country()    {return this._country;}\n  set country(arg) {this._country = arg;}\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Organization {\n    constructor(name, country) {\n        this.name = name;\n        this.country = country;\n    }\n\n    getName() {\n        return this.name;\n    }\n\n    getCountry() {\n        return this.country;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nconst organization = new Organization(\"Acme Gooseberries\", \"GB\");\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Organization {\n    constructor(name, country) {\n        this._record = { name: name, country: country };\n    }\n\n    get record() {\n        return this._record;\n    }\n\n    get name() {\n        return this._record.name;\n    }\n\n    get country() {\n        return this._record.country;\n    }\n\n    // Additional methods can be added here as needed.\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n// Usage\nconst organization = new Organization(\"Acme Gooseberries\", \"GB\");\n\n// Accessing the data\nconsole.log(organization.name);    // \"Acme Gooseberries\"\nconsole.log(organization.country);  // \"GB\"\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst organization = {\n    name: \"Acme Gooseberries\",\n    country: \"GB\"\n};\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Organization {\n    constructor(name, country) {\n        this.name = name;\n        this.country = country;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nconst organization = new Organization(\"Acme Gooseberries\", \"GB\");\n```"
            ]
        }
    },
    "FOWLER_EX_PUSH DOWN METHOD": {
        "RefactMethod": "PUSH DOWN METHOD",
        "BeforeRefact": "class Employee {\n  get quota {...}\n}\n\nclass Engineer extends Employee {...}\nclass Salesman extends Employee {...}",
        "AfterRefact": "class Employee {...}\nclass Engineer extends Employee {...}\nclass Salesman extends Employee {\n  get quota {...}  \n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  getQuota() {\n    // Implementation...\n  }\n}",
                "class Engineer extends Employee {}",
                "class Salesman extends Employee {}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Employee {\n}",
                "class Engineer extends Employee {\n  get quota { \n    // implementation specific to Engineer \n  }\n}",
                "class Salesman extends Employee {\n  get quota { \n    // implementation specific to Salesman \n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  get quota() {\n    // Implementation details here\n  }\n}",
                "class Engineer extends Employee {\n  // Engineer specific implementations\n}",
                "class Salesman extends Employee {\n  // Salesman specific implementations\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  get quota {...}\n}",
                "class Engineer extends Employee {\n  get quota {...}\n}",
                "class Salesman extends Employee {\n  get quota {...}\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_EXTRACT FUNCTION": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "function printOwing(invoice) {\n  printBanner();\n  let outstanding  = calculateOutstanding();\n\n  //print details\n  console.log(`name: ${invoice.customer}`);\n  console.log(`amount: ${outstanding}`);  \n}",
        "AfterRefact": "function printOwing(invoice) {\n  printBanner();\n  let outstanding  = calculateOutstanding();\n  printDetails(outstanding);\n\n  function printDetails(outstanding) {\n    console.log(`name: ${invoice.customer}`);\n    console.log(`amount: ${outstanding}`);\n  }\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction printOwing(invoice) {\n  printBanner();\n  let outstanding = calculateOutstanding(invoice);\n\n  printDetails(invoice.customer, outstanding);\n}\n\nfunction printDetails(customer, amount) {\n  console.log(`name: ${customer}`);\n  console.log(`amount: ${amount}`);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction printOwing(invoice) {\n  printBanner();\n  let outstanding = calculateOutstanding();\n  printDetails(invoice, outstanding);\n}\n\nfunction printDetails(invoice, outstanding) {\n  // print details\n  console.log(`name: ${invoice.customer}`);\n  console.log(`amount: ${outstanding}`);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction printOwing(invoice) {\n  printBanner();\n  const outstanding = calculateOutstanding(invoice);\n\n  console.log(`name: ${invoice.customer}`);\n  console.log(`amount: ${outstanding}`);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction printOwing(invoice) {\n  printBanner();\n  let outstanding = calculateOutstanding();\n  printDetails(invoice, outstanding);\n}\n\nfunction printDetails(invoice, outstanding) {\n  // print details\n  console.log(`name: ${invoice.customer}`);\n  console.log(`amount: ${outstanding}`);\n}\n```"
            ]
        }
    },
    "FOWLER_EX_INTRODUCE ASSERTION": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "if (this.discountRate)\n  base = base - (this.discountRate * base);",
        "AfterRefact": "assert(this.discountRate >= 0);\nif (this.discountRate)\n  base = base - (this.discountRate * base);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst hasDiscount = this.discountRate !== undefined && this.discountRate > 0;\nif (hasDiscount) {\n  base = base - (this.discountRate * base);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nassert(this.discountRate !== undefined);\nif (this.discountRate) {\n  base = base - (this.discountRate * base);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (this.discountRate) {\n  base -= this.discountRate * base;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (this.discountRate) {\n  console.assert(this.discountRate >= 0, 'Discount rate should be non-negative');\n  base = base - (this.discountRate * base);\n}\n```"
            ]
        }
    },
    "FOWLER_EX_EXTRACT VARIABLE": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "return order.quantity * order.itemPrice -\n    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +\n    Math.min(order.quantity * order.itemPrice * 0.1, 100);",
        "AfterRefact": "const basePrice = order.quantity * order.itemPrice;\nconst quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;\nconst shipping = Math.min(basePrice * 0.1, 100);\nreturn basePrice - quantityDiscount + shipping;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst totalPrice = order.quantity * order.itemPrice;\nconst discountThreshold = 500;\nconst discountRate = 0.05;\nconst maxDiscount = 100;\nconst extraDiscountRate = 0.1;\n\nconst discount = Math.max(0, order.quantity - discountThreshold) * order.itemPrice * discountRate;\nconst extraDiscount = Math.min(totalPrice * extraDiscountRate, maxDiscount);\n\nreturn totalPrice - discount + extraDiscount;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nfinal double itemPrice = order.itemPrice;\nfinal int quantity = order.quantity;\nreturn quantity * itemPrice -\n    Math.max(0, quantity - 500) * itemPrice * 0.05 +\n    Math.min(quantity * itemPrice * 0.1, 100);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst calculateOrderTotal = (order) => {\n    const { quantity, itemPrice } = order;\n    const baseTotal = quantity * itemPrice;\n    const discount = Math.max(0, quantity - 500) * itemPrice * 0.05;\n    const additionalCost = Math.min(baseTotal * 0.1, 100);\n\n    return baseTotal - discount + additionalCost;\n};\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\ndouble itemTotal = order.quantity * order.itemPrice;\ndouble discount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;\ndouble cappedDiscount = Math.min(itemTotal * 0.1, 100);\n\nreturn itemTotal - discount + cappedDiscount;\n```"
            ]
        }
    },
    "FOWLER_EX_INLINE VARIABLE": {
        "RefactMethod": "INLINE VARIABLE",
        "BeforeRefact": "let basePrice = anOrder.basePrice;\nreturn (basePrice > 1000);",
        "AfterRefact": "return anOrder.basePrice > 1000;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "return (anOrder.basePrice > 1000);"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nreturn (anOrder.basePrice > 1000);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst isPriceAboveThreshold = (order) => order.basePrice > 1000;\n\nreturn isPriceAboveThreshold(anOrder);\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nreturn (anOrder.basePrice > 1000);\n```"
            ]
        }
    },
    "FOWLER_EX_ENCAPSULATE COLLECTION": {
        "RefactMethod": "ENCAPSULATE COLLECTION",
        "BeforeRefact": "class Person {              \n  get courses() {return this._courses;}\n  set courses(aList) {this._courses = aList;}",
        "AfterRefact": "class Person {\n  get courses() {return this._courses.slice();}\n  addCourse(aCourse)    { ... }\n  removeCourse(aCourse) { ... }",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor() {\n    this._courses = [];\n  }\n\n  get courses() {\n    return [...this._courses];\n  }\n\n  addCourse(course) {\n    this._courses.push(course);\n  }\n\n  removeCourse(course) {\n    this._courses = this._courses.filter(c => c !== course);\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor() {\n    this._courses = [];\n  }\n\n  get courses() {\n    return this._courses.slice(); // Return a copy for protected view\n  }\n\n  addCourse(course) {\n    this._courses.push(course);\n  }\n\n  removeCourse(course) {\n    const index = this._courses.indexOf(course);\n    if (index > -1) {\n      this._courses.splice(index, 1);\n    }\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor() {\n    this._courses = [];\n  }\n\n  get courses() {\n    return this._courses;\n  }\n\n  set courses(aList) {\n    this._courses = aList;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get courses() {\n    return java.util.Collections.unmodifiableList(this._courses);\n  }\n  \n  addCourse(course) {\n    this._courses.add(course);\n  }\n\n  removeCourse(course) {\n    this._courses.remove(course);\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_ENCAPSULATE VARIABLE": {
        "RefactMethod": "ENCAPSULATE VARIABLE",
        "BeforeRefact": "let defaultOwner = {firstName: \u201cMartin\u201d, lastName: \u201cFowler\u201d};",
        "AfterRefact": "let defaultOwnerData = {firstName: \u201cMartin\u201d, lastName: \u201cFowler\u201d};\nexport function defaultOwner()       {return defaultOwnerData;}\nexport function setDefaultOwner(arg) {defaultOwnerData = arg;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Order {\n    #defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"};\n\n    get defaultOwner() {\n        return this.#defaultOwner;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet defaultOwner = { firstName: \"Martin\", lastName: \"Fowler\" };\n\nfunction getDefaultOwner() {\n    return { ...defaultOwner }; // Return a copy to prevent external modification\n}\n\nfunction setDefaultOwner(newOwner) {\n    defaultOwner = { ...newOwner }; // Update with a copy to prevent external modification\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst defaultOwner = {\n    firstName: \"Martin\",\n    lastName: \"Fowler\"\n};\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Owner {\n    constructor() {\n        this._firstName = \"Martin\";\n        this._lastName = \"Fowler\";\n    }\n\n    get firstName() {\n        return this._firstName;\n    }\n\n    set firstName(value) {\n        this._firstName = value;\n    }\n\n    get lastName() {\n        return this._lastName;\n    }\n\n    set lastName(value) {\n        this._lastName = value;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nlet defaultOwner = new Owner();\n```"
            ]
        }
    },
    "FOWLER_EX_PUSH DOWN FIELD": {
        "RefactMethod": "PUSH DOWN FIELD",
        "BeforeRefact": "class Employee {        // Java\n  private String quota;\n}\n\nclass Engineer extends Employee {...}\nclass Salesman extends Employee {...}",
        "AfterRefact": "class Employee {...}\nclass Engineer extends Employee {...}\n\nclass Salesman extends Employee {\n  protected String quota;\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Employee {\n    // Other properties and methods\n}",
                "class Engineer extends Employee {\n    private String quota;\n}",
                "class Salesman extends Employee {\n    private String quota;\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Employee { }",
                "class Engineer extends Employee {\n    private String quota;\n}",
                "class Salesman extends Employee {\n    private String quota;\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getQuota() {\n        return quota;\n    }",
                "public void setQuota(String quota) {\n        this.quota = quota;\n    }"
            ],
            "classes": [
                "class Employee {\n    private String quota;\n\n    public String getQuota() {\n        return quota;\n    }\n\n    public void setQuota(String quota) {\n        this.quota = quota;\n    }\n}",
                "class Engineer extends Employee {\n    // Engineer specific attributes and methods\n}",
                "class Salesman extends Employee {\n    // Salesman specific attributes and methods\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Employee {\n}",
                "class Engineer extends Employee {\n    private String quota;\n}",
                "class Salesman extends Employee {\n    private String quota;\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "function getPayAmount() {\n    let result;\n    if (isDead)\n        result = deadAmount();\n    else {\n        if (isSeparated)\n            result = separatedAmount();\n        else {\n            if (isRetired)\n                result = retiredAmount();\n            else\n                result = normalPayAmount();\n        }\n    }\n    return result;\n}",
        "AfterRefact": "function getPayAmount() {\n    if (isDead) return deadAmount();\n    if (isSeparated) return separatedAmount();\n    if (isRetired) return retiredAmount();\n    return normalPayAmount();\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getPayAmount() {\n    if (isDead) return deadAmount();\n    if (isSeparated) return separatedAmount();\n    if (isRetired) return retiredAmount();\n    return normalPayAmount();\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getPayAmount() {\n    if (isDead) return deadAmount();\n    if (isSeparated) return separatedAmount();\n    if (isRetired) return retiredAmount();\n    return normalPayAmount();\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getPayAmount() {\n    if (isDead) return deadAmount();\n    if (isSeparated) return separatedAmount();\n    if (isRetired) return retiredAmount();\n    return normalPayAmount();\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getPayAmount() {\n    if (isDead) return deadAmount();\n    if (isSeparated) return separatedAmount();\n    if (isRetired) return retiredAmount();\n    return normalPayAmount();\n}\n```"
            ]
        }
    },
    "FOWLER_EX_REMOVE SETTING METHOD": {
        "RefactMethod": "REMOVE SETTING METHOD",
        "BeforeRefact": "class Person {\n  get name() {...}\n  set name(aString) {...}",
        "AfterRefact": "class Person {\n  get name() {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor(name) {\n    this._name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor(name) {\n    this._name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor(name) {\n    this._name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(value) {\n    this._name = value;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get name() {...}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE DERIVED VARIABLE WITH QUERY": {
        "RefactMethod": "REPLACE DERIVED VARIABLE WITH QUERY",
        "BeforeRefact": "get discountedTotal() {return this._discountedTotal;}\nset discount(aNumber) {\n    const old = this._discount;\n    this._discount = aNumber;\n    this._discountedTotal += old - aNumber; \n}",
        "AfterRefact": "get discountedTotal() {return this._baseTotal - this._discount;}\nset discount(aNumber) {this._discount = aNumber;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nget discountedTotal() {\n    return this._calculateDiscountedTotal();\n}\n\nset discount(aNumber) {\n    const old = this._discount;\n    this._discount = aNumber;\n    this._updateDiscountedTotal(old, aNumber);\n}\n\n_calculateDiscountedTotal() {\n    // Logic to calculate discounted total\n}\n\n_updateDiscountedTotal(oldDiscount, newDiscount) {\n    this._discountedTotal += oldDiscount - newDiscount; \n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nget discountedTotal() {\n    return this.calculateDiscountedTotal();\n}\n\nset discount(aNumber) {\n    const old = this._discount;\n    this._discount = aNumber;\n    this._discountedTotal += old - aNumber; \n}\n\ncalculateDiscountedTotal() {\n    return this._originalPrice - (this._originalPrice * this._discount / 100);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nget discountedTotal() {\n    return this._discountedTotal;\n}\n\nset discount(value) {\n    const previousDiscount = this._discount;\n    this._discount = value;\n    this._discountedTotal += previousDiscount - value; \n}\n```"
            ]
        }
    },
    "FOWLER_EX_SUBSTITUTE ALGORITHM": {
        "RefactMethod": "SUBSTITUTE ALGORITHM",
        "BeforeRefact": "function foundPerson(people) {\n  for(let i = 0; i < people.length; i++) {\n    if (people[i] === \u201cDon\u201d) {\n      return \u201cDon\u201d;\n    }\n    if (people[i] === \u201cJohn\u201d) {\n      return \u201cJohn\u201d;\n    }\n    if (people[i] === \u201cKent\u201d) {\n      return \u201cKent\u201d;\n    }\n  }\n  return \u201c\u201d;\n}",
        "AfterRefact": "function foundPerson(people) {\n  const candidates = [\u201dDon\u201d, \u201cJohn\u201d, \u201cKent\u201d];\n  return people.find(p => candidates.includes(p)) || '';\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction foundPerson(people) {\n  const names = [\"Don\", \"John\", \"Kent\"];\n  for (let i = 0; i < people.length; i++) {\n    if (names.includes(people[i])) {\n      return people[i];\n    }\n  }\n  return \"\";\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction foundPerson(people) {\n  const targetNames = new Set([\"Don\", \"John\", \"Kent\"]);\n  \n  for (let i = 0; i < people.length; i++) {\n    if (targetNames.has(people[i])) {\n      return people[i];\n    }\n  }\n  \n  return \"\";\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction foundPerson(people) {\n  const targets = [\"Don\", \"John\", \"Kent\"];\n  \n  for (let person of people) {\n    if (targets.includes(person)) {\n      return person;\n    }\n  }\n\n  return \"\";\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction foundPerson(people) {\n  const validNames = new Set([\"Don\", \"John\", \"Kent\"]);\n  \n  for (let i = 0; i < people.length; i++) {\n    if (validNames.has(people[i])) {\n      return people[i];\n    }\n  }\n  return \"\";\n}\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE CONDITIONAL WITH POLYMORPHISM": {
        "RefactMethod": "REPLACE CONDITIONAL WITH POLYMORPHISM",
        "BeforeRefact": "switch (bird.type) {\n  case 'EuropeanSwallow':\n    return \u201caverage\u201d;\n  case 'AfricanSwallow':\n    return (bird.numberOfCoconuts > 2) ? \u201ctired\u201d : \u201caverage\u201d;\n  case 'NorwegianBlueParrot':\n    return (bird.voltage > 100) ? \u201cscorched\u201d : \u201cbeautiful\u201d;\n  default:\n    return \u201cunknown\u201d;",
        "AfterRefact": "class EuropeanSwallow {\n  get plumage() {\n    return \u201caverage\u201d;\n  }\nclass AfricanSwallow {\n  get plumage() {\n     return (this.numberOfCoconuts > 2) ? \u201ctired\u201d : \u201caverage\u201d;\n  }\nclass NorwegianBlueParrot {\n  get plumage() {\n     return (this.voltage > 100) ? \u201cscorched\u201d : \u201cbeautiful\u201d;\n  }",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Bird {\n  constructor() {\n    if (new.target === Bird) {\n      throw new TypeError(\"Cannot construct Bird instances directly\");\n    }\n  }\n\n  getState() {\n    throw new Error(\"Method \\'getState()\\' must be implemented.\");\n  }\n}",
                "class EuropeanSwallow extends Bird {\n  getState() {\n    return \"average\";\n  }\n}",
                "class AfricanSwallow extends Bird {\n  constructor(numberOfCoconuts) {\n    super();\n    this.numberOfCoconuts = numberOfCoconuts;\n  }\n\n  getState() {\n    return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";\n  }\n}",
                "class NorwegianBlueParrot extends Bird {\n  constructor(voltage) {\n    super();\n    this.voltage = voltage;\n  }\n\n  getState() {\n    return (this.voltage > 100) ? \"scorched\" : \"beautiful\";\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\nfunction getBirdState(bird) {\n  if (bird instanceof Bird) {\n    return bird.getState();\n  }\n  return \"unknown\";\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Bird:\n    def get_flying_condition(self):\n        raise NotImplementedError(\"This method should be overridden in subclasses.\")\n\n\nclass EuropeanSwallow(Bird):\n    def get_flying_condition(self):\n        return \"average\"\n\n\nclass AfricanSwallow(Bird):\n    def __init__(self, number_of_coconuts):\n        self.number_of_coconuts = number_of_coconuts\n\n    def get_flying_condition(self):\n        return \"tired\" if self.number_of_coconuts > 2 else \"average\"\n\n\nclass NorwegianBlueParrot(Bird):\n    def __init__(self, voltage):\n        self.voltage = voltage\n\n    def get_flying_condition(self):\n        return \"scorched\" if self.voltage > 100 else \"beautiful\"\n\n\ndef bird_factory(bird_type, *args):\n    if bird_type == \\'EuropeanSwallow\\':\n        return EuropeanSwallow()\n    elif bird_type == \\'AfricanSwallow\\':\n        return AfricanSwallow(*args)\n    elif bird_type == \\'NorwegianBlueParrot\\':\n        return NorwegianBlueParrot(*args)\n    else:\n        return None\n\n\ndef get_bird_condition(bird_type, *args):\n    bird = bird_factory(bird_type, *args)\n    if bird:\n        return bird.get_flying_condition()\n    return \"unknown\"\n```",
                "class EuropeanSwallow(Bird):\n    def get_flying_condition(self):\n        return \"average\"\n\n\nclass AfricanSwallow(Bird):\n    def __init__(self, number_of_coconuts):\n        self.number_of_coconuts = number_of_coconuts\n\n    def get_flying_condition(self):\n        return \"tired\" if self.number_of_coconuts > 2 else \"average\"\n\n\nclass NorwegianBlueParrot(Bird):\n    def __init__(self, voltage):\n        self.voltage = voltage\n\n    def get_flying_condition(self):\n        return \"scorched\" if self.voltage > 100 else \"beautiful\"\n\n\ndef bird_factory(bird_type, *args):\n    if bird_type == \\'EuropeanSwallow\\':\n        return EuropeanSwallow()\n    elif bird_type == \\'AfricanSwallow\\':\n        return AfricanSwallow(*args)\n    elif bird_type == \\'NorwegianBlueParrot\\':\n        return NorwegianBlueParrot(*args)\n    else:\n        return None\n\n\ndef get_bird_condition(bird_type, *args):\n    bird = bird_factory(bird_type, *args)\n    if bird:\n        return bird.get_flying_condition()\n    return \"unknown\"\n```",
                "class AfricanSwallow(Bird):\n    def __init__(self, number_of_coconuts):\n        self.number_of_coconuts = number_of_coconuts\n\n    def get_flying_condition(self):\n        return \"tired\" if self.number_of_coconuts > 2 else \"average\"\n\n\nclass NorwegianBlueParrot(Bird):\n    def __init__(self, voltage):\n        self.voltage = voltage\n\n    def get_flying_condition(self):\n        return \"scorched\" if self.voltage > 100 else \"beautiful\"\n\n\ndef bird_factory(bird_type, *args):\n    if bird_type == \\'EuropeanSwallow\\':\n        return EuropeanSwallow()\n    elif bird_type == \\'AfricanSwallow\\':\n        return AfricanSwallow(*args)\n    elif bird_type == \\'NorwegianBlueParrot\\':\n        return NorwegianBlueParrot(*args)\n    else:\n        return None\n\n\ndef get_bird_condition(bird_type, *args):\n    bird = bird_factory(bird_type, *args)\n    if bird:\n        return bird.get_flying_condition()\n    return \"unknown\"\n```",
                "class NorwegianBlueParrot(Bird):\n    def __init__(self, voltage):\n        self.voltage = voltage\n\n    def get_flying_condition(self):\n        return \"scorched\" if self.voltage > 100 else \"beautiful\"\n\n\ndef bird_factory(bird_type, *args):\n    if bird_type == \\'EuropeanSwallow\\':\n        return EuropeanSwallow()\n    elif bird_type == \\'AfricanSwallow\\':\n        return AfricanSwallow(*args)\n    elif bird_type == \\'NorwegianBlueParrot\\':\n        return NorwegianBlueParrot(*args)\n    else:\n        return None\n\n\ndef get_bird_condition(bird_type, *args):\n    bird = bird_factory(bird_type, *args)\n    if bird:\n        return bird.get_flying_condition()\n    return \"unknown\"\n```"
            ],
            "others": [
                "```python\n"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst getBirdStatus = (bird) => {\n  const statusMap = {\n    EuropeanSwallow: \"average\",\n    AfricanSwallow: (bird) => (bird.numberOfCoconuts > 2 ? \"tired\" : \"average\"),\n    NorwegianBlueParrot: (bird) => (bird.voltage > 100 ? \"scorched\" : \"beautiful\"),\n  };\n\n  const status = statusMap[bird.type];\n  return typeof status === \"function\" ? status(bird) : status || \"unknown\";\n};\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Bird {\n  constructor(type) {\n    this.type = type;\n  }\n}",
                "class EuropeanSwallow extends Bird {\n  constructor() {\n    super(\\'EuropeanSwallow\\');\n  }\n\n  flightSpeed() {\n    return \"average\";\n  }\n}",
                "class AfricanSwallow extends Bird {\n  constructor(numberOfCoconuts) {\n    super(\\'AfricanSwallow\\');\n    this.numberOfCoconuts = numberOfCoconuts;\n  }\n\n  flightSpeed() {\n    return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";\n  }\n}",
                "class NorwegianBlueParrot extends Bird {\n  constructor(voltage) {\n    super(\\'NorwegianBlueParrot\\');\n    this.voltage = voltage;\n  }\n\n  flightSpeed() {\n    return (this.voltage > 100) ? \"scorched\" : \"beautiful\";\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\nfunction getBirdFlightSpeed(bird) {\n  if (bird instanceof Bird) {\n    return bird.flightSpeed();\n  }\n  return \"unknown\";\n}\n```"
            ]
        }
    },
    "FOWLER_EX_DECOMPOSE CONDITIONAL": {
        "RefactMethod": "DECOMPOSE CONDITIONAL",
        "BeforeRefact": "if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))\n  charge = quantity * plan.summerRate;\nelse\n  charge = quantity * plan.regularRate + plan.regularServiceCharge;",
        "AfterRefact": "if (summer())\n  charge = summerCharge();\nelse\n  charge = regularCharge();",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (isSummer(aDate, plan)) {\n  charge = quantity * plan.summerRate;\n} else {\n  charge = quantity * plan.regularRate + plan.regularServiceCharge;\n}\n\nfunction isSummer(aDate, plan) {\n  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "private boolean isDuringSummer(LocalDate aDate, Plan plan) {\n    return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);\n}",
                "private double calculateSummerCharge(int quantity, Plan plan) {\n    return quantity * plan.summerRate;\n}",
                "private double calculateRegularCharge(int quantity, Plan plan) {\n    return quantity * plan.regularRate + plan.regularServiceCharge;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nif (isDuringSummer(aDate, plan)) {\n    charge = calculateSummerCharge(quantity, plan);\n} else {\n    charge = calculateRegularCharge(quantity, plan);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst isSummerCharge = !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);\ncharge = quantity * (isSummerCharge ? plan.summerRate : plan.regularRate) + (isSummerCharge ? 0 : plan.regularServiceCharge);\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private boolean isSummerCharge(LocalDate aDate, Plan plan) {\n  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);\n}"
            ],
            "classes": [],
            "others": [
                "```java\nif (isSummerCharge(aDate, plan)) {\n  charge = quantity * plan.summerRate;\n} else {\n  charge = quantity * plan.regularRate + plan.regularServiceCharge;\n}\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_EXTRACT SUPERCLASS": {
        "RefactMethod": "EXTRACT SUPERCLASS",
        "BeforeRefact": "class Department {\n  get totalAnnualCost() {...}\n  get name() {...}\n  get headCount() {...}\n}\n\nclass Employee {\n  get annualCost() {...}\n  get name() {...}\n  get id() {...}\n}",
        "AfterRefact": "class Party {\n  get name() {...}\n  get annualCost() {...}\n}\n\nclass Department extends Party {\n  get annualCost() {...}\n  get headCount() {...}\n}\n\nclass Employee extends Party {\n  get annualCost() {...}\n  get id() {...}\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class OrganizationMember {\n  get name() {...}\n}",
                "class Department extends OrganizationMember {\n  get totalAnnualCost() {...}\n  get headCount() {...}\n}",
                "class Employee extends OrganizationMember {\n  get annualCost() {...}\n  get id() {...}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Entity {\n  get name() { /* ... */ }\n}",
                "class Department extends Entity {\n  get totalAnnualCost() { /* ... */ }\n  get headCount() { /* ... */ }\n}",
                "class Employee extends Entity {\n  get annualCost() { /* ... */ }\n  get id() { /* ... */ }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Department {\n  constructor(name, headCount, totalAnnualCost) {\n    this._name = name;\n    this._headCount = headCount;\n    this._totalAnnualCost = totalAnnualCost;\n  }\n\n  get totalAnnualCost() {\n    return this._totalAnnualCost;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get headCount() {\n    return this._headCount;\n  }\n}",
                "class Employee {\n  constructor(name, id, annualCost) {\n    this._name = name;\n    this._id = id;\n    this._annualCost = annualCost;\n  }\n\n  get annualCost() {\n    return this._annualCost;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get id() {\n    return this._id;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Organization {\n  get name() {...}\n}",
                "class Department extends Organization {\n  get totalAnnualCost() {...}\n  get headCount() {...}\n}",
                "class Employee extends Organization {\n  get annualCost() {...}\n  get id() {...}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE LOOP WITH PIPELINE": {
        "RefactMethod": "REPLACE LOOP WITH PIPELINE",
        "BeforeRefact": "const names = [];\nfor (const i of input) {\n    if (i.job === \u201cprogrammer\u201d)\n        names.push(i.name);\n}",
        "AfterRefact": "const names = input\n    .filter(i => i.job === \u201cprogrammer\u201d)\n    .map(i => i.name)\n;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst names = input\n    .filter(i => i.job === \"programmer\")\n    .map(i => i.name);\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst names = input\n    .filter(i => i.job === \"programmer\")\n    .map(i => i.name);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst names = input\n    .filter(person => person.job === \"programmer\")\n    .map(person => person.name);\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE SUPERCLASS WITH DELEGATE": {
        "RefactMethod": "REPLACE SUPERCLASS WITH DELEGATE",
        "BeforeRefact": "class List {...}\nclass Stack extends List {...}",
        "AfterRefact": "class Stack {\n  constructor() {\n    this._storage = new List();\n  }\n}\nclass List {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class List {\n    // List implementation\n}",
                "class Stack {\n    private List list = new List();\n    \n    // Stack implementation that delegates to the List instance\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void add(Object item) {\n        // Implementation for adding item to the list\n    }",
                "public Object get(int index) {\n        // Implementation for getting item from the list\n        return null;\n    }",
                "public int size() {\n        // Implementation for returning size of the list\n        return 0;\n    }",
                "public void push(Object item) {\n        delegate.add(item);\n    }",
                "public Object pop() {\n        // Implementation for popping item from stack, assumes list structure supports it\n        // For example, using size() and get() to remove the last element\n        return null;\n    }",
                "public Object peek() {\n        // Implementation for peeking at the top item of the stack\n        return delegate.get(delegate.size() - 1);\n    }",
                "public int size() {\n        return delegate.size();\n    }"
            ],
            "classes": [
                "class List {\n    public void add(Object item) {\n        // Implementation for adding item to the list\n    }\n\n    public Object get(int index) {\n        // Implementation for getting item from the list\n        return null;\n    }\n\n    public int size() {\n        // Implementation for returning size of the list\n        return 0;\n    }\n}",
                "class Stack {\n    private List delegate = new List();\n\n    public void push(Object item) {\n        delegate.add(item);\n    }\n\n    public Object pop() {\n        // Implementation for popping item from stack, assumes list structure supports it\n        // For example, using size() and get() to remove the last element\n        return null;\n    }\n\n    public Object peek() {\n        // Implementation for peeking at the top item of the stack\n        return delegate.get(delegate.size() - 1);\n    }\n\n    public int size() {\n        return delegate.size();\n    }\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class List {\n    // Implementation of List class\n}",
                "class Stack extends List {\n    // Implementation of Stack class\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class List {\n    // List implementation\n}",
                "class Stack {\n    private List delegate;\n\n    public Stack(List delegate) {\n        this.delegate = delegate;\n    }\n\n    // Delegate methods to List\n}"
            ],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_COMBINE FUNCTIONS INTO TRANSFORM": {
        "RefactMethod": "COMBINE FUNCTIONS INTO TRANSFORM",
        "BeforeRefact": "function base(aReading) {...}\nfunction taxableCharge(aReading) {...}",
        "AfterRefact": "function enrichReading(argReading) {\n  const aReading = _.cloneDeep(argReading);\n  aReading.baseCharge = base(aReading);\n  aReading.taxableCharge = taxableCharge(aReading);\n  return aReading;\n}\n",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction charge(aReading) {\n    const base = ...; // your logic for base calculation\n    const taxableCharge = ...; // your logic for taxable charge calculation\n    return base + taxableCharge;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction transform(aReading) {\n    // Deep copy of aReading\n    return { ...aReading };\n}\n\nfunction base(aReading) {\n    // Original base calculation logic\n    const baseCharge = aReading.hourlyReading * 0.5; // example logic\n    const transformedReading = transform(aReading);\n    transformedReading.baseCharge = baseCharge;\n    return transformedReading;\n}\n\nfunction taxableCharge(aReading) {\n    const transformedReading = transform(aReading);\n    transformedReading.taxableCharge = transformedReading.baseCharge * 1.2; // example logic\n    return transformedReading;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction base(aReading) {\n    return aReading.baseCharge;\n}\n\nfunction taxableCharge(aReading) {\n    const baseCharge = base(aReading);\n    return aReading.taxableCharge + baseCharge;\n}\n```"
            ]
        }
    },
    "FOWLER_EX_PARAMETERIZE FUNCTION": {
        "RefactMethod": "PARAMETERIZE FUNCTION",
        "BeforeRefact": "function tenPercentRaise(aPerson) {\n  aPerson.salary = aPerson.salary.multiply(1.1);\n}\nfunction fivePercentRaise(aPerson) {\n  aPerson.salary = aPerson.salary.multiply(1.05);\n}",
        "AfterRefact": "function raise(aPerson, factor) {\n  aPerson.salary = aPerson.salary.multiply(1 + factor);\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction applyRaise(aPerson, percentage) {\n  aPerson.salary = aPerson.salary.multiply(1 + percentage);\n}\n\nfunction tenPercentRaise(aPerson) {\n  applyRaise(aPerson, 0.10);\n}\n\nfunction fivePercentRaise(aPerson) {\n  applyRaise(aPerson, 0.05);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction applyRaise(aPerson, raiseFactor) {\n  aPerson.salary = aPerson.salary.multiply(raiseFactor);\n}\n\nfunction tenPercentRaise(aPerson) {\n  applyRaise(aPerson, 1.1);\n}\n\nfunction fivePercentRaise(aPerson) {\n  applyRaise(aPerson, 1.05);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction applySalaryRaise(aPerson, percentage) {\n  aPerson.salary = aPerson.salary.multiply(1 + percentage / 100);\n}\n\nfunction tenPercentRaise(aPerson) {\n  applySalaryRaise(aPerson, 10);\n}\n\nfunction fivePercentRaise(aPerson) {\n  applySalaryRaise(aPerson, 5);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction raiseSalary(aPerson, percentage) {\n  aPerson.salary = aPerson.salary.multiply(1 + percentage);\n}\n\nfunction tenPercentRaise(aPerson) {\n  raiseSalary(aPerson, 0.1);\n}\n\nfunction fivePercentRaise(aPerson) {\n  raiseSalary(aPerson, 0.05);\n}\n```"
            ]
        }
    },
    "FOWLER_EX_REMOVE FLAG ARGUMENT": {
        "RefactMethod": "REMOVE FLAG ARGUMENT",
        "BeforeRefact": "function setDimension(name, value) {\n  if (name === \u201cheight\u201d) {\n    this._height = value;\n    return;\n  }\n  if (name === \u201cwidth\u201d) {\n    this._width = value;\n    return;\n  }\n}",
        "AfterRefact": "function setHeight(value) {this._height = value;}\nfunction setWidth (value) {this._width = value;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction setHeight(value) {\n  this._height = value;\n}\n\nfunction setWidth(value) {\n  this._width = value;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction setHeight(value) {\n  this._height = value;\n}\n\nfunction setWidth(value) {\n  this._width = value;\n}\n\nfunction setDimension(name, value) {\n  if (name === \"height\") {\n    setHeight(value);\n    return;\n  }\n  if (name === \"width\") {\n    setWidth(value);\n    return;\n  }\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction setDimension(name, value) {\n  const dimensionMap = {\n    height: '_height',\n    width: '_width'\n  };\n\n  if (dimensionMap[name]) {\n    this[dimensionMap[name]] = value;\n  }\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction setDimension(value) {\n  if (this._name === \"height\") {\n    this._height = value;\n    return;\n  }\n  if (this._name === \"width\") {\n    this._width = value;\n    return;\n  }\n}\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE PARAMETER WITH QUERY": {
        "RefactMethod": "REPLACE PARAMETER WITH QUERY",
        "BeforeRefact": "availableVacation(anEmployee, anEmployee.grade);\n\nfunction availableVacation(anEmployee, grade) {\n  // calculate vacation...",
        "AfterRefact": "availableVacation(anEmployee)\n\nfunction availableVacation(anEmployee) {\n  const grade = anEmployee.grade;\n  // calculate vacation...",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\navailableVacation(anEmployee);\n\nfunction availableVacation(anEmployee) {\n  const grade = anEmployee.grade;\n  // calculate vacation...\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction availableVacation(anEmployee) {\n  const grade = anEmployee.grade; // Extracted the parameter calculation\n  // calculate vacation...\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction availableVacation(employee) {\n  const { grade } = employee;\n  // calculate vacation...\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction availableVacation(anEmployee) {\n  const grade = anEmployee.grade;\n  // calculate vacation...\n}\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE COMMAND WITH FUNCTION": {
        "RefactMethod": "REPLACE COMMAND WITH FUNCTION",
        "BeforeRefact": "class ChargeCalculator {\n  constructor (customer, usage){\n    this._customer = customer;\n    this._usage = usage;\n  }\n  execute() {\n    return this._customer.rate * this._usage;\n  }\n}",
        "AfterRefact": "function charge(customer, usage) {\n  return customer.rate * usage;\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class ChargeCalculator {\n  constructor(customer, usage) {\n    this._customer = customer;\n    this._usage = usage;\n  }\n  \n  calculateCharge() {\n    return this._customer.rate * this._usage;\n  }\n  \n  execute() {\n    return this.calculateCharge();\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class ChargeCalculator {\n  static calculateCharge(customer, usage) {\n    return customer.rate * usage;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class ChargeCalculator {\n  constructor(customer, usage) {\n    this.customer = customer;\n    this.usage = usage;\n  }\n\n  calculate() {\n    return this.customer.rate * this.usage;\n  }\n}"
            ],
            "others": []
        }
    },
    "FOWLER_EX_CHANGE FUNCTION DECLARATION": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "function circum(radius) {...}",
        "AfterRefact": "function circumference(radius) {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction calculateCircumference(radius) {\n    // function implementation\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction circum(radius) {\n    // Function implementation here\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction calculateCircumference(radius) {\n    if (radius < 0) {\n        throw new Error(\"Radius cannot be negative\");\n    }\n    const pi = Math.PI;\n    return 2 * pi * radius;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction circum(radius, addedParam) {...}\n```"
            ]
        }
    },
    "FOWLER_EX_RENAME FIELD": {
        "RefactMethod": "RENAME FIELD",
        "BeforeRefact": "class Organization {\n  get name() {...}\n}",
        "AfterRefact": "class Organization {\n  get title() {...}\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Organization {\n  get organizationName() {...}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Organization {\n  get organizationName() {...}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Organization {\n  constructor(name) {\n    this._name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE INLINE CODE WITH FUNCTION CALL": {
        "RefactMethod": "REPLACE INLINE CODE WITH FUNCTION CALL",
        "BeforeRefact": "let appliesToMass = false;\nfor(const s of states) {\n    if (s === \u201cMA\u201d) appliesToMass = true;\n}",
        "AfterRefact": "appliesToMass = states.includes(\u201cMA\u201d);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet appliesToMass = isMassApplicable(states);\n\nfunction isMassApplicable(states) {\n    for(const s of states) {\n        if (s === \"MA\") return true;\n    }\n    return false;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet appliesToMass = isMassIncluded(states);\n\nfunction isMassIncluded(states) {\n    for (const s of states) {\n        if (s === \"MA\") return true;\n    }\n    return false;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst appliesToMass = states.includes(\"MA\");\n```"
            ]
        }
    },
    "FOWLER_EX_MOVE FUNCTION": {
        "RefactMethod": "MOVE FUNCTION",
        "BeforeRefact": "class Account {\n    get overdraftCharge() {...}",
        "AfterRefact": "class AccountType {\n    get overdraftCharge() {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Account {\n    get overdraftCharge() {\n        return this.calculateOverdraftCharge();\n    }\n\n    calculateOverdraftCharge() {\n        // logic for calculating overdraft charge\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Account {\n    get overdraftCharge() {\n        return this.calculateOverdraftCharge();\n    }\n\n    calculateOverdraftCharge() {\n        // Logic for calculating overdraft charge\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Account {\n    get overdraftCharge() {\n        // Implementation here\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Account {\n    get overdraftCharge() {...}\n}",
                "class PremiumAccount extends Account {\n    get overdraftCharge() {...}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_SPLIT VARIABLE": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "let temp = 2 * (height + width);\nconsole.log(temp);\ntemp = height * width;\nconsole.log(temp);",
        "AfterRefact": "const perimeter = 2 * (height + width);\nconsole.log(perimeter);\nconst area = height * width;\nconsole.log(area);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet perimeter = 2 * (height + width);\nconsole.log(perimeter);\n\nlet area = height * width;\nconsole.log(area);\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet initialArea = 2 * (height + width);\nconsole.log(initialArea);\nlet finalArea = height * width;\nconsole.log(finalArea);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst perimeter = 2 * (height + width);\nconst area = height * width;\n\nconsole.log(perimeter);\nconsole.log(area);\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet area = height * width;\nconsole.log(area);\n\nlet perimeter = 2 * (height + width);\nconsole.log(perimeter);\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE QUERY WITH PARAMETER": {
        "RefactMethod": "REPLACE QUERY WITH PARAMETER",
        "BeforeRefact": "targetTemperature(aPlan)\n\nfunction targetTemperature(aPlan) {\n    currentTemperature = thermostat.currentTemperature;\n    // rest of function...\n}",
        "AfterRefact": "targetTemperature(aPlan, thermostat.currentTemperature)\n\nfunction targetTemperature(aPlan, currentTemperature) {\n  // rest of function...\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction targetTemperature(aPlan, currentTemperature) {\n    // rest of function...\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction targetTemperature(aPlan, query) {\n    currentTemperature = thermostat.currentTemperature;\n    // rest of function...\n}\n\nfunction queryTemperature(aPlan) {\n    // logic for querying temperature based on aPlan\n}\n\n// Example of how to call the function\ntargetTemperature(aPlan, queryTemperature(aPlan));\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction targetTemperature(plan) {\n    const currentTemperature = thermostat.currentTemperature;\n    // rest of function...\n}\n```"
            ]
        }
    },
    "FOWLER_EX_INTRODUCE SPECIAL CASE": {
        "RefactMethod": "INTRODUCE SPECIAL CASE",
        "BeforeRefact": "if (aCustomer === \u201cunknown\u201d) customerName = \u201coccupant\u201d;",
        "AfterRefact": "class UnknownCustomer {\n    get name() {return \u201coccupant\u201d;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (aCustomer === \"unknown\") {\n    customerName = getOccupantName();\n}\n\nfunction getOccupantName() {\n    return \"occupant\";\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Customer {\n    constructor(name) {\n        this.name = name;\n    }\n\n    isSpecialCase() {\n        return this.name === \"unknown\";\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nconst specialCaseCustomer = new Customer(\"unknown\");\nlet customerName;\n\nfunction getCustomerName(customer) {\n    if (customer.isSpecialCase()) {\n        return \"occupant\";\n    }\n    return customer.name;\n}\n\n// Assuming \\'aCustomer\\' is an instance of Customer\ncustomerName = getCustomerName(aCustomer);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\ncustomerName = (aCustomer === \"unknown\") ? \"occupant\" : customerName;\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (aCustomer === \"unknown\") {\n    customerName = new Occupant();\n} else {\n    customerName = aCustomer;\n}\n```"
            ]
        }
    },
    "FOWLER_EX_REMOVE DEAD CODE": {
        "RefactMethod": "REMOVE DEAD CODE",
        "BeforeRefact": "if(false) {\n  doSomethingThatUsedToMatter();\n}",
        "AfterRefact": "",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\n// No code needed, as the dead code has been removed.\n// The block below has been eliminated since it will never execute:\n//\n// if(false) {\n//   doSomethingThatUsedToMatter();\n// }\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\n// The condition is always false, so the function call is removed\n```"
            ]
        }
    },
    "FOWLER_EX_RENAME VARIABLE": {
        "RefactMethod": "RENAME VARIABLE",
        "BeforeRefact": "let a = height * width;",
        "AfterRefact": "let area = height * width;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet area = height * width;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet area = height * width;\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst area = height * width;\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE TYPE CODE WITH SUBCLASSES": {
        "RefactMethod": "REPLACE TYPE CODE WITH SUBCLASSES",
        "BeforeRefact": "function createEmployee(name, type) {\n  return new Employee(name, type);\n}",
        "AfterRefact": "function createEmployee(name, type) {\n  switch (type) {\n    case \u201cengineer\u201d: return new Engineer(name);\n    case \u201csalesman\u201d: return new Salesman(name);\n    case \u201cmanager\u201d:  return new Manager (name);\n  }",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  constructor(name) {\n    this.name = name;\n  }\n}",
                "class FullTimeEmployee extends Employee {\n  constructor(name) {\n    super(name);\n    this.type = 'Full-Time';\n  }\n}",
                "class PartTimeEmployee extends Employee {\n  constructor(name) {\n    super(name);\n    this.type = 'Part-Time';\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n\nfunction createEmployee(name, type) {\n  if (type === 'Full-Time') {\n    return new FullTimeEmployee(name);\n  } else if (type === 'Part-Time') {\n    return new PartTimeEmployee(name);\n  }\n  throw new Error('Invalid employee type');\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Employee {\n    constructor(name) {\n        this.name = name;\n    }\n\n    // Other common employee methods can go here\n}",
                "class Manager extends Employee {\n    constructor(name) {\n        super(name);\n    }\n\n    // Manager specific methods can go here\n}",
                "class Engineer extends Employee {\n    constructor(name) {\n        super(name);\n    }\n\n    // Engineer specific methods can go here\n}",
                "class SalesPerson extends Employee {\n    constructor(name) {\n        super(name);\n    }\n\n    // SalesPerson specific methods can go here\n}",
                "class EmployeeFactory {\n    static create(type, name) {\n        switch (type) {\n            case 'manager':\n                return new Manager(name);\n            case 'engineer':\n                return new Engineer(name);\n            case 'salesperson':\n                return new SalesPerson(name);\n            default:\n                throw new Error('Unknown employee type');\n        }\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\nfunction createEmployee(name, type) {\n    const employee = EmployeeFactory.create(type, name);\n    return employee;\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst createEmployee = (name, type) => new Employee(name, type);\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n  }\n}",
                "class FullTimeEmployee extends Employee {\n  constructor(name) {\n    super(name, 'full-time');\n  }\n}",
                "class PartTimeEmployee extends Employee {\n  constructor(name) {\n    super(name, 'part-time');\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n\nfunction createEmployee(name, type) {\n  if (type === 'full-time') {\n    return new FullTimeEmployee(name);\n  } else if (type === 'part-time') {\n    return new PartTimeEmployee(name);\n  } else {\n    throw new Error('Invalid employee type');\n  }\n}\n```"
            ]
        }
    },
    "FOWLER_EX_INLINE FUNCTION": {
        "RefactMethod": "INLINE FUNCTION",
        "BeforeRefact": "function getRating(driver) {\n  return moreThanFiveLateDeliveries(driver) ? 2 : 1;\n}\n\nfunction moreThanFiveLateDeliveries(driver) {\n  return driver.numberOfLateDeliveries > 5;\n}",
        "AfterRefact": "function getRating(driver) {\n  return (driver.numberOfLateDeliveries > 5) ? 2 : 1;\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getRating(driver) {\n  return driver.numberOfLateDeliveries > 5 ? 2 : 1;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getRating(driver) {\n  return driver.numberOfLateDeliveries > 5 ? 2 : 1;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getRating(driver) {\n  return hasExcessiveLateDeliveries(driver) ? 2 : 1;\n}\n\nfunction hasExcessiveLateDeliveries(driver) {\n  return driver.numberOfLateDeliveries > 5;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getRating(driver) {\n  return driver.numberOfLateDeliveries > 5 ? 2 : 1;\n}\n```"
            ]
        }
    },
    "FOWLER_EX_COMBINE FUNCTIONS INTO CLASS": {
        "RefactMethod": "COMBINE FUNCTIONS INTO CLASS",
        "BeforeRefact": "function base(aReading) {...}\nfunction taxableCharge(aReading) {...}\nfunction calculateBaseCharge(aReading) {...}",
        "AfterRefact": "class Reading {\n  base() {...}\n  taxableCharge() {...}\n  calculateBaseCharge() {...}\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Reading {\n    constructor(aReading) {\n        this._aReading = aReading;\n    }\n\n    base() {\n        // implementation of base function\n    }\n\n    taxableCharge() {\n        // implementation of taxableCharge function\n    }\n\n    calculateBaseCharge() {\n        // implementation of calculateBaseCharge function\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Reading {\n    constructor(aReading) {\n        this.value = aReading.value;\n        this.year = aReading.year;\n        this.month = aReading.month;\n    }\n\n    base() {\n        // Logic for calculating base\n    }\n\n    taxableCharge() {\n        // Logic for calculating taxable charge\n    }\n\n    calculateBaseCharge() {\n        // Logic for calculating base charge\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nfunction processReading(aReading) {\n    const reading = new Reading(aReading);\n    const baseCharge = reading.base();\n    const taxCharge = reading.taxableCharge();\n    const totalCharge = reading.calculateBaseCharge();\n    // Further processing\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction base(reading) {\n    return reading.quantity * reading.unitPrice;\n}\n\nfunction taxableCharge(reading) {\n    return Math.max(0, base(reading) - reading.taxThreshold);\n}\n\nfunction calculateBaseCharge(reading) {\n    return base(reading) + taxableCharge(reading);\n}\n```"
            ]
        }
    },
    "FOWLER_EX_MOVE FIELD": {
        "RefactMethod": "MOVE FIELD",
        "BeforeRefact": "class Customer {\n  get plan() {return this._plan;}\n  get discountRate() {return this._discountRate;}",
        "AfterRefact": "class Customer {\n  get plan() {return this._plan;}\n  get discountRate() {return this.plan.discountRate;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Customer {\n  get plan() { return this._plan; }\n  get discountRate() { return this._discountRate; }\n  \n  set plan(value) { this._plan = value; }\n  set discountRate(value) { this._discountRate = value; }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Customer {\n  constructor(target) {\n    this._target = target; // Reference to the target object\n  }\n\n  get plan() {\n    return this._target.plan; // Accessing the target's plan\n  }\n\n  get discountRate() {\n    return this._target.discountRate; // Accessing the target's discountRate\n  }\n}",
                "class Target {\n  constructor(plan, discountRate) {\n    this._plan = plan;\n    this._discountRate = discountRate;\n  }\n  \n  get plan() {\n    return this._plan;\n  }\n\n  get discountRate() {\n    return this._discountRate;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Customer {\n  constructor(plan, discountRate) {\n    this._plan = plan;\n    this._discountRate = discountRate;\n  }\n\n  get plan() {\n    return this._plan;\n  }\n\n  get discountRate() {\n    return this._discountRate;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Customer {\n  get plan() {return this._plan;}\n  get discountRate() {return this._discountRate;}\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE TEMP WITH QUERY": {
        "RefactMethod": "REPLACE TEMP WITH QUERY",
        "BeforeRefact": "const basePrice = this._quantity * this._itemPrice;\nif (basePrice > 1000)\n  return basePrice * 0.95;\nelse\n  return basePrice * 0.98;",
        "AfterRefact": "get basePrice() {this._quantity * this._itemPrice;}\n\n// ...\n\nif (this.basePrice > 1000)\n  return this.basePrice * 0.95;\nelse\n  return this.basePrice * 0.98;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst discountRate = this._quantity * this._itemPrice > 1000 ? 0.95 : 0.98;\nreturn this._quantity * this._itemPrice * discountRate;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst basePrice = calculateBasePrice();\n\nfunction calculateBasePrice() {\n  return this._quantity * this._itemPrice;\n}\n\nif (basePrice > 1000)\n  return basePrice * 0.95;\nelse\n  return basePrice * 0.98;\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst basePrice = this._quantity * this._itemPrice;\nconst discount = basePrice > 1000 ? 0.95 : 0.98;\nreturn basePrice * discount;\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (this._quantity * this._itemPrice > 1000)\n  return (this._quantity * this._itemPrice) * 0.95;\nelse\n  return (this._quantity * this._itemPrice) * 0.98;\n```"
            ]
        }
    },
    "FOWLER_EX_CHANGE VALUE TO REFERENCE": {
        "RefactMethod": "CHANGE VALUE TO REFERENCE",
        "BeforeRefact": "let customer = new Customer(customerData);",
        "AfterRefact": "let customer = customerRepository.get(customerData.id);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet customerRef = customerData;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class CustomerRepository {\n    constructor() {\n        this.customers = new Map();\n    }\n\n    get(customerData) {\n        if (!this.customers.has(customerData.id)) {\n            const customer = new Customer(customerData);\n            this.customers.set(customerData.id, customer);\n        }\n        return this.customers.get(customerData.id);\n    }\n}",
                "class Customer {\n    constructor(customerData) {\n        this.id = customerData.id;\n        this.name = customerData.name;\n        // other properties\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n// Usage\nconst customerRepository = new CustomerRepository();\nlet customer = customerRepository.get(customerData);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst customer = new Customer(customerData);\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet customer = Customer.create(customerData);\n```"
            ]
        }
    },
    "FOWLER_EX_MOVE STATEMENTS INTO FUNCTION": {
        "RefactMethod": "MOVE STATEMENTS INTO FUNCTION",
        "BeforeRefact": "result.push(`<p>title: ${person.photo.title}</p>`);\nresult.concat(photoData(person.photo));\n\nfunction photoData(aPhoto) {\n  return [\n    `<p>location: ${aPhoto.location}</p>`,\n    `<p>date: ${aPhoto.date.toDateString()}</p>`,\n  ];\n}",
        "AfterRefact": "result.concat(photoData(person.photo));\n\nfunction photoData(aPhoto) {\n  return [\n    `<p>title: ${aPhoto.title}</p>`,\n    `<p>location: ${aPhoto.location}</p>`,\n    `<p>date: ${aPhoto.date.toDateString()}</p>`,\n  ];\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction photoData(person) {\n  return [\n    `<p>title: ${person.photo.title}</p>`,\n    `<p>location: ${person.photo.location}</p>`,\n    `<p>date: ${person.photo.date.toDateString()}</p>`,\n  ];\n}\n\nresult.push(...photoData(person));\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction photoData(aPhoto) {\n  const result = [];\n  result.push(`<p>location: ${aPhoto.location}</p>`);\n  result.push(`<p>date: ${aPhoto.date.toDateString()}</p>`);\n  return result;\n}\n\nresult.push(`<p>title: ${person.photo.title}</p>`);\nresult.push(...photoData(person.photo));\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst generatePhotoDetails = (photo) => {\n  return [\n    `<p>location: ${photo.location}</p>`,\n    `<p>date: ${photo.date.toDateString()}</p>`,\n  ];\n};\n\nresult.push(`<p>title: ${person.photo.title}</p>`, ...generatePhotoDetails(person.photo));\n```"
            ]
        }
    },
    "FOWLER_EX_SEPARATE QUERY FROM MODIFIER": {
        "RefactMethod": "SEPARATE QUERY FROM MODIFIER",
        "BeforeRefact": "function getTotalOutstandingAndSendBill() {\n  const result = customer.invoices.reduce((total, each) => each.amount + total, 0);\n  sendBill();\n  return result;\n}",
        "AfterRefact": "function totalOutstanding() {\n  return customer.invoices.reduce((total, each) => each.amount + total, 0);  \n}\nfunction sendBill() {\n  emailGateway.send(formatBill(customer));\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getTotalOutstanding() {\n  return customer.invoices.reduce((total, each) => each.amount + total, 0);\n}\n\nfunction sendBill() {\n  // implementation of sendBill\n}\n\nfunction getTotalOutstandingAndSendBill() {\n  const result = getTotalOutstanding();\n  sendBill();\n  return result;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getTotalOutstanding() {\n  return customer.invoices.reduce((total, each) => each.amount + total, 0);\n}\n\nfunction getTotalOutstandingAndSendBill() {\n  const result = getTotalOutstanding();\n  sendBill();\n  return result;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getTotalOutstandingAndSendBill() {\n  const totalOutstanding = customer.invoices.reduce((total, invoice) => total + invoice.amount, 0);\n  sendBill();\n  return totalOutstanding;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction getTotalOutstanding() {\n  const result = customer.invoices.reduce((total, each) => each.amount + total, 0);\n  return result;\n}\n\nfunction sendBill() {\n  // logic to send the bill\n}\n\nfunction getTotalOutstandingAndSendBill() {\n  const result = getTotalOutstanding();\n  sendBill();\n  return result;\n}\n```"
            ]
        }
    },
    "FOWLER_EX_HIDE DELEGATE": {
        "RefactMethod": "HIDE DELEGATE",
        "BeforeRefact": "manager = aPerson.department.manager;",
        "AfterRefact": "manager = aPerson.manager;\n\nclass Person {\n  get manager() {return this.department.manager;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```python\nmanager = get_manager(aPerson)\n\ndef get_manager(person):\n    return person.department.manager\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Manager getManager() {\n        return manager;\n    }",
                "public String getManagerName() {\n        return manager.getName();\n    }",
                "public Department getDepartment() {\n        return department;\n    }",
                "public String getName() {\n        return name;\n    }"
            ],
            "classes": [
                "class Department {\n    private Manager manager;\n\n    public Manager getManager() {\n        return manager;\n    }\n\n    // Hides the delegate by creating a new method\n    public String getManagerName() {\n        return manager.getName();\n    }\n\n    // Additional methods ...\n}",
                "class Person {\n    private Department department;\n\n    public Department getDepartment() {\n        return department;\n    }\n\n    // Additional methods ...\n}",
                "class Manager {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    // Additional methods ...\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\npublic ",
                "\n\npublic ",
                "\n\n// Adjusting the client to call the server\nPerson aPerson = new Person();\nString managerName = aPerson.getDepartment().getManagerName();  // Updated line\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```python\nmanager = aPerson.get_department().get_manager()\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nmanager = aPerson.department.getManager();\n```"
            ]
        }
    },
    "FOWLER_EX_PULL UP METHOD": {
        "RefactMethod": "PULL UP METHOD",
        "BeforeRefact": "class Employee {...}\n\nclass Salesman extends Employee {\n  get name() {...}\n}\n\nclass Engineer extends Employee {\n  get name() {...}\n}",
        "AfterRefact": "class Employee {\n  get name() {...}\n}\n\nclass Salesman extends Employee {...}\nclass Engineer extends Employee {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  get name() {\n    // Implementation in subclasses\n  }\n}",
                "class Salesman extends Employee {\n  get name() {\n    // Salesman specific implementation\n  }\n}",
                "class Engineer extends Employee {\n  get name() {\n    // Engineer specific implementation\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  get name() {\n    // shared implementation here\n  }\n}",
                "class Salesman extends Employee {\n  // No longer needed since 'name' is pulled up\n}",
                "class Engineer extends Employee {\n  // No longer needed since 'name' is pulled up\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  // Common properties and methods for all employees can be defined here\n}",
                "class Salesman extends Employee {\n  get name() {\n    // Return the name of the salesman\n  }\n}",
                "class Engineer extends Employee {\n  get name() {\n    // Return the name of the engineer\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Employee {\n  get name() {...}\n}",
                "class Salesman extends Employee {\n  // Optional: Additional Salesman-specific methods or properties\n}",
                "class Engineer extends Employee {\n  // Optional: Additional Engineer-specific methods or properties\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_SLIDE STATEMENTS": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "const pricingPlan = retrievePricingPlan();\nconst order = retreiveOrder();\nlet charge;\nconst chargePerUnit = pricingPlan.unit;",
        "AfterRefact": "const pricingPlan = retrievePricingPlan();\nconst chargePerUnit = pricingPlan.unit;\nconst order = retreiveOrder();\nlet charge;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst pricingPlan = retrievePricingPlan();\nconst order = retrieveOrder();\nconst chargePerUnit = pricingPlan.unit;\nconst charge = chargePerUnit * order.units;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst pricingPlan = retrievePricingPlan();\nlet charge;\nconst chargePerUnit = pricingPlan.unit;\nconst order = retrieveOrder();\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst pricingPlan = retrievePricingPlan();\nconst order = retrieveOrder();\nconst chargePerUnit = pricingPlan.unit;\nconst charge = calculateCharge(order, chargePerUnit);\n\nfunction calculateCharge(order, chargePerUnit) {\n    return order.units * chargePerUnit;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst pricingPlan = retrievePricingPlan();\nconst order = retreiveOrder();\nconst chargePerUnit = pricingPlan.unit;\nlet charge;\n```"
            ]
        }
    },
    "FOWLER_EX_EXTRACT CLASS": {
        "RefactMethod": "EXTRACT CLASS",
        "BeforeRefact": "class Person {\n  get officeAreaCode() {return this._officeAreaCode;}\n  get officeNumber()   {return this._officeNumber;}",
        "AfterRefact": "class Person {\n  get officeAreaCode() {return this._telephoneNumber.areaCode;}\n  get officeNumber()   {return this._telephoneNumber.number;}\n}\nclass TelephoneNumber {\n  get areaCode() {return this._areaCode;}\n  get number()   {return this._number;}\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor(office) {\n    this._office = office;\n  }\n\n  get officeAreaCode() {\n    return this._office.areaCode;\n  }\n\n  get officeNumber() {\n    return this._office.number;\n  }\n}",
                "class Office {\n  constructor(areaCode, number) {\n    this.areaCode = areaCode;\n    this.number = number;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor() {\n    this._contactDetails = new ContactDetails();\n  }\n\n  get officeAreaCode() {\n    return this._contactDetails.officeAreaCode;\n  }\n\n  get officeNumber() {\n    return this._contactDetails.officeNumber;\n  }\n}",
                "class ContactDetails {\n  constructor() {\n    this._officeAreaCode = '';\n    this._officeNumber = '';\n  }\n\n  get officeAreaCode() {\n    return this._officeAreaCode;\n  }\n\n  get officeNumber() {\n    return this._officeNumber;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get officeAreaCode() {\n    return this._officeAreaCode;\n  }\n\n  get officeNumber() {\n    return this._officeNumber;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get officeAreaCode() { return this._officeAreaCode; }\n  get officeNumber() { return this._officeNumber; }\n}",
                "class Office {\n  constructor(officeAreaCode, officeNumber) {\n    this._officeAreaCode = officeAreaCode;\n    this._officeNumber = officeNumber;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_CONSOLIDATE CONDITIONAL EXPRESSION": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "if (anEmployee.seniority < 2) return 0;\nif (anEmployee.monthsDisabled > 12) return 0;\nif (anEmployee.isPartTime) return 0;",
        "AfterRefact": "if (isNotEligibleForDisability()) return 0;\n\nfunction isNotEligibleForDisability() {\nreturn ((anEmployee.seniority < 2)\n        || (anEmployee.monthsDisabled > 12)\n        || (anEmployee.isPartTime));\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (anEmployee.seniority < 2 || anEmployee.monthsDisabled > 12 || anEmployee.isPartTime) return 0;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (anEmployee.seniority < 2 || anEmployee.monthsDisabled > 12 || anEmployee.isPartTime) return 0;\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nif (anEmployee.seniority < 2 || anEmployee.monthsDisabled > 12 || anEmployee.isPartTime) return 0;\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nif (anEmployee.seniority < 2 || anEmployee.monthsDisabled > 12 || anEmployee.isPartTime) return 0;\n```"
            ]
        }
    },
    "FOWLER_EX_PULL UP CONSTRUCTOR BODY": {
        "RefactMethod": "PULL UP CONSTRUCTOR BODY",
        "BeforeRefact": "class Party {...}\n\nclass Employee extends Party {\n  constructor(name, id, monthlyCost) {\n    super();\n    this._id = id;\n    this._name = name;\n    this._monthlyCost = monthlyCost;\n  }\n}",
        "AfterRefact": "class Party {\n  constructor(name){\n    this._name = name;\n  }\n}\n\nclass Employee extends Party {\n  constructor(name, id, monthlyCost) {\n    super(name);\n    this._id = id;\n    this._monthlyCost = monthlyCost;\n  }\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Party {\n  constructor(name) {\n    this._name = name;\n  }\n}",
                "class Employee extends Party {\n  constructor(name, id, monthlyCost) {\n    super(name);\n    this._id = id;\n    this._monthlyCost = monthlyCost;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Party {\n  constructor(name, id, monthlyCost) {\n    this._name = name;\n    this._id = id;\n    this._monthlyCost = monthlyCost;\n  }\n}",
                "class Employee extends Party {\n  constructor(name, id, monthlyCost) {\n    super(name, id, monthlyCost);\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Party {}",
                "class Employee extends Party {\n  constructor(name, id, monthlyCost) {\n    super();\n    this.id = id;\n    this.name = name;\n    this.monthlyCost = monthlyCost;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Party {\n  constructor(name) {\n    this._name = name;\n  }\n}",
                "class Employee extends Party {\n  constructor(name, id, monthlyCost) {\n    super(name);\n    this._id = id;\n    this._monthlyCost = monthlyCost;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE CONSTRUCTOR WITH FACTORY FUNCTION": {
        "RefactMethod": "REPLACE CONSTRUCTOR WITH FACTORY FUNCTION",
        "BeforeRefact": "leadEngineer = new Employee(document.leadEngineer, 'E');",
        "AfterRefact": "leadEngineer = createEngineer(document.leadEngineer);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction createEmployee(name, type) {\n    return new Employee(name, type);\n}\n\nconst leadEngineer = createEmployee(document.leadEngineer, 'E');\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction createEmployee(name, role) {\n    return new Employee(name, role);\n}\n\nleadEngineer = createEmployee(document.leadEngineer, 'E');\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst leadEngineer = new Employee(document.leadEngineer, 'E');\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nleadEngineer = Employee.create(document.leadEngineer, 'E');\n```"
            ]
        }
    },
    "FOWLER_EX_REMOVE SUBCLASS": {
        "RefactMethod": "REMOVE SUBCLASS",
        "BeforeRefact": "class Person {\n  get genderCode() {return \u201cX\u201d;}\n}\nclass Male extends Person {\n  get genderCode() {return \u201cM\u201d;}\n}\nclass Female extends Person {\n  get genderCode() {return \u201cF\u201d;}\n}",
        "AfterRefact": "class Person {\n  get genderCode() {return this._genderCode;}\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get genderCode() {return this._genderCode;}\n}",
                "class Male extends Person {\n  constructor() {\n    super();\n    this._genderCode = \"M\";\n  }\n}",
                "class Female extends Person {\n  constructor() {\n    super();\n    this._genderCode = \"F\";\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor(genderType) {\n    this.genderType = genderType;\n  }\n\n  get genderCode() {\n    switch (this.genderType) {\n      case 'Male':\n        return 'M';\n      case 'Female':\n        return 'F';\n      default:\n        return 'X';\n    }\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n// Usage\nconst male = new Person('Male');\nconst female = new Person('Female');\nconst other = new Person('Other');\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get genderCode() {\n    return \"X\";\n  }\n}",
                "class Male extends Person {\n  get genderCode() {\n    return \"M\";\n  }\n}",
                "class Female extends Person {\n  get genderCode() {\n    return \"F\";\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get genderCode() { return \"X\"; }\n  get gender() { return this.genderCode; }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nconst male = new Person();\nmale.genderCode = \"M\";\n\nconst female = new Person();\nfemale.genderCode = \"F\";\n```"
            ]
        }
    },
    "FOWLER_EX_INTRODUCE PARAMETER OBJECT": {
        "RefactMethod": "INTRODUCE PARAMETER OBJECT",
        "BeforeRefact": "function amountInvoiced(startDate, endDate) {...}\nfunction amountReceived(startDate, endDate) {...}\nfunction amountOverdue(startDate, endDate) {...}",
        "AfterRefact": "function amountInvoiced(aDateRange) {...}\nfunction amountReceived(aDateRange) {...}\nfunction amountOverdue(aDateRange) {...}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction amountInvoiced(dateRange) {\n    const { startDate, endDate } = dateRange;\n    // ...\n}\n\nfunction amountReceived(dateRange) {\n    const { startDate, endDate } = dateRange;\n    // ...\n}\n\nfunction amountOverdue(dateRange) {\n    const { startDate, endDate } = dateRange;\n    // ...\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class DateRange {\n    constructor(startDate, endDate) {\n        this.startDate = startDate;\n        this.endDate = endDate;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nfunction amountInvoiced(dateRange) {\n    const { startDate, endDate } = dateRange;\n    // implementation\n}\n\nfunction amountReceived(dateRange) {\n    const { startDate, endDate } = dateRange;\n    // implementation\n}\n\nfunction amountOverdue(dateRange) {\n    const { startDate, endDate } = dateRange;\n    // implementation\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction calculateAmount(type, startDate, endDate) {\n    switch (type) {\n        case 'invoiced':\n            return amountInvoiced(startDate, endDate);\n        case 'received':\n            return amountReceived(startDate, endDate);\n        case 'overdue':\n            return amountOverdue(startDate, endDate);\n        default:\n            throw new Error('Invalid type');\n    }\n}\n\nfunction amountInvoiced(startDate, endDate) {\n    // Logic for calculating amount invoiced\n}\n\nfunction amountReceived(startDate, endDate) {\n    // Logic for calculating amount received\n}\n\nfunction amountOverdue(startDate, endDate) {\n    // Logic for calculating amount overdue\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class DateRange {\n    constructor(startDate, endDate) {\n        this.startDate = startDate;\n        this.endDate = endDate;\n    }\n}"
            ],
            "others": [
                "```javascript\nfunction amountInvoiced(dateRange) {...}\nfunction amountReceived(dateRange) {...}\nfunction amountOverdue(dateRange) {...}\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_SPLIT LOOP": {
        "RefactMethod": "SPLIT LOOP",
        "BeforeRefact": "let averageAge = 0;\nlet totalSalary = 0;\nfor (const p of people) {\n    averageAge += p.age;\n    totalSalary += p.salary;\n}\naverageAge = averageAge / people.length;",
        "AfterRefact": "let totalSalary = 0;\nfor (const p of people) {\n    totalSalary += p.salary;\n}\n\nlet averageAge = 0;\nfor (const p of people) {\n    averageAge += p.age;\n}\naverageAge = averageAge / people.length;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet totalAge = 0;\nlet totalSalary = 0;\n\nfor (const p of people) {\n    totalAge += p.age;\n}\naverageAge = totalAge / people.length;\n\nfor (const p of people) {\n    totalSalary += p.salary;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nlet totalAge = 0;\nlet totalSalary = 0;\n\nfor (const p of people) {\n    totalAge += p.age;\n}\n\nfor (const p of people) {\n    totalSalary += p.salary;\n}\n\nlet averageAge = totalAge / people.length;\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst totalAge = people.reduce((sum, p) => sum + p.age, 0);\nconst totalSalary = people.reduce((sum, p) => sum + p.salary, 0);\nconst averageAge = totalAge / people.length;\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE PRIMITIVE WITH OBJECT": {
        "RefactMethod": "REPLACE PRIMITIVE WITH OBJECT",
        "BeforeRefact": "orders.filter(o => \u201chigh\u201d === o.priority\n                || \u201crush\u201d === o.priority);  ",
        "AfterRefact": "orders.filter(o => o.priority.higherThan(new Priority(\u201cnormal\u201d)))",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst highPriority = { priority: \"high\" };\nconst rushPriority = { priority: \"rush\" };\n\norders.filter(o => highPriority.priority === o.priority || rushPriority.priority === o.priority);\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Priority {\n    constructor(value) {\n        this.value = value;\n    }\n\n    get() {\n        return this.value;\n    }\n}",
                "class Order {\n    constructor(priority) {\n        this.priority = new Priority(priority);\n    }\n\n    getPriority() {\n        return this.priority.get();\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\nconst orders = /* existing orders array */;\nconst filteredOrders = orders.filter(o => \n    \"high\" === o.getPriority() || \"rush\" === o.getPriority()\n);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nconst highPriorityOrders = orders.filter(o => \n    ['high', 'rush'].includes(o.priority)\n);\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Priority {\n    constructor(name) {\n        this.name = name;\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nconst HIGH_PRIORITY = new Priority(\"high\");\nconst RUSH_PRIORITY = new Priority(\"rush\");\n\norders.filter(o => HIGH_PRIORITY.name === o.priority || RUSH_PRIORITY.name === o.priority);\n```"
            ]
        }
    },
    "FOWLER_EX_MOVE STATEMENTS TO CALLERS": {
        "RefactMethod": "MOVE STATEMENTS TO CALLERS",
        "BeforeRefact": "emitPhotoData(outStream, person.photo);\n\nfunction emitPhotoData(outStream, photo) {\n  outStream.write(`<p>title: ${photo.title}</p>\\n`);\n  outStream.write(`<p>location: ${photo.location}</p>\\n`);\n}",
        "AfterRefact": "emitPhotoData(outStream, person.photo);\noutStream.write(`<p>location: ${person.photo.location}</p>\\n`);\n\nfunction emitPhotoData(outStream, photo) {\n  outStream.write(`<p>title: ${photo.title}</p>\\n`);\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction emitPhotoData(outStream, photo) {\n  outStream.write(`<p>title: ${photo.title}</p>\\\n`);\n  outStream.write(`<p>location: ${photo.location}</p>\\\n`);\n}\n\noutStream.write(`<p>title: ${person.photo.title}</p>\\\n`);\noutStream.write(`<p>location: ${person.photo.location}</p>\\\n`);\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\noutStream.write(`<p>title: ${person.photo.title}</p>\\\n`);\noutStream.write(`<p>location: ${person.photo.location}</p>\\\n`);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction emitPhotoData(outStream, { title, location }) {\n  outStream.write(`<p>title: ${title}</p>\\\n`);\n  outStream.write(`<p>location: ${location}</p>\\\n`);\n}\n```"
            ]
        }
    },
    "FOWLER_EX_INLINE CLASS": {
        "RefactMethod": "INLINE CLASS",
        "BeforeRefact": "class Person {\n  get officeAreaCode() {return this._telephoneNumber.areaCode;}\n  get officeNumber()   {return this._telephoneNumber.number;}\n}\nclass TelephoneNumber {\n  get areaCode() {return this._areaCode;}\n  get number()   {return this._number;}\n}",
        "AfterRefact": "class Person {\n  get officeAreaCode() {return this._officeAreaCode;}\n  get officeNumber()   {return this._officeNumber;}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get officeAreaCode() { return this._telephoneNumber.areaCode; }\n  get officeNumber()   { return this._telephoneNumber.number; }\n}",
                "class Person {\n  get officeAreaCode() { return this._telephoneNumber._areaCode; }\n  get officeNumber()   { return this._telephoneNumber._number; }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Person {\n  constructor(telephoneNumber) {\n    this._telephoneNumber = telephoneNumber;\n  }\n\n  get officeAreaCode() {\n    return this._telephoneNumber.areaCode;\n  }\n\n  get officeNumber() {\n    return this._telephoneNumber.number;\n  }\n\n  get areaCode() {\n    return this._telephoneNumber.areaCode;\n  }\n\n  get number() {\n    return this._telephoneNumber.number;\n  }\n}",
                "class TelephoneNumber {\n  constructor(areaCode, number) {\n    this._areaCode = areaCode;\n    this._number = number;\n  }\n\n  get areaCode() {\n    return this._areaCode;\n  }\n\n  get number() {\n    return this._number;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get officeAreaCode() {\n    return this.telephoneNumber.areaCode;\n  }\n  \n  get officeNumber() {\n    return this.telephoneNumber.number;\n  }\n  \n  constructor(telephoneNumber) {\n    this.telephoneNumber = telephoneNumber;\n  }\n}",
                "class TelephoneNumber {\n  constructor(areaCode, number) {\n    this._areaCode = areaCode;\n    this._number = number;\n  }\n  \n  get areaCode() {\n    return this._areaCode;\n  }\n  \n  get number() {\n    return this._number;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get officeAreaCode() { return this._telephoneNumber._areaCode; }\n  get officeNumber() { return this._telephoneNumber._number; }\n}",
                "class TelephoneNumber {\n  constructor(areaCode, number) {\n    this._areaCode = areaCode;\n    this._number = number;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REMOVE MIDDLE MAN": {
        "RefactMethod": "REMOVE MIDDLE MAN",
        "BeforeRefact": "manager = aPerson.manager;\n\nclass Person {\n  get manager() {return this.department.manager;}",
        "AfterRefact": "manager = aPerson.department.manager;",
        "ZeroShotCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get manager() { return this.department.manager; }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n// Refactored version\nmanager = this.department.manager;\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get manager() {\n    return this.department.manager;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get manager() {\n    return this.department.manager;\n  }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nconst manager = new Person().manager;\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class Person {\n  get manager() { return this.department.manager; }\n}",
                "class Department {\n  get manager() { return this.head; } // assuming 'head' is the manager of the department\n}",
                "class Manager {\n  // Manager properties and methods\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "FOWLER_EX_REPLACE FUNCTION WITH COMMAND": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "function score(candidate, medicalExam, scoringGuide) {\n    let result = 0;\n    let healthLevel = 0;\n// long body code\n}",
        "AfterRefact": "class Scorer {\n  constructor(candidate, medicalExam, scoringGuide) {\n    this._candidate = candidate;\n    this._medicalExam = medicalExam;\n    this._scoringGuide = scoringGuide;\n  }\n\n  execute() {\n    this._result = 0;\n    this._healthLevel = 0;\n    // long body code\n  }\n}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction calculateScore(candidate, medicalExam, scoringGuide) {\n    let result = 0;\n    let healthLevel = 0;\n    // long body code\n}\n\nfunction score(candidate, medicalExam, scoringGuide) {\n    return calculateScore(candidate, medicalExam, scoringGuide);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [
                "class ScoreCommand {\n    constructor(candidate, medicalExam, scoringGuide) {\n        this.candidate = candidate;\n        this.medicalExam = medicalExam;\n        this.scoringGuide = scoringGuide;\n    }\n\n    execute() {\n        let result = 0;\n        let healthLevel = 0;\n        // long body code\n        return result; // Assuming you want to return some result\n    }\n}"
            ],
            "others": [
                "```javascript\n",
                "\n\nfunction score(candidate, medicalExam, scoringGuide) {\n    const command = new ScoreCommand(candidate, medicalExam, scoringGuide);\n    return command.execute();\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction score(candidate, medicalExam, scoringGuide) {\n    let result = 0;\n    const healthLevel = calculateHealthLevel(medicalExam);\n    \n    // Compute the score based on the scoring guide and candidate's data\n    result += calculateScores(candidate, scoringGuide, healthLevel);\n    \n    return result;\n}\n\nfunction calculateHealthLevel(medicalExam) {\n    // Logic to determine health level based on medicalExam\n}\n\nfunction calculateScores(candidate, scoringGuide, healthLevel) {\n    // Logic to calculate scores based on candidate, scoringGuide, and healthLevel\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```javascript\nfunction score(candidate, medicalExam, scoringGuide) {\n    let result = 0;\n    let healthLevel = 0;\n    // long body code\n}\n```"
            ]
        }
    },
    "L10937": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "\n\tpublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "AfterRefact": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tRuleFunction rf = getCurrentRuleFunction();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tdefineImplicitLabel(setAST, matchOp);\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\t\tmatchOp.labels.add(d);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        Decl d = processLabel(labelAST, setAST);\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(labelAST.getText());\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) \n        defineImplicitLabel(setAST, matchOp);\n        \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}",
                "private Decl processLabel(GrammarAST labelAST, GrammarAST setAST) {\n    String label = labelAST.getText();\n    Decl d = getTokenLabelDecl(label);\n    matchOp.labels.add(d);\n    getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n    return d;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    boolean needsImplicitLabel = controller.needsImplicitLabel(setAST, matchOp);\n    if (needsImplicitLabel) defineImplicitLabel(setAST, matchOp);\n\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        addContextDecl(setAST, d, labelAST);\n    }\n\n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}",
                "private void addContextDecl(GrammarAST setAST, Decl d, GrammarAST labelAST) {\n    getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n    if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n        TokenListDecl l = getTokenListLabelDecl(labelAST.getText());\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        handleLabelAST(labelAST, setAST, matchOp);\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}",
                "private void handleLabelAST(GrammarAST labelAST, GrammarAST setAST, MatchSet matchOp) {\n    String label = labelAST.getText();\n    Decl d = getTokenLabelDecl(label);\n    matchOp.labels.add(d);\n    getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\n    if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n        TokenListDecl l = getTokenListLabelDecl(label);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5343": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public List<ParseTreeListener> getParseListeners() {\n        return _parseListeners;\n    }",
        "AfterRefact": "public List<ParseTreeListener> getParseListeners() {\n\t\tList<ParseTreeListener> listeners = _parseListeners;\n\t\tif (listeners == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn listeners;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    return new ArrayList<>(_parseListeners);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3671": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": " public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t@NotNull BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportAmbiguity d=\" + dfa.decision +\n\t\t\t\": ambigAlts=\" + ambigAlts + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }",
        "AfterRefact": "public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa,\n\t\t\t\t\t\t\t\tint startIndex,\n\t\t\t\t\t\t\t\tint stopIndex,\n\t\t\t\t\t\t\t\tboolean exact,\n\t\t\t\t\t\t\t\t@Nullable BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n\t{\n\t\tif (exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\n\t\tString format = \"reportAmbiguity d=%s: ambigAlts=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tBitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, conflictingAlts, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs)\n{\n    String decision = \"reportAmbiguity d=\" + dfa.decision;\n    String ambiguousAlternatives = \"ambigAlts=\" + ambigAlts;\n    String inputText = \"input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    \n    recognizer.notifyErrorListeners(decision + \": \" + ambiguousAlternatives + \", \" + inputText);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) \n{\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = \"reportAmbiguity d=\" + dfa.decision +\n                     \": ambigAlts=\" + ambigAlts + \", input=\\'\" + inputText + \"\\'\";\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs)\n{\n    String decision = \"reportAmbiguity d=\" + dfa.decision;\n    String ambiguousAlts = \": ambigAlts=\" + ambigAlts;\n    String inputText = \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    \n    recognizer.notifyErrorListeners(decision + ambiguousAlts + inputText);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer, DFA dfa, int startIndex, int stopIndex, \n                            @NotNull BitSet ambigAlts, @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = String.format(\"reportAmbiguity d=%d: ambigAlts=%s, input=\\'%s\\'\", \n                                     dfa.decision, ambigAlts, inputText);\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String message = \"reportAmbiguity d=\" + dfa.decision +\n                     \": ambigAlts=\" + ambigAlts + \n                     \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3692": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n                                         int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n\t\t\tdfa.decision + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }\n}",
        "AfterRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n\t{\n\t\tString format = \"reportContextSensitivity d=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                     @NotNull DFA dfa,\n                                     int startIndex, int stopIndex,\n                                     @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String errorMessage = String.format(\"reportContextSensitivity d=%d, input=\\'%s\\'\", dfa.decision, inputText);\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" + dfa.decision + \", input=\\'\" + inputText + \"\\'\");\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs)\n{\n    String decisionMessage = \"reportContextSensitivity d=\" + dfa.decision;\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    recognizer.notifyErrorListeners(decisionMessage + \", input=\\'\" + inputText + \"\\'\");\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer, @NotNull DFA dfa, \n                                      int startIndex, int stopIndex, \n                                      @NotNull ATNConfigSet configs) {\n    String errorMessage = String.format(\"reportContextSensitivity d=%d, input=\\'%s\\'\",\n            dfa.decision, recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)));\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String errorMessage = \"reportContextSensitivity d=\" + dfa.decision + \n                          \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L7413": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "AfterRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\n\t\t\tassert s.decision + 1 >= g.decisionLOOK.size();\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        assert s != null : \"DecisionState should not be null\";\n        \n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        \n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n\n        // Introduced assertion to verify look is not null\n        assert look != null : \"Lookahead array should not be null for decision \" + s.decision;\n        \n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n\n        assert(s.getNumberOfTransitions() >= 0); // Assertion for non-negative transitions\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void processParser() {\n    initializeDecisionLook();\n    \n    for (DecisionState decisionState : g.atn.decisionToState) {\n        logDecisionInfo(decisionState);\n        IntervalSet[] lookaheadSets = determineLookaheadSets(decisionState);\n        updateDecisionLook(decisionState, lookaheadSets);\n        logLookaheadResult(lookaheadSets);\n    }\n}",
                "private void initializeDecisionLook() {\n    g.decisionLOOK = new ArrayList<>(g.atn.getNumberOfDecisions() + 1);\n}",
                "private void logDecisionInfo(DecisionState decisionState) {\n    g.tool.log(\"LL1\", \"\\\nDECISION \" + decisionState.decision + \" in rule \" + g.getRule(decisionState.ruleIndex).name);\n}",
                "private IntervalSet[] determineLookaheadSets(DecisionState decisionState) {\n    if (decisionState.nonGreedy) {\n        return new IntervalSet[decisionState.getNumberOfTransitions() + 1];\n    } else {\n        LL1Analyzer analyzer = new LL1Analyzer(g.atn);\n        IntervalSet[] lookaheadSets = analyzer.getDecisionLookahead(decisionState);\n        g.tool.log(\"LL1\", \"look=\" + Arrays.toString(lookaheadSets));\n        return lookaheadSets;\n    }\n}",
                "private void updateDecisionLook(DecisionState decisionState, IntervalSet[] lookaheadSets) {\n    Utils.setSize(g.decisionLOOK, decisionState.decision + 1);\n    g.decisionLOOK.set(decisionState.decision, lookaheadSets);\n}",
                "private void logLookaheadResult(IntervalSet[] lookaheadSets) {\n    g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(lookaheadSets));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if (s.nonGreedy) { \n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L10037": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tIntervalSet enterLook = altLookSets[1];\n\t\tIntervalSet exitLook = altLookSets[2];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "AfterRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tassert altLookSets.length == 2;\n\t\tIntervalSet enterLook = altLookSets[0];\n\t\tIntervalSet exitLook = altLookSets[1];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n\n    assert enterLook != null : \"enterLook cannot be null\";\n    assert exitLook != null : \"exitLook cannot be null\";\n\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n    assert star != null : \"starRoot.atnState should not be null and must be an instance of StarLoopEntryState\";\n    \n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    \n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets != null : \"altLookSets should not be null for the current decision\";\n    \n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    \n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets != null : \"altLookSets should not be null for decision: \" + decision;\n    \n    IntervalSet enterLook = altLookSets[1];\n    assert enterLook != null : \"enterLook should not be null for decision: \" + decision;\n\n    IntervalSet exitLook = altLookSets[2];\n    assert exitLook != null : \"exitLook should not be null for decision: \" + decision;\n\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class LL1StarBlockSingleAlt {\n\tprivate final OutputModelFactory factory;\n\tprivate final GrammarAST starRoot;\n\tprivate final List<CodeBlockForAlt> alts;\n\tprivate final int loopBackStateNumber;\n\tprivate final int decision;\n\tprivate final IntervalSet loopExpr;\n\n\tpublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tthis.factory = factory;\n\t\tthis.starRoot = starRoot;\n\t\tthis.alts = alts;\n\n\t\tStarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n\t\tthis.loopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tIntervalSet enterLook = altLookSets[1];\n\t\tIntervalSet exitLook = altLookSets[2];\n\t\tthis.loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        }
    },
    "L1927": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(\"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tATNConfigSet closure = s.configs;\n\t\t\tDFAState target = null;\n\t\t\tif ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {\n\t\t\t\ttarget = s.edges[t - MIN_DFA_EDGE];\n\t\t\t\tif (target == ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (debug && target != null) {\n\t\t\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (target == null) {\n\t\t\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t\t\t// if we don't find an existing DFA state\n\t\t\t\t// Fill reach starting from closure, following t transitions\n\t\t\t\tgetReachableConfigSet(input, closure, reach, t);\n\n\t\t\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t\t\t// we reached state associated with closure for sure, so\n\t\t\t\t\t// make sure it's defined. worst case, we define s0 from\n\t\t\t\t\t// start state configs.\n\t\t\t\t\t@NotNull\n\t\t\t\t\tDFAState from = s != null ? s : addDFAState(closure);\n\t\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t\t// cause a failover from DFA later.\n\t\t\t\t\taddDFAEdge(from, t, ERROR);\n\t\t\t\t\tbreak; // stop when we can't match any more char\n\t\t\t\t}\n\n\t\t\t\t// Add an edge from s to target DFA found/created for reach\n\t\t\t\ttarget = addDFAEdge(s, t, reach);\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}",
        "AfterRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(Locale.getDefault(), \"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tDFAState target = getExistingTargetState(s, t);\n\t\t\tif (target == null) {\n\t\t\t\ttarget = computeTargetState(input, s, t);\n\t\t\t}\n\n\t\t\tif (target == ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\t@Nullable\n\tprotected DFAState getExistingTargetState(@NotNull DFAState s, int t) {\n\t\tif (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tDFAState target = s.edges[t - MIN_DFA_EDGE];\n\t\tif (debug && target != null) {\n\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link #ERROR}.\n\t */\n\t@NotNull\n\tprotected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {\n\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tgetReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t// cause a failover from DFA later.\n\t\t\taddDFAEdge(s, t, ERROR);\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ERROR;\n\t\t}\n\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn addDFAEdge(s, t, reach);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = getTargetState(s, t);\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull\n                DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break; // stop when we can\\'t match any more char\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug && target != null) {\n                System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        @NotNull DFAState target = handleDFAEdges(input, s, t);\n        if (target == null) {\n            handleNoExistingDFAState(input, s, t);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private void handleNoExistingDFAState(@NotNull CharStream input, @NotNull DFAState s, int t) {\n    ATNConfigSet reach = new OrderedATNConfigSet();\n    getReachableConfigSet(input, s.configs, reach, t);\n\n    if (reach.isEmpty()) {\n        @NotNull DFAState from = s != null ? s : addDFAState(s.configs);\n        addDFAEdge(from, t, ERROR);\n        return;\n    }\n\n    addDFAEdge(s, t, reach);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\nprivate @NotNull DFAState handleDFAEdges(@NotNull CharStream input, @NotNull DFAState s, int t) {\n    ATNConfigSet closure = s.configs;\n    DFAState target = null;\n\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n    }\n    return target;\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0; // s is current/from DFA state\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        DFAState target = getTargetState(s, t);\n        if (target == null) {\n            ATNConfigSet closure = s.configs;\n            target = handleNoTargetState(input, closure, t, s);\n            if (target == null) {\n                break; // stop when we can\\'t match any more char\n            }\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}",
                "private DFAState handleNoTargetState(@NotNull CharStream input, ATNConfigSet closure, int t, @NotNull DFAState s) {\n    ATNConfigSet reach = new OrderedATNConfigSet();\n    getReachableConfigSet(input, closure, reach, t);\n\n    if (reach.isEmpty()) { // we got nowhere on t from s\n        @NotNull DFAState from = s != null ? s : addDFAState(closure);\n        addDFAEdge(from, t, ERROR);\n        return null; // stop when we can\\'t match any more char\n    }\n\n    // Add an edge from s to target DFA found/created for reach\n    return addDFAEdge(s, t, reach);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState currentState = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", currentState.configs);\n        }\n\n        ATNConfigSet closure = currentState.configs;\n        DFAState target = getDfaTarget(currentState, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull DFAState from = currentState != null ? currentState : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n\n            target = addDFAEdge(currentState, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        currentState = target;\n    }\n\n    return failOrAccept(prevAccept, input, currentState.configs, t);\n}",
                "private DFAState getDfaTarget(DFAState state, int t) {\n    if (state.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = state.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug) {\n                System.out.println(\"reuse state \" + state.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = null;\n        target = getTargetState(s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) { // we got nowhere on t from s\n                @NotNull DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break; // stop when we can\\'t match any more char\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L540": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t DFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t boolean exact,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // method implementation\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // Method implementation\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs,\n                     boolean exact) {\n    // Implementation for handling ambiguity with the extra 'exact' parameter\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // Implementation here\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, int startIndex, int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs,\n                     MethodObject methodObject) {\n    // Method body replaced with method object invocation\n    methodObject.invoke(recognizer, dfa, startIndex, stopIndex, ambigAlts, configs);\n}\n```"
            ]
        }
    },
    "L561": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t @Nullable BitSet conflictingAlts,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs);\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Function logic here\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer, \n                                  @NotNull DFA dfa, \n                                  int startIndex, \n                                  int stopIndex, \n                                  @NotNull ATNConfigSet configs) {\n    // Method implementation here\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs,\n                                  MethodObject methodObject) {\n    // Implementation using methodObject instead of directly using this method\n}\n```"
            ]
        }
    },
    "L5431": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\t\tif (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n\t}",
        "AfterRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\n\t\tif (_buildParseTrees && _parentctx != null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\t_parentctx.addChild(retctx);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null || _ctx == _parentctx) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    \n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null || _ctx != _parentctx) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext parentCtx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext returnCtx = _ctx; // save current ctx (return value)\n\n    if (_parseListeners != null) {\n        while (_ctx != parentCtx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = parentCtx;\n    }\n\n    // Hook into tree\n    returnCtx.parent = parentCtx;\n    if (_buildParseTrees) {\n        parentCtx.addChild(returnCtx); // add return ctx into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    _ctx = (_parseListeners != null) ? unrollWithListeners(_parentctx) : _parentctx;\n\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}",
                "private ParserRuleContext unrollWithListeners(ParserRuleContext _parentctx) {\n    while (_ctx != _parentctx) {\n        triggerExitRuleEvent();\n        _ctx = (ParserRuleContext) _ctx.parent;\n    }\n    return _ctx;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L3844": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "AfterRefact": " public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "ZeroShotCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = p < 0 ? false : (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size());\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p < 0) ? false :\n                          (fetchedEOF ? (p < tokens.size() - 1) : (p < tokens.size()));\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p >= 0) ? (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size()) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = shouldSkipEofCheck(p, fetchedEOF);\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}",
                "private boolean shouldSkipEofCheck(int index, boolean fetchedEOF) {\n    if (index < 0) {\n        return false; // not yet initialized\n    }\n    return fetchedEOF ? index < tokens.size() - 1 : index < tokens.size();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p >= 0) ? (fetchedEOF ? (p < tokens.size() - 1) : (p < tokens.size())) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3168": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates.\n\t\t */\n\t\tif (skippedStopStates == null) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "AfterRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates, or when the current symbol is EOF.\n\t\t */\n\t\tif (skippedStopStates == null && t != Token.EOF) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tboolean treatEofAsEpsilon = t == Token.EOF;\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) {\n        System.out.println(\"in computeReachSet, starting closure: \" + closure);\n    }\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) {\n            System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n        }\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = determineReach(intermediate, skippedStopStates, fullCtx);\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}",
                "private ATNConfigSet determineReach(ATNConfigSet intermediate, List<ATNConfig> skippedStopStates, boolean fullCtx) {\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            return intermediate;\n        }\n    }\n    \n    ATNConfigSet reach = new ATNConfigSet(fullCtx);\n    Set<ATNConfig> closureBusy = new HashSet<>();\n    for (ATNConfig c : intermediate) {\n        closure(c, reach, closureBusy, false, fullCtx);\n    }\n    \n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L10263": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenDisplayNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        marked.add(s);\n        processStateTransitions(s, buf);\n    }\n    return buf.toString();\n}",
                "private void processStateTransitions(ATNState s, StringBuilder buf) {\n    int n = s.getNumberOfTransitions();\n    \n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        addToWork(s, t);\n\n        buf.append(getStateString(s));\n        appendTransitionDetails(t, buf);\n    }\n}",
                "private void addToWork(ATNState s, Transition t) {\n    if (!(s instanceof RuleStopState)) {\n        if (t instanceof RuleTransition) {\n            work.add(((RuleTransition) t).followState);\n        } else {\n            work.add(t.target);\n        }\n    }\n}",
                "private void appendTransitionDetails(Transition t, StringBuilder buf) {\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition) t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition) t;\n        boolean not = st instanceof NotSetTransition;\n        if (g.isLexer()) {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        } else {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        }\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition) t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        \n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition)t).followState);\n                else work.add(t.target);\n            }\n            appendTransitionInfo(buf, t, s);\n        }\n    }\n    return buf.toString();\n}",
                "private void appendTransitionInfo(StringBuilder buf, Transition t, ATNState s) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition)t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition)t;\n        boolean not = st instanceof NotSetTransition;\n        if (g.isLexer()) {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        } else {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        }\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition)t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n            buf.append(getStateString(s));\n            appendTransitionDetails(buf, t);\n        }\n    }\n    return buf.toString();\n}",
                "private void appendTransitionDetails(StringBuilder buf, Transition t) {\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name)\n           .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition) t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition) t;\n        boolean not = st instanceof NotSetTransition;\n        if (g.isLexer()) {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString())\n               .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        } else {\n            buf.append(\"-\").append(not ? \"~\" : \"\")\n               .append(st.label().toString(g.getTokenNames()))\n               .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        }\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition) t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n\n    marked = new HashSet<>();\n    work = new ArrayList<>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n\n    while (!work.isEmpty()) {\n        ATNState s = work.remove(0);\n        if (marked.contains(s)) continue;\n\n        marked.add(s);\n        processStateTransitions(s, buf);\n    }\n    return buf.toString();\n}",
                "private void processStateTransitions(ATNState s, StringBuilder buf) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        addTransitionToWork(s, t);\n        appendTransitionDescription(s, t, buf);\n    }\n}",
                "private void addTransitionToWork(ATNState s, Transition t) {\n    if (!(s instanceof RuleStopState)) {\n        if (t instanceof RuleTransition) {\n            work.add(((RuleTransition) t).followState);\n        } else {\n            work.add(t.target);\n        }\n    }\n}",
                "private void appendTransitionDescription(ATNState s, Transition t, StringBuilder buf) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name)\n           .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        appendSetTransitionDescription((SetTransition) t, buf);\n    } else if (t instanceof AtomTransition) {\n        String label = g.getTokenDisplayName(((AtomTransition) t).label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}",
                "private void appendSetTransitionDescription(SetTransition st, StringBuilder buf) {\n    boolean not = st instanceof NotSetTransition;\n    String prefix = (g.isLexer()) ? (not ? \"~\" : \"\") : (not ? \"~\" : st.label().toString(g.getTokenNames()));\n    buf.append(\"-\").append(prefix).append(st.toString()).append(\"->\").append(getStateString(st.target)).append(\\'\\\n\\');\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) {\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n            appendTransitionDetails(buf, s, t);\n        }\n    }\n    return buf.toString();\n}",
                "private void appendTransitionDetails(StringBuilder buf, ATNState s, Transition t) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition) t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition) t;\n        boolean not = st instanceof NotSetTransition;\n        buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition) t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L102630": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "AfterRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) {\n        return \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        return \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        return \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        return \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        return \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        return \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        return \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        return \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        return \"StarLoopEntry_\" + n;\n    }\n\n    return stateStr;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) \n        stateStr = \"StarBlockStart_\" + n;\n    else if (s instanceof PlusBlockStartState) \n        stateStr = \"PlusBlockStart_\" + n;\n    else if (s instanceof BlockStartState) \n        stateStr = \"BlockStart_\" + n;\n    else if (s instanceof BlockEndState) \n        stateStr = \"BlockEnd_\" + n;\n    else if (s instanceof RuleStartState) \n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    else if (s instanceof RuleStopState) \n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    else if (s instanceof PlusLoopbackState) \n        stateStr = \"PlusLoopBack_\" + n;\n    else if (s instanceof StarLoopbackState) \n        stateStr = \"StarLoopBack_\" + n;\n    else if (s instanceof StarLoopEntryState) \n        stateStr = \"StarLoopEntry_\" + n;\n\n    return stateStr;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    }\n\n    return stateStr;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private String getStatePrefix(ATNState s) {\n    if (s instanceof StarBlockStartState) return \"StarBlockStart_\";\n    if (s instanceof PlusBlockStartState) return \"PlusBlockStart_\";\n    if (s instanceof BlockStartState) return \"BlockStart_\";\n    if (s instanceof BlockEndState) return \"BlockEnd_\";\n    if (s instanceof PlusLoopbackState) return \"PlusLoopBack_\";\n    if (s instanceof StarLoopbackState) return \"StarLoopBack_\";\n    if (s instanceof StarLoopEntryState) return \"StarLoopEntry_\";\n    return \"s\";\n}"
            ],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr;\n\n    if (s instanceof RuleStartState || s instanceof RuleStopState) {\n        String ruleName = g.getRule(s.ruleIndex).name;\n        stateStr = (s instanceof RuleStartState ? \"RuleStart_\" : \"RuleStop_\") + ruleName + \"_\" + n;\n    } else {\n        stateStr = getStatePrefix(s) + n;\n    }\n\n    return stateStr;\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String execute() {\n        int n = state.stateNumber;\n        String stateStr = \"s\" + n;\n        if (state instanceof StarBlockStartState) stateStr = \"StarBlockStart_\" + n;\n        else if (state instanceof PlusBlockStartState) stateStr = \"PlusBlockStart_\" + n;\n        else if (state instanceof BlockStartState) stateStr = \"BlockStart_\" + n;\n        else if (state instanceof BlockEndState) stateStr = \"BlockEnd_\" + n;\n        else if (state instanceof RuleStartState) stateStr = \"RuleStart_\" + g.getRule(state.ruleIndex).name + \"_\" + n;\n        else if (state instanceof RuleStopState) stateStr = \"RuleStop_\" + g.getRule(state.ruleIndex).name + \"_\" + n;\n        else if (state instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\" + n;\n        else if (state instanceof StarLoopbackState) stateStr = \"StarLoopBack_\" + n;\n        else if (state instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\" + n;\n        return stateStr;\n    }"
            ],
            "classes": [
                "class GetStateStringMethod {\n    private ATNState state;\n\n    public GetStateStringMethod(ATNState state) {\n        this.state = state;\n    }\n\n    public String execute() {\n        int n = state.stateNumber;\n        String stateStr = \"s\" + n;\n        if (state instanceof StarBlockStartState) stateStr = \"StarBlockStart_\" + n;\n        else if (state instanceof PlusBlockStartState) stateStr = \"PlusBlockStart_\" + n;\n        else if (state instanceof BlockStartState) stateStr = \"BlockStart_\" + n;\n        else if (state instanceof BlockEndState) stateStr = \"BlockEnd_\" + n;\n        else if (state instanceof RuleStartState) stateStr = \"RuleStart_\" + g.getRule(state.ruleIndex).name + \"_\" + n;\n        else if (state instanceof RuleStopState) stateStr = \"RuleStop_\" + g.getRule(state.ruleIndex).name + \"_\" + n;\n        else if (state instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\" + n;\n        else if (state instanceof StarLoopbackState) stateStr = \"StarLoopBack_\" + n;\n        else if (state instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\" + n;\n        return stateStr;\n    }\n}"
            ],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L15668": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addStopStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addStopStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1;\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" :\n                    (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState && d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // Define stop states first; seems to be a bug in DOT where doublecircle\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        addStopState(dot, d);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        addState(dot, d);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            addEdges(dot, d, isLexer);\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addStopState(ST dot, DFAState d) {\n    ST st = stlib.getInstanceOf(\"stopstate\");\n    st.add(\"name\", \"s\" + d.stateNumber);\n    st.add(\"label\", getStateLabel(d));\n    dot.add(\"states\", st);\n}",
                "private void addState(ST dot, DFAState d) {\n    ST st = stlib.getInstanceOf(\"state\");\n    st.add(\"name\", \"s\" + d.stateNumber);\n    st.add(\"label\", getStateLabel(d));\n    dot.add(\"states\", st);\n}",
                "private void addEdges(ST dot, DFAState d, boolean isLexer) {\n    for (int i = 0; i < d.edges.length; i++) {\n        DFAState target = d.edges[i];\n        if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n        int ttype = i - 1; // we shift up for EOF as -1 for parser\n        String label = String.valueOf(ttype);\n        if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n        else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n        \n        ST st = stlib.getInstanceOf(\"edge\");\n        st.add(\"label\", label);\n        st.add(\"src\", \"s\" + d.stateNumber);\n        st.add(\"target\", \"s\" + target.stateNumber);\n        st.add(\"arrowhead\", arrowhead);\n        dot.add(\"edges\", st);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addStopStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addStopStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges == null) continue;\n        for (int i = 0; i < d.edges.length; i++) {\n            DFAState target = d.edges[i];\n            if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n            int ttype = i - 1; \n            String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n            ST st = stlib.getInstanceOf(\"edge\");\n            st.add(\"label\", label);\n            st.add(\"src\", \"s\" + d.stateNumber);\n            st.add(\"target\", \"s\" + target.stateNumber);\n            st.add(\"arrowhead\", arrowhead);\n            dot.add(\"edges\", st);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    defineStopStates(dot, dfa);\n    defineRegularStates(dot, dfa);\n    defineEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void defineStopStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void defineRegularStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void defineEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L156680": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    return Utils.sortLinesInString(dot.render());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addStopStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addStopStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + state.stateNumber);\n            st.add(\"label\", getStateLabel(state));\n            dot.add(\"states\", st);\n        }\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (!state.isAcceptState && state.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + state.stateNumber);\n            st.add(\"label\", getStateLabel(state));\n            dot.add(\"states\", st);\n        }\n    }\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.edges != null) {\n            for (int i = 0; i < state.edges.length; i++) {\n                DFAState target = state.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = getEdgeLabel(isLexer, i, ttype);\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + state.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n}",
                "private String getEdgeLabel(boolean isLexer, int i, int ttype) {\n    if (isLexer) {\n        return \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n    } else if (grammar != null) {\n        return grammar.getTokenDisplayName(ttype);\n    }\n    return String.valueOf(ttype);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        ST st;\n        if (d.isAcceptState) {\n            st = stlib.getInstanceOf(\"stopstate\");\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            st = stlib.getInstanceOf(\"state\");\n        } else {\n            continue;\n        }\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n\n                int ttype = i - 1; // shift up for EOF as -1 for parser\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : \n                                           grammar != null ? grammar.getTokenDisplayName(ttype) : \n                                           String.valueOf(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3347": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(ATNConfig config,\n\t\t\t\t\t\t\tATNConfigSet configs,\n\t\t\t\t\t\t\tSet<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_dfa != null && _dfa.isPrecedenceDfa()) {\n\t\t\t\t\t\tint outermostPrecedenceReturn = ((EpsilonTransition)t).outermostPrecedenceReturn();\n\t\t\t\t\t\tif (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {\n\t\t\t\t\t\t\tc.setPrecedenceFilterSuppressed(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        \n        if (c != null) {\n            if (!t.isEpsilon()) {\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                handleRuleStopState(c, configs, closureBusy, newDepth);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}",
                "private void handleRuleStopState(ATNConfig c, ATNConfigSet configs, Set<ATNConfig> closureBusy, int newDepth) {\n    assert !fullCtx;\n    if (!closureBusy.add(c)) {\n        return;\n    }\n    c.reachesIntoOuterContext++;\n    configs.dipsIntoOuterContext = true; \n    assert newDepth > Integer.MIN_VALUE;\n    newDepth--;\n    if (debug) System.out.println(\"dips into outer ctx: \" + c);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon)\n{\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true; \n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState state = config.state;\n    \n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean shouldCollectPredicates = !(transition instanceof ActionTransition) && collectPredicates;\n        ATNConfig targetConfig = getEpsilonTarget(config, transition, shouldCollectPredicates,\n                                                  depth == 0, fullCtx, treatEofAsEpsilon);\n        if (targetConfig != null) {\n            if (!transition.isEpsilon() && !closureBusy.add(targetConfig)) {\n                continue; // avoid infinite recursion for EOF* and EOF+\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(targetConfig)) {\n                    continue; // avoid infinite recursion for right-recursive rules\n                }\n\n                targetConfig.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true; \n                newDepth--;\n                assert newDepth > Integer.MIN_VALUE;\n\n            } else if (transition instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(targetConfig, configs, closureBusy, shouldCollectPredicates,\n                                     fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    \n    ATNState p = config.state;\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        \n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n\n                if (debug) {\n                    System.out.println(\"dips into outer ctx: \" + c);\n                }\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2755": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof AbstractPredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        handleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, stopState, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        return;\n    }\n\n    processTransitions(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n}",
                "private void handleStopState(@Nullable PredictionContext ctx, @NotNull IntervalSet look, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n}",
                "private void handleRuleStopState(@Nullable PredictionContext ctx, @Nullable ATNState stopState, \n                                  @NotNull IntervalSet look, @NotNull Set<ATNConfig> lookBusy, \n                                  @NotNull BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    } else if (ctx != PredictionContext.EMPTY) {\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}",
                "private void processTransitions(ATNState s, @Nullable ATNState stopState,\n                                @Nullable PredictionContext ctx, @NotNull IntervalSet look, \n                                @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack, \n                                boolean seeThruPreds, boolean addEOF) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            processRuleTransition((RuleTransition) t, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            processPredicateTransition(t, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            processOtherTransitions(t, look);\n        }\n    }\n}",
                "private void processRuleTransition(RuleTransition t, @Nullable ATNState stopState, \n                                    @Nullable PredictionContext ctx, @NotNull IntervalSet look, \n                                    @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack, \n                                    boolean seeThruPreds, boolean addEOF) {\n    if (calledRuleStack.get(t.target.ruleIndex)) {\n        return;\n    }\n    PredictionContext newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n    try {\n        calledRuleStack.set(t.target.ruleIndex);\n        _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } finally {\n        calledRuleStack.clear(t.target.ruleIndex);\n    }\n}",
                "private void processPredicateTransition(Transition t, @Nullable ATNState stopState, \n                                        @Nullable PredictionContext ctx, @NotNull IntervalSet look, \n                                        @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack, \n                                        boolean seeThruPreds, boolean addEOF) {\n    if (seeThruPreds) {\n        _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } else {\n        look.add(HIT_PRED);\n    }\n}",
                "private void processOtherTransitions(Transition t, @NotNull IntervalSet look) {\n    IntervalSet set = t.label();\n    if (set != null) {\n        if (t instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        look.addAll(set);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext =\n                    SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState state,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext context,\n                     @NotNull IntervalSet lookahead,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    \n    ATNConfig config = new ATNConfig(state, 0, context);\n    if (!lookBusy.add(config)) return;\n\n    if (state == stopState) {\n        handleStopState(context, lookahead, addEOF);\n        return;\n    }\n\n    if (state instanceof RuleStopState) {\n        handleRuleStopState(context, lookahead, stopState, calledRuleStack, addEOF);\n        return;\n    }\n\n    processTransitions(state, stopState, context, lookahead, lookBusy, calledRuleStack, seeThruPreds);\n}",
                "private void handleStopState(@Nullable PredictionContext context, \n                              @NotNull IntervalSet lookahead, \n                              boolean addEOF) {\n    if (context == null) {\n        lookahead.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookahead.add(Token.EOF);\n    }\n}",
                "private void handleRuleStopState(@Nullable PredictionContext context, \n                                  @NotNull IntervalSet lookahead, \n                                  @Nullable ATNState stopState, \n                                  @NotNull BitSet calledRuleStack, \n                                  boolean addEOF) {\n    if (context == null) {\n        lookahead.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookahead.add(Token.EOF);\n    }\n\n    if (context != PredictionContext.EMPTY) {\n        for (int i = 0; i < context.size(); i++) {\n            ATNState returnState = atn.states.get(context.getReturnState(i));\n            boolean wasSet = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, context.getParent(i), lookahead, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (wasSet) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}",
                "private void processTransitions(@NotNull ATNState state, \n                                @Nullable ATNState stopState, \n                                @Nullable PredictionContext context, \n                                @NotNull IntervalSet lookahead, \n                                @NotNull Set<ATNConfig> lookBusy, \n                                @NotNull BitSet calledRuleStack, \n                                boolean seeThruPreds) {\n    \n    int transitionCount = state.getNumberOfTransitions();\n    for (int i = 0; i < transitionCount; i++) {\n        Transition transition = state.transition(i);\n        if (transition instanceof RuleTransition) {\n            processRuleTransition((RuleTransition) transition, context, stopState, lookahead, lookBusy, calledRuleStack, seeThruPreds);\n        } else if (transition instanceof PredicateTransition) {\n            processPredicateTransition(transition, context, lookahead, seeThruPreds);\n        } else if (transition.isEpsilon()) {\n            _LOOK(transition.target, stopState, context, lookahead, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (transition instanceof WildcardTransition) {\n            lookahead.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            processOtherTransitions(transition, lookahead);\n        }\n    }\n}",
                "private void processRuleTransition(RuleTransition ruleTransition, \n                                    @Nullable PredictionContext context, \n                                    @Nullable ATNState stopState, \n                                    @NotNull IntervalSet lookahead, \n                                    @NotNull Set<ATNConfig> lookBusy, \n                                    @NotNull BitSet calledRuleStack, \n                                    boolean seeThruPreds) {\n    if (calledRuleStack.get(ruleTransition.target.ruleIndex)) return;\n\n    PredictionContext newContext = SingletonPredictionContext.create(context, ruleTransition.followState.stateNumber);\n    try {\n        calledRuleStack.set(ruleTransition.target.ruleIndex);\n        _LOOK(ruleTransition.target, stopState, newContext, lookahead, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } finally {\n        calledRuleStack.clear(ruleTransition.target.ruleIndex);\n    }\n}",
                "private void processPredicateTransition(Transition transition, \n                                        @Nullable PredictionContext context, \n                                        @NotNull IntervalSet lookahead, \n                                        boolean seeThruPreds) {\n    if (seeThruPreds) {\n        _LOOK(transition.target, stopState, context, lookahead, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } else {\n        lookahead.add(HIT_PRED);\n    }\n}",
                "private void processOtherTransitions(Transition transition, \n                                      @NotNull IntervalSet lookahead) {\n    IntervalSet labels = transition.label();\n    if (labels != null) {\n        if (transition instanceof NotSetTransition) {\n            labels = labels.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        lookahead.addAll(labels);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    \n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L13228": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tFileReader fr = new FileReader(fullFile);\n\t\t\tBufferedReader br = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  ioe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\treturn tokens;\n\t}",
        "AfterRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\tFileReader fr = null;\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tfr = new FileReader(fullFile);\n\t\t\tbr = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token type: \"+tokenTypeS,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t\ttokenType = Token.INVALID_TOKEN_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ( br!=null ) br.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t\t  ioe);\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private void processTokenDef(String tokenDef, Pattern tokenDefPattern, Map<String, Integer> tokens, int lineNum) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else {\n        if (!tokenDef.isEmpty()) { // ignore blank lines\n            tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                  \" bad token def: \" + tokenDef,\n                                  lineNum);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n\n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        String tokenDef;\n        int lineNum = 1;\n\n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDef(tokenDef, tokenDefPattern, tokens, lineNum);\n            lineNum++;\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n\n    return tokens;\n}\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\tint maxTokenType = -1;\n\tFile fullFile = getImportedVocabFile();\n\tPattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n\t\n\ttry (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n\t\tString tokenDef = br.readLine();\n\t\tint lineNum = 1;\n\t\twhile (tokenDef != null) {\n\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\tif (matcher.find()) {\n\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\tint tokenType = Integer.valueOf(matcher.group(2));\n\t\t\t\ttool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\tmaxTokenType = Math.max(maxTokenType, tokenType);\n\t\t\t\tlineNum++;\n\t\t\t} else {\n\t\t\t\tif (tokenDef.length() > 0) { // ignore blank lines\n\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t  \" bad token def: \" + tokenDef,\n\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokenDef = br.readLine();\n\t\t}\n\t} catch (FileNotFoundException fnfe) {\n\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t  fullFile);\n\t} catch (IOException ioe) {\n\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t  ioe);\n\t} catch (Exception e) {\n\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t  e);\n\t}\n\treturn tokens;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef;\n        int lineNum = 1;\n        while ((tokenDef = br.readLine()) != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                int tokenType = Integer.valueOf(matcher.group(2));\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n            } else if (tokenDef.length() > 0) { // ignore blank lines\n                tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                      vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                      \" bad token def: \" + tokenDef,\n                                      lineNum);\n            }\n            lineNum++;\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    return tokens;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void processTokenDefinition(Map<String, Integer> tokens, String tokenDef, int lineNum, Pattern tokenDefPattern) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (!tokenDef.trim().isEmpty()) { // ignore blank lines\n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                              vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                              \" bad token def: \" + tokenDef,\n                              lineNum);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n\n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        String tokenDef;\n        int lineNum = 1;\n\n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokens, tokenDef, lineNum, tokenDefPattern);\n            lineNum++;\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n\n    return tokens;\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private void loadTokens(File fullFile, Map<String,Integer> tokens) {\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n        int lineNum = 1;\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) {\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \" + tokenDef,\n                                          lineNum);\n                }\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n                              fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              e);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    loadTokens(fullFile, tokens);\n    return tokens;\n}\n\n",
                "\n```"
            ]
        }
    },
    "L8024": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i - 1).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\");\n\t\t\tfor (int j=1; j<=nintervals; j++) {\n\t\t\t\tif ( j>1 ) buf.append(\", \");\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tUUID uuid = ATNSimulator.toUUID(data, p);\n\t\tp += 8;\n\t\tif (!uuid.equals(ATNSimulator.SERIALIZED_UUID)) {\n\t\t\tString reason = String.format(Locale.getDefault(), \"Could not deserialize ATN with UUID %s (expected %s).\", uuid, ATNSimulator.SERIALIZED_UUID);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tif (ruleIndex == Character.MAX_VALUE) {\n\t\t\t\truleIndex = -1;\n\t\t\t}\n\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n\t\t\t\tif (arg2 == Character.MAX_VALUE) {\n\t\t\t\t\targ2 = -1;\n\t\t\t\t}\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\");\n\t\t\tboolean containsEof = data[p++] != 0;\n\t\t\tif (containsEof) {\n\t\t\t\tbuf.append(getTokenName(Token.EOF));\n\t\t\t}\n\n\t\t\tfor (int j=0; j<nintervals; j++) {\n\t\t\t\tif ( containsEof || j>0 ) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t}\n\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    checkVersion(data, p++);\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    decodeStates(data, buf, p, nstates);\n    p += nstates * 2; // Update p based on states\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    p += decodeNonGreedyStates(data, p, numNonGreedyStates);\n    int nrules = ATNSimulator.toInt(data[p++]);\n    p += decodeRules(data, buf, p, nrules, g.isLexer());\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    p += decodeModes(data, buf, p, nmodes);\n    int nsets = ATNSimulator.toInt(data[p++]);\n    p += decodeSets(data, buf, p, nsets);\n    int nedges = ATNSimulator.toInt(data[p++]);\n    p += decodeEdges(data, buf, p, nedges);\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    p += decodeDecisions(data, buf, p, ndecisions);\n    \n    return buf.toString();\n}",
                "private void checkVersion(char[] data, int p) {\n    int version = ATNSimulator.toInt(data[p]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n}",
                "private void decodeStates(char[] data, StringBuilder buf, int p, int nstates) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n}",
                "private int decodeNonGreedyStates(char[] data, int p, int numNonGreedyStates) {\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    return numNonGreedyStates;\n}",
                "private int decodeRules(char[] data, StringBuilder buf, int p, int nrules, boolean isLexer) {\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (isLexer) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    return nrules * (isLexer ? 3 : 1); // Adjust based on whether lexer\n}",
                "private int decodeModes(char[] data, StringBuilder buf, int p, int nmodes) {\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    return nmodes;\n}",
                "private int decodeSets(char[] data, StringBuilder buf, int p, int nsets) {\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    return nsets * 2; // Assumes intervals of 2 tokens each\n}",
                "private int decodeEdges(char[] data, StringBuilder buf, int p, int nedges) {\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n    return nedges * 6; // Adjust based on the number of attributes per edge\n}",
                "private int decodeDecisions(char[] data, StringBuilder buf, int p, int ndecisions) {\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return ndecisions;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n    \n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        ATNSimulator.toInt(data[p++]);\n    }\n    \n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    \n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    \n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    \n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n    \n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    \n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    // don\\'t adjust the first value since that\\'s the version number\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n    \n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    \n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    \n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    \n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    \n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n    \n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    adjustData(data);\n    \n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    validateVersion(data, p++);\n    \n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    \n    appendStatesData(buf, data, p);\n    p += 4 + (3 * ATNSimulator.toInt(data[p++]));\n    \n    appendRulesData(buf, data, p);\n    p += 2 * (ATNSimulator.toInt(data[p++]) + (g.isLexer() ? 2 : 1));\n    \n    appendModesData(buf, data, p);\n    p += 2 * ATNSimulator.toInt(data[p++]);\n    \n    appendSetsData(buf, data, p);\n    p += 2 * (ATNSimulator.toInt(data[p++]) + 1);\n    \n    appendEdgesData(buf, data, p);\n    p += 6 * ATNSimulator.toInt(data[p++]);\n    \n    appendDecisionsData(buf, data, p);\n    \n    return buf.toString();\n}",
                "private void adjustData(char[] data) {\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n}",
                "private void validateVersion(char[] data, int versionPointer) {\n    int version = ATNSimulator.toInt(data[versionPointer]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n}",
                "private void appendStatesData(StringBuilder buf, char[] data, int p) {\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        \n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = getStateArg(data, p, stype);\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n        p += (stype == ATNState.LOOP_END) ? 1 : (stype >= ATNState.PLUS_BLOCK_START ? 1 : 0);\n    }\n}",
                "private String getStateArg(char[] data, int p, int stype) {\n    if (stype == ATNState.LOOP_END) {\n        return \" \" + ATNSimulator.toInt(data[p++]);\n    } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n        return \" \" + ATNSimulator.toInt(data[p++]);\n    }\n    return \"\";\n}",
                "private void appendRulesData(StringBuilder buf, char[] data, int p) {\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n}",
                "private void appendModesData(StringBuilder buf, char[] data, int p) {\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n}",
                "private void appendSetsData(StringBuilder buf, char[] data, int p) {\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p])))\n               .append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n}",
                "private void appendEdgesData(StringBuilder buf, char[] data, int p) {\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n}",
                "private void appendDecisionsData(StringBuilder buf, char[] data, int p) {\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L9806": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.target.getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "AfterRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.getTarget().getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.getTarget().getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.getTarget().getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d = createImplicitLabelDecl(ast);\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}",
                "private Decl createImplicitLabelDecl(GrammarAST ast) {\n    Decl d;\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } else if (ast.getType() == ANTLRParser.RULE_REF) {\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n    setImplicitFlag(d);\n    return d;\n}",
                "private void setImplicitFlag(Decl d) {\n    if (d instanceof TokenDecl) {\n        ((TokenDecl) d).isImplicit = true;\n    } else if (d instanceof RuleContextDecl) {\n        ((RuleContextDecl) d).isImplicit = true;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl) d).isImplicit = true;\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    }\n    // all labels must be in scope struct in case we exec action out of context\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } \n    else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } \n    else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n\n    ((TokenDecl)d).isImplicit = true;\n    op.getLabels().add(d);\n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n\n    switch (ast.getType()) {\n        case ANTLRParser.SET:\n        case ANTLRParser.WILDCARD:\n            implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n            d = getTokenLabelDecl(implLabel);\n            break;\n\n        case ANTLRParser.RULE_REF:\n            Rule r = g.getRule(ast.getText());\n            implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n            String ctxName = gen.target.getRuleFunctionContextStructName(r);\n            d = new RuleContextDecl(this, implLabel, ctxName);\n            break;\n\n        default:\n            implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n            d = getTokenLabelDecl(implLabel);\n            break;\n    }\n\n    ((TokenDecl) d).isImplicit = true;\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } else if (ast.getType() == ANTLRParser.RULE_REF) {\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n    \n    ((TokenDecl)d).isImplicit = true;\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L1506": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void addTransition(Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(e);\n\t}",
        "AfterRefact": "public void addTransition(Transition e) {\n\t\taddTransition(transitions.size(), e);\n\t}\n\n\tpublic void addTransition(int index, Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(Locale.getDefault(), \"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(index, e);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    if (transitions.isEmpty() || epsilonOnlyTransitions != isEpsilon) {\n        if (!transitions.isEmpty() && epsilonOnlyTransitions != isEpsilon) {\n            System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        }\n        epsilonOnlyTransitions = !transitions.isEmpty() ? epsilonOnlyTransitions : isEpsilon;\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n\n    if (transitions.isEmpty() || epsilonOnlyTransitions != isEpsilon) {\n        if (!transitions.isEmpty()) {\n            System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n            epsilonOnlyTransitions = false;\n        } else {\n            epsilonOnlyTransitions = isEpsilon;\n        }\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addTransition(Transition e) {\n\tif (isMixedTransitions(e)) {\n\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n\t\tepsilonOnlyTransitions = false;\n\t} else if (transitions.isEmpty()) {\n\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t}\n\t\n\ttransitions.add(e);\n}",
                "private boolean isMixedTransitions(Transition e) {\n\treturn !transitions.isEmpty() && (epsilonOnlyTransitions != e.isEpsilon());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addTransition(Transition transition) {\n    boolean isEpsilonTransition = transition.isEpsilon();\n\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilonTransition;\n    } else if (epsilonOnlyTransitions != isEpsilonTransition) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(transition);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean currentIsEpsilon = e.isEpsilon();\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = currentIsEpsilon;\n    } else if (epsilonOnlyTransitions != currentIsEpsilon) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L1991": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null) {\n            configs.add(config);\n            return true;\n        }\n\n        if (config.context.hasEmptyPath()) {\n            if (config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    // we have no context info. Don\\'t pursue but\n                    // record a config that indicates how we hit end\n                    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                    if (debug) {\n                        System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                    }\n                    configs.add(c);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions() && \n        (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (!(config.state instanceof RuleStopState)) {\n        // optimization\n        if (!config.state.onlyHasEpsilonTransitions() && \n            (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n            configs.add(config);\n        }\n\n        ATNState p = config.state;\n        for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n            Transition t = p.transition(i);\n            LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n            if (c != null) {\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (debug) {\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\\n\", config);\n        }\n    }\n\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n        }\n    }\n\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    // we have no context info. Don\\'t pursue but\n                    // record a config that indicates how we hit end\n                    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                    if (debug) System.out.println(\"FALLING off token \" +\n                            recog.getRuleNames()[config.state.ruleIndex] +\n                            \" record \" + c);\n                    configs.add(c);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\tif (debug) {\n\t\tSystem.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n\t}\n\n\tif (config.state instanceof RuleStopState) {\n\t\tif (debug) {\n\t\t\tif (recog != null) {\n\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t} else {\n\t\t\t\tSystem.out.format(\"closure at rule stop %s\\\n\", config);\n\t\t\t}\n\t\t}\n\n\t\tif (config.context == null || config.context.hasEmptyPath()) {\n\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t}\n\t\t}\n\n\t\tif (config.context != null && !config.context.isEmpty()) {\n\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\tif (!ctx.isEmpty()) {\n\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\tif (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\tif (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\tif (config.state.onlyHasEpsilonTransitions()) {\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\tconfigs.add(config);\n\t}\n\n\tATNState p = config.state;\n\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\tTransition t = p.transition(i);\n\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\tif (c != null) {\n\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t}\n\t}\n\n\treturn currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                          @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                          boolean speculative) {\n    logDebugInfo(config);\n\n    if (config.state instanceof RuleStopState) {\n        handleRuleStopState(config, configs);\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    return processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n}",
                "private void logDebugInfo(LexerATNConfig config) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\\n\", \n                              recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\\n\", config);\n        }\n    }\n}",
                "private void handleRuleStopState(LexerATNConfig config, ATNConfigSet configs) {\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n        }\n    } else {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                handleNonEmptyContext(config, ctx, configs);\n            }\n        }\n    }\n}",
                "private void handleNonEmptyContext(LexerATNConfig config, SingletonPredictionContext ctx, \n                                     ATNConfigSet configs) {\n    PredictionContext newContext = ctx.parent; // \"pop\" return state\n    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n        configs.add(new LexerATNConfig(config, config.state, ctx));\n    } else {\n        ATNState returnState = atn.states.get(ctx.returnState);\n        LexerATNConfig newConfig = new LexerATNConfig(returnState, config.alt, newContext);\n        closure(input, newConfig, configs, true, speculative);\n    }\n}",
                "private boolean processTransitions(CharStream input, LexerATNConfig config, \n                                    ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                                    boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\tif (debug) {\n\t\tSystem.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n\t}\n\n\tif (!(config.state instanceof RuleStopState)) {\n\t\t// optimization\n\t\tif (!config.state.onlyHasEpsilonTransitions() && (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n\t\t\tconfigs.add(config);\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif (c != null) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\tif (debug) {\n\t\tif (recog != null) {\n\t\t\tSystem.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t} else {\n\t\t\tSystem.out.format(\"closure at rule stop %s\\\n\", config);\n\t\t}\n\t}\n\n\tif (config.context == null || config.context.hasEmptyPath()) {\n\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\tconfigs.add(config);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\tcurrentAltReachedAcceptState = true;\n\t\t}\n\t}\n\n\tif (config.context != null && !config.context.isEmpty()) {\n\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\tif (!ctx.isEmpty()) {\n\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\tif (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\tif (debug) System.out.println(\"FALLING off token \" +\n\t\t\t\t\t\trecog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L19910": {
        "RefactMethod": "INTRODUCE SPECIAL CASE",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        handleRuleStopState(input, config, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}",
                "private boolean handleRuleStopState(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\\n\", config);\n        }\n    }\n\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n        }\n    }\n\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    // we have no context info. Don\\'t pursue but\n                    // record a config that indicates how we hit end\n                    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                    if (debug) System.out.println(\"FALLING off token \" +\n                            recog.getRuleNames()[config.state.ruleIndex] +\n                            \" record \" + c);\n                    configs.add(c);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (isRuleStopState(config.state)) {\n        if (debug) {\n            logRuleStop(config);\n        }\n\n        if (isEmptyContext(config.context)) {\n            configs.add(config);\n            return true;\n        } else {\n            handleNonEmptyContext(config, configs);\n        }\n\n        return processContexts(config, input, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    return processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n}",
                "private boolean isRuleStopState(ATNState state) {\n    return state instanceof RuleStopState;\n}",
                "private void logRuleStop(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\\n\", config);\n    }\n}",
                "private boolean isEmptyContext(PredictionContext context) {\n    return context == null || context.hasEmptyPath() || context.isEmpty();\n}",
                "private void handleNonEmptyContext(LexerATNConfig config, ATNConfigSet configs) {\n    configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n}",
                "private boolean processContexts(LexerATNConfig config, CharStream input, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            PredictionContext newContext = ctx.parent; // \"pop\" return state\n            if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                handleEndOfContext(config, ctx, configs);\n            } else {\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n    return currentAltReachedAcceptState;\n}",
                "private void handleEndOfContext(LexerATNConfig config, SingletonPredictionContext ctx, ATNConfigSet configs) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) System.out.println(\"FALLING off token \" +\n            recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n    configs.add(c);\n}",
                "private boolean processTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Handle as Unknown Context\n                        configs.add(new LexerATNConfig(config, config.state, ctx));\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, \n                          @NotNull LexerATNConfig config, \n                          @NotNull ATNConfigSet configs, \n                          boolean currentAltReachedAcceptState, \n                          boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        handleRuleStopState(config, configs);\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    currentAltReachedAcceptState = processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n    \n    return currentAltReachedAcceptState;\n}",
                "private void handleRuleStopState(LexerATNConfig config, ATNConfigSet configs) {\n    if (debug) {\n        logRuleStopState(config);\n    }\n    \n    if (config.context == null || config.context.hasEmptyPath()) {\n        handleEmptyContext(config, configs);\n    } else {\n        handleNonEmptyContext(config, configs);\n    }\n}",
                "private void logRuleStopState(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\\n\", config);\n    }\n}",
                "private void handleEmptyContext(LexerATNConfig config, ATNConfigSet configs) {\n    if (config.context == null || config.context.isEmpty()) {\n        configs.add(config);\n    } else {\n        configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n    }\n}",
                "private void handleNonEmptyContext(LexerATNConfig config, ATNConfigSet configs) {\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            processSingletonContext(config, ctx, configs);\n        }\n    }\n}",
                "private void processSingletonContext(LexerATNConfig config, \n                                      SingletonPredictionContext ctx, \n                                      ATNConfigSet configs) {\n    PredictionContext newContext = ctx.parent; // \"pop\" return state\n    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n        logFallingOffToken(config);\n        configs.add(new LexerATNConfig(config, config.state, ctx));\n    } else {\n        ATNState returnState = atn.states.get(ctx.returnState);\n        LexerATNConfig newConfig = new LexerATNConfig(returnState, config.alt, newContext);\n        closure(input, newConfig, configs, currentAltReachedAcceptState, speculative);\n    }\n}",
                "private void logFallingOffToken(LexerATNConfig config) {\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex]);\n    }\n}",
                "private boolean processTransitions(@NotNull CharStream input, \n                                   LexerATNConfig config, \n                                   ATNConfigSet configs, \n                                   boolean currentAltReachedAcceptState, \n                                   boolean speculative) {\n    ATNState state = config.state;\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition t = state.transition(i);\n        LexerATNConfig newConfig = getEpsilonTarget(input, config, t, configs, speculative);\n        if (newConfig != null) {\n            currentAltReachedAcceptState = closure(input, newConfig, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; \n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2113": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (SingletonPredictionContext p : ctx) {\n\t\t\t\t\tATNState returnState = atn.states.get(p.returnState);\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\t\t\t\t\t_LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\t\t\t\t_LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, \n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, \n                     boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look, @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    processTransitions(s, ctx, look, lookBusy, seeThruPreds, addEOF);\n}",
                "private void handleRuleStopState(@Nullable PredictionContext ctx, @NotNull IntervalSet look, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    } else if (ctx != PredictionContext.EMPTY) {\n        for (SingletonPredictionContext p : ctx) {\n            ATNState returnState = atn.states.get(p.returnState);\n            _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n        }\n    }\n}",
                "private void processTransitions(ATNState s, PredictionContext ctx, IntervalSet look, \n                                Set<ATNConfig> lookBusy, boolean seeThruPreds, boolean addEOF) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            PredictionContext newContext = \n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            handlePredicateTransition(seeThruPreds, ctx, look, t);\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            addTransitionLabelToLook(look, t);\n        }\n    }\n}",
                "private void handlePredicateTransition(boolean seeThruPreds, PredictionContext ctx, \n                                        IntervalSet look, Transition t) {\n    if (seeThruPreds) {\n        _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n    } else {\n        look.add(HIT_PRED);\n    }\n}",
                "private void addTransitionLabelToLook(IntervalSet look, Transition t) {\n    IntervalSet set = t.label();\n    if (set != null) {\n        if (t instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        look.addAll(set);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2427": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    if (p.onlyHasEpsilonTransitions()) {\n        return;\n    }\n    \n    configs.add(config, mergeCache);\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n        \n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c == null) continue;\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n            continue;\n        }\n        \n        if (t instanceof RuleTransition && newDepth >= 0) {\n            newDepth++;\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c != null) {\n            int newDepth = depth;\n\n            if (config.state instanceof RuleStopState) {\n                handleRuleStopState(c, configs);\n                newDepth--;\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n        }\n    }\n}",
                "private void handleRuleStopState(ATNConfig c, ATNConfigSet configs) {\n    assert !fullCtx;\n    c.reachesIntoOuterContext++;\n    configs.dipsIntoOuterContext = true;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    \n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c == null) {\n            continue;\n        }\n        \n        int newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n            continue;\n        }\n        \n        if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L9795": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.target.getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.target.getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "AfterRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.getTarget().getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.getTarget().getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private void initializeStateAndName(ParserFactory factory, GrammarAST ast) {\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n    this.name = ast.getText();\n}",
                "private void createContextDeclarations(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n}",
                "private void translateActionIfPresent(ParserFactory factory, GrammarAST ast) {\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, factory.getCurrentRuleFunction(), arg.token, arg);\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = factory.getGenerator().target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        factory.getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    initializeStateAndName(factory, ast);\n    createContextDeclarations(factory, ast, labelAST);\n    translateActionIfPresent(factory, ast);\n    defineImplicitLabelIfNeeded(factory, ast);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    \n    if (labelAST != null) {\n        // for x=r, define <rule-context-type> x and list_x\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n    \n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "private void defineContext(GrammarAST labelAST, ParserFactory factory, RuleFunction rf, CodeGenerator gen, GrammarAST ast) {\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast, CodeGenerator gen, RuleFunction rf) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    \n    defineContext(labelAST, factory, rf, gen, ast);\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    defineImplicitLabelIfNeeded(factory, ast, gen, rf);\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void initializeStateNumber(GrammarAST ast) {\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n}",
                "private void processLabelAST(ParserFactory factory, GrammarAST labelAST, GrammarAST ast, CodeGenerator gen) {\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        RuleFunction rf = factory.getCurrentRuleFunction();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl listDecl = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), listDecl);\n        } else {\n            RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n            labels.add(contextDecl);\n            rf.addContextDecl(ast.getAltLabel(), contextDecl);\n        }\n    }\n}",
                "private void processActionAST(ParserFactory factory, GrammarAST ast) {\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, factory.getCurrentRuleFunction(), arg.token, arg);\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast, CodeGenerator gen) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n        labels.add(contextDecl);\n        factory.getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), contextDecl);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    initializeStateNumber(ast);\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n    processLabelAST(factory, labelAST, ast, gen);\n    processActionAST(factory, ast);\n    defineImplicitLabelIfNeeded(factory, ast, gen);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private void handleLabelAST(ParserFactory factory, CodeGenerator gen, GrammarAST ast, GrammarAST labelAST, RuleFunction rf) {\n    String label = labelAST.getText();\n    if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n        factory.defineImplicitLabel(ast, this);\n        String listLabel = gen.target.getListLabel(label);\n        RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n        rf.addContextDecl(ast.getAltLabel(), l);\n    } else {\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    if (labelAST != null) {\n        handleLabelAST(factory, gen, ast, labelAST, rf);\n    }\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n\n",
                "\n```"
            ]
        }
    },
    "L9861": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.target.getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "AfterRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.getTarget().getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "ZeroShotCode": {
            "methods": [
                "private String getGrammarFileName(Grammar g) {\n    return new File(g.fileName).getName();\n}",
                "private String[] initializeTokenNames(Grammar g) {\n    String[] tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        tokenNames[i] = formatTokenName(gen, tokenNames[i]);\n    }\n    return tokenNames;\n}",
                "private String formatTokenName(CodeGenerator gen, String tokenName) {\n    if (tokenName.charAt(0) == \\'\\\\\\'\\') {\n        boolean addQuotes = false;\n        tokenName = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, addQuotes);\n        return \"\\\\\"\\'\"+tokenName+\"\\'\\\\\"\";\n    } else {\n        return gen.target.getTargetStringLiteralFromString(tokenName, true);\n    }\n}",
                "private ActionText initializeSuperClass(Grammar g) {\n    if (g.getOptionString(\"superClass\") != null) {\n        return new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        return new DefaultLexerSuperClass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = getGrammarFileName(g);\n    name = g.getRecognizerName();\n    tokens = initializeTokens(g);\n    tokenNames = initializeTokenNames(g);\n    ruleNames = g.rules.keySet();\n    superClass = initializeSuperClass(g);\n}\n\n",
                "\n\nprivate Map<String, Integer> initializeTokens(Grammar g) {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n    return tokens;\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    \n    // Moved initialization of modes to before the loop\n    LexerGrammar lg = (LexerGrammar) g;\n    modes = lg.modes.keySet();\n    atn = new SerializedATN(factory, lg.atn);\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator(); // Moved outside loop for efficiency\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] =\n                gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen,\n                                                                        tokenNames[i],\n                                                                        addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n\n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "private void initializeTokens(Grammar g) {\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n}",
                "private void initializeTokenNames(Grammar g) {\n    tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n}",
                "private void initializeSuperClass(Grammar g) {\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    initializeTokens(g);\n    initializeTokenNames(g);\n    ruleNames = g.rules.keySet();\n    initializeSuperClass(g);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private String[] initializeTokenNames(Grammar grammar) {\n    String[] names = grammar.getTokenDisplayNames();\n    CodeGenerator generator = factory.getGenerator();\n    for (int i = 0; i < names.length; i++) {\n        if (names[i] == null) continue;\n        names[i] = formatTokenName(generator, names[i]);\n    }\n    return names;\n}",
                "private String formatTokenName(CodeGenerator generator, String tokenName) {\n    if (tokenName.charAt(0) == \\'\\\\\\'\\') {\n        boolean addQuotes = false;\n        tokenName = generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator, tokenName, addQuotes);\n        return \"\\\\\"\\'\" + tokenName + \"\\'\\\\\"\";\n    } else {\n        return generator.target.getTargetStringLiteralFromString(tokenName, true);\n    }\n}",
                "private ActionText getSuperClass(Grammar grammar) {\n    String superClassName = grammar.getOptionString(\"superClass\");\n    return superClassName != null ? new ActionText(null, superClassName) : new DefaultLexerSuperClass();\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file;\n\n    Grammar grammar = factory.getGrammar();\n    grammarFileName = new File(grammar.fileName).getName();\n    name = grammar.getRecognizerName();\n    tokens = initializeTokens(grammar);\n    tokenNames = initializeTokenNames(grammar);\n    ruleNames = grammar.rules.keySet();\n    superClass = getSuperClass(grammar);\n}\n\nprivate Map<String, Integer> initializeTokens(Grammar grammar) {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    for (String token : grammar.tokenNameToTypeMap.keySet()) {\n        Integer tokenType = grammar.tokenNameToTypeMap.get(token);\n        if (tokenType > 0) {\n            tokens.put(token, tokenType);\n        }\n    }\n    return tokens;\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private void initializeTokens(Grammar g) {\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n}",
                "private void initializeTokenNames(Grammar g) {\n    tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String,Integer>();\n    LexerGrammar lg = (LexerGrammar)g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    initializeTokens(g);\n    initializeTokenNames(g);\n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L2093": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\tATNState s;\n\t\tswitch (type) {\n\t\t\tcase ATNState.INVALID_TYPE: return null;\n\t\t\tcase ATNState.BASIC : s = new BasicState(); break;\n\t\t\tcase ATNState.RULE_START : s = new RuleStartState(); break;\n\t\t\tcase ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n\t\t\tcase ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n\t\t\tcase ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n\t\t\tcase ATNState.TOKEN_START : s = new TokensStartState(); break;\n\t\t\tcase ATNState.RULE_STOP : s = new RuleStopState(); break;\n\t\t\tcase ATNState.BLOCK_END : s = new BlockEndState(); break;\n\t\t\tcase ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n\t\t\tcase ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n\t\t\tcase ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n\t\t\tcase ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n\t\t\t\tString message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\n\t\ts.ruleIndex = ruleIndex;\n\t\treturn s;\n\t}",
        "AfterRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\treturn new ATNDeserializer().stateFactory(type, ruleIndex);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState s = createState(type);\n    if (s == null) {\n        String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n        throw new IllegalArgumentException(message);\n    }\n    s.ruleIndex = ruleIndex;\n    return s;\n}",
                "static ATNState createState(int type) {\n    switch (type) {\n        case ATNState.INVALID_TYPE: return null;\n        case ATNState.BASIC: return new BasicState();\n        case ATNState.RULE_START: return new RuleStartState();\n        case ATNState.BLOCK_START: return new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n        case ATNState.TOKEN_START: return new TokensStartState();\n        case ATNState.RULE_STOP: return new RuleStopState();\n        case ATNState.BLOCK_END: return new BlockEndState();\n        case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n        case ATNState.LOOP_END: return new LoopEndState();\n        default: return null;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }",
                "static ATNState stateFactory(int type, int ruleIndex) {\n    return new StateFactoryCommand(type, ruleIndex).execute();\n}"
            ],
            "classes": [
                "class StateFactoryCommand {\n    private final int type;\n    private final int ruleIndex;\n\n    public StateFactoryCommand(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Forwarding method in the original class\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    return new StateFactory(type, ruleIndex).create();\n}"
            ],
            "classes": [
                "class StateFactory {\n    private final int type;\n    private final int ruleIndex;\n\n    StateFactory(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    ATNState create() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState state;\n\n    switch (type) {\n        case ATNState.INVALID_TYPE:\n            return null;\n        case ATNState.BASIC:\n            state = new BasicState();\n            break;\n        case ATNState.RULE_START:\n            state = new RuleStartState();\n            break;\n        case ATNState.BLOCK_START:\n            state = new BasicBlockStartState();\n            break;\n        case ATNState.PLUS_BLOCK_START:\n            state = new PlusBlockStartState();\n            break;\n        case ATNState.STAR_BLOCK_START:\n            state = new StarBlockStartState();\n            break;\n        case ATNState.TOKEN_START:\n            state = new TokensStartState();\n            break;\n        case ATNState.RULE_STOP:\n            state = new RuleStopState();\n            break;\n        case ATNState.BLOCK_END:\n            state = new BlockEndState();\n            break;\n        case ATNState.STAR_LOOP_BACK:\n            state = new StarLoopbackState();\n            break;\n        case ATNState.STAR_LOOP_ENTRY:\n            state = new StarLoopEntryState();\n            break;\n        case ATNState.PLUS_LOOP_BACK:\n            state = new PlusLoopbackState();\n            break;\n        case ATNState.LOOP_END:\n            state = new LoopEndState();\n            break;\n        default:\n            throw new IllegalArgumentException(\n                String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type)\n            );\n    }\n\n    state.ruleIndex = ruleIndex;\n    return state;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    return StateFactory.createState(type, ruleIndex);\n}",
                "static ATNState createState(int type, int ruleIndex) {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC : s = new BasicState(); break;\n            case ATNState.RULE_START : s = new RuleStartState(); break;\n            case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START : s = new TokensStartState(); break;\n            case ATNState.RULE_STOP : s = new RuleStopState(); break;\n            case ATNState.BLOCK_END : s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }"
            ],
            "classes": [
                "class StateFactory {\n    public static ATNState createState(int type, int ruleIndex) {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC : s = new BasicState(); break;\n            case ATNState.RULE_START : s = new RuleStartState(); break;\n            case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START : s = new TokensStartState(); break;\n            case ATNState.RULE_STOP : s = new RuleStopState(); break;\n            case ATNState.BLOCK_END : s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L2083": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\tATNState target = atn.states.get(trg);\n\t\tswitch (type) {\n\t\t\tcase Transition.EPSILON : return new EpsilonTransition(target);\n\t\t\tcase Transition.RANGE :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase Transition.RULE :\n\t\t\t\tRuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n\t\t\t\treturn rt;\n\t\t\tcase Transition.PREDICATE :\n\t\t\t\tPredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn pt;\n\t\t\tcase Transition.ATOM :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase Transition.ACTION :\n\t\t\t\tActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn a;\n\t\t\tcase Transition.SET : return new SetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.WILDCARD : return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"The specified transition type is not valid.\");\n\t}",
        "AfterRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\treturn new ATNDeserializer().edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n                                     int type, int src, int trg,\n                                     int arg1, int arg2, int arg3,\n                                     List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    Transition transition;\n\n    switch (type) {\n        case Transition.EPSILON:\n            transition = new EpsilonTransition(target);\n            break;\n        case Transition.RANGE:\n            transition = (arg3 != 0) ? new RangeTransition(target, Token.EOF, arg2)\n                                       : new RangeTransition(target, arg1, arg2);\n            break;\n        case Transition.RULE:\n            transition = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n            break;\n        case Transition.PREDICATE:\n            transition = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.ATOM:\n            transition = (arg3 != 0) ? new AtomTransition(target, Token.EOF)\n                                      : new AtomTransition(target, arg1);\n            break;\n        case Transition.ACTION:\n            transition = new ActionTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.SET:\n            transition = new SetTransition(target, sets.get(arg1));\n            break;\n        case Transition.NOT_SET:\n            transition = new NotSetTransition(target, sets.get(arg1));\n            break;\n        case Transition.WILDCARD:\n            transition = new WildcardTransition(target);\n            break;\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n\n    return transition;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }",
                "static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    EdgeFactoryCommand command = new EdgeFactoryCommand(atn, type, src, trg, arg1, arg2, arg3, sets);\n    return command.execute();\n}"
            ],
            "classes": [
                "class EdgeFactoryCommand {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public EdgeFactoryCommand(ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Original forwarding function\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    return new EdgeCreator(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n}",
                "public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE: return createRangeTransition(target);\n            case Transition.RULE: return createRuleTransition(target);\n            case Transition.PREDICATE: return createPredicateTransition(target);\n            case Transition.ATOM: return createAtomTransition(target);\n            case Transition.ACTION: return createActionTransition(target);\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }",
                "private Transition createRangeTransition(ATNState target) {\n        if (arg3 != 0) {\n            return new RangeTransition(target, Token.EOF, arg2);\n        } else {\n            return new RangeTransition(target, arg1, arg2);\n        }\n    }",
                "private Transition createRuleTransition(ATNState target) {\n        return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n    }",
                "private Transition createPredicateTransition(ATNState target) {\n        return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n    }",
                "private Transition createAtomTransition(ATNState target) {\n        if (arg3 != 0) {\n            return new AtomTransition(target, Token.EOF);\n        } else {\n            return new AtomTransition(target, arg1);\n        }\n    }",
                "private Transition createActionTransition(ATNState target) {\n        return new ActionTransition(target, arg1, arg2, arg3 != 0);\n    }"
            ],
            "classes": [
                "class EdgeCreator {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public EdgeCreator(@NotNull ATN atn,\n                       int type, int src, int trg,\n                       int arg1, int arg2, int arg3,\n                       List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE: return createRangeTransition(target);\n            case Transition.RULE: return createRuleTransition(target);\n            case Transition.PREDICATE: return createPredicateTransition(target);\n            case Transition.ATOM: return createAtomTransition(target);\n            case Transition.ACTION: return createActionTransition(target);\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n\n    private Transition createRangeTransition(ATNState target) {\n        if (arg3 != 0) {\n            return new RangeTransition(target, Token.EOF, arg2);\n        } else {\n            return new RangeTransition(target, arg1, arg2);\n        }\n    }\n\n    private Transition createRuleTransition(ATNState target) {\n        return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n    }\n\n    private Transition createPredicateTransition(ATNState target) {\n        return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n    }\n\n    private Transition createAtomTransition(ATNState target) {\n        if (arg3 != 0) {\n            return new AtomTransition(target, Token.EOF);\n        } else {\n            return new AtomTransition(target, arg1);\n        }\n    }\n\n    private Transition createActionTransition(ATNState target) {\n        return new ActionTransition(target, arg1, arg2, arg3 != 0);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n\n    switch (type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return (arg3 != 0) ? new RangeTransition(target, Token.EOF, arg2) \n                               : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.ATOM:\n            return (arg3 != 0) ? new AtomTransition(target, Token.EOF) \n                               : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.SET:\n            return new SetTransition(target, sets.get(arg1));\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets.get(arg1));\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t  int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t  int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t  List<IntervalSet> sets)\n{\n\tATNState target = atn.states.get(trg);\n\tTransitionFactory transitionFactory = new TransitionFactory(target, sets, arg1, arg2, arg3);\n\treturn transitionFactory.createTransition(type);\n}",
                "public Transition createTransition(int type) {\n\t\tswitch (type) {\n\t\t\tcase Transition.EPSILON : return new EpsilonTransition(target);\n\t\t\tcase Transition.RANGE :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase Transition.RULE :\n\t\t\t\tRuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n\t\t\t\treturn rt;\n\t\t\tcase Transition.PREDICATE :\n\t\t\t\tPredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn pt;\n\t\t\tcase Transition.ATOM :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase Transition.ACTION :\n\t\t\t\tActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn a;\n\t\t\tcase Transition.SET : return new SetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.WILDCARD : return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"The specified transition type is not valid.\");\n\t}"
            ],
            "classes": [
                "class TransitionFactory {\n\tprivate ATNState target;\n\tprivate List<IntervalSet> sets;\n\tprivate int arg1;\n\tprivate int arg2;\n\tprivate int arg3;\n\n\tpublic TransitionFactory(ATNState target, List<IntervalSet> sets, int arg1, int arg2, int arg3) {\n\t\tthis.target = target;\n\t\tthis.sets = sets;\n\t\tthis.arg1 = arg1;\n\t\tthis.arg2 = arg2;\n\t\tthis.arg3 = arg3;\n\t}\n\n\tpublic Transition createTransition(int type) {\n\t\tswitch (type) {\n\t\t\tcase Transition.EPSILON : return new EpsilonTransition(target);\n\t\t\tcase Transition.RANGE :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase Transition.RULE :\n\t\t\t\tRuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n\t\t\t\treturn rt;\n\t\t\tcase Transition.PREDICATE :\n\t\t\t\tPredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn pt;\n\t\t\tcase Transition.ATOM :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase Transition.ACTION :\n\t\t\t\tActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn a;\n\t\t\tcase Transition.SET : return new SetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.WILDCARD : return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"The specified transition type is not valid.\");\n\t}\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L2079": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\tlong leastSigBits = toLong(data, offset);\n\t\tlong mostSigBits = toLong(data, offset + 4);\n\t\treturn new UUID(mostSigBits, leastSigBits);\n\t}",
        "AfterRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\treturn ATNDeserializer.toUUID(data, offset);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    return new UUID(toLong(data, offset + 4), toLong(data, offset));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }",
                "private long toLong(char[] data, int offset) {\n        // Implementation of toLong method here\n    }",
                "static UUID toUUID(char[] data, int offset) {\n    ToUUIDCommand command = new ToUUIDCommand(data, offset);\n    return command.execute();\n}"
            ],
            "classes": [
                "class ToUUIDCommand {\n    private char[] data;\n    private int offset;\n\n    public ToUUIDCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implementation of toLong method here\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    return new UUIDConverter(data, offset).execute();\n}",
                "private long toLong(char[] data, int offset) {\n        // Implementation of toLong method\n    }"
            ],
            "classes": [
                "class UUIDConverter {\n    private char[] data;\n    private int offset;\n    private long leastSigBits;\n    private long mostSigBits;\n\n    UUIDConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    UUID execute() {\n        leastSigBits = toLong(data, offset);\n        mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implementation of toLong method\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    long mostSigBits = toLong(data, offset + 4);\n    long leastSigBits = toLong(data, offset);\n    return new UUID(mostSigBits, leastSigBits);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    return UUID.fromString(new String(data, offset, data.length - offset));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        }
    },
    "L2075": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static long toLong(char[] data, int offset) {\n\t\tlong lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n\t\treturn lowOrder | ((long)toInt32(data, offset + 2) << 32);\n\t}",
        "AfterRefact": "public static long toLong(char[] data, int offset) {\n\t\treturn ATNDeserializer.toLong(data, offset);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    return ((long)toInt32(data, offset + 2) << 32) | (toInt32(data, offset) & 0x00000000FFFFFFFFL);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }",
                "private int toInt32(char[] data, int offset) {\n        // Implementation of toInt32 goes here\n    }",
                "static long toLong(char[] data, int offset) {\n    return new ToLongCommand(data, offset).execute();\n}"
            ],
            "classes": [
                "class ToLongCommand {\n    private char[] data;\n    private int offset;\n\n    public ToLongCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Implementation of toInt32 goes here\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    return new LongConverter(data, offset).execute();\n}",
                "public long execute() {\n        long lowOrder = toInt32(_data, _offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(_data, _offset + 2) << 32);\n    }"
            ],
            "classes": [
                "class LongConverter {\n    private char[] _data;\n    private int _offset;\n\n    public LongConverter(char[] data, int offset) {\n        this._data = data;\n        this._offset = offset;\n    }\n\n    public long execute() {\n        long lowOrder = toInt32(_data, _offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(_data, _offset + 2) << 32);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    int lowerInt = toInt32(data, offset) & 0xFFFFFFFF;\n    int upperInt = toInt32(data, offset + 2);\n    return ((long) upperInt << 32) | lowerInt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    long lowOrder = newToInt32(data, offset) & 0x00000000FFFFFFFFL;\n    return lowOrder | ((long)newToInt32(data, offset + 2) << 32);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        }
    },
    "L1276": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\t// share same graph if both same\n\t\tif ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "AfterRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\tassert a!=null && b!=null; // must be empty context, never null\n\n\t\t// share same graph if both same\n\t\tif ( a==b || a.equals(b) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static PredictionContext merge(\n    PredictionContext a, PredictionContext b,\n    boolean rootIsWildcard,\n    DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\n    if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons((SingletonPredictionContext) a,\n                               (SingletonPredictionContext) b,\n                               rootIsWildcard, mergeCache);\n    }\n\n    if (rootIsWildcard) {\n        if (a instanceof EmptyPredictionContext) return a;\n        if (b instanceof EmptyPredictionContext) return b;\n    }\n\n    a = normalizeToArray(a);\n    b = normalizeToArray(b);\n    \n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                       rootIsWildcard, mergeCache);\n}",
                "static PredictionContext normalizeToArray(PredictionContext context) {\n    if (context instanceof SingletonPredictionContext) {\n        return new ArrayPredictionContext((SingletonPredictionContext) context);\n    }\n    return context;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }",
                "static PredictionContext merge(\n        PredictionContext a, PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache)\n    {\n        return new MergePredictionContextCommand(a, b, rootIsWildcard, mergeCache).execute();\n    }"
            ],
            "classes": [
                "class MergePredictionContextCommand {\n    private final PredictionContext a;\n    private final PredictionContext b;\n    private final boolean rootIsWildcard;\n    private final DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n\n    public MergePredictionContextCommand(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }\n\n    public static PredictionContext merge(\n        PredictionContext a, PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache)\n    {\n        return new MergePredictionContextCommand(a, b, rootIsWildcard, mergeCache).execute();\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    return new Merger(a, b, rootIsWildcard, mergeCache).execute();\n}",
                "public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }"
            ],
            "classes": [
                "class Merger {\n    private PredictionContext a;\n    private PredictionContext b;\n    private boolean rootIsWildcard;\n    private DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n\n    public Merger(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static PredictionContext merge(\n        PredictionContext a, PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    \n    if (areContextsEqual(a, b)) {\n        return a;\n    }\n\n    if (areBothSingletons(a, b)) {\n        return mergeSingletons((SingletonPredictionContext) a,\n                               (SingletonPredictionContext) b,\n                               rootIsWildcard, mergeCache);\n    }\n\n    if (rootIsWildcard && (isEmptyContext(a) || isEmptyContext(b))) {\n        return a instanceof EmptyPredictionContext ? a : b;\n    }\n\n    a = convertToArrayIfSingleton(a);\n    b = convertToArrayIfSingleton(b);\n\n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                       rootIsWildcard, mergeCache);\n}",
                "static boolean areContextsEqual(PredictionContext a, PredictionContext b) {\n    return (a == null && b == null) || a == b || (a != null && a.equals(b));\n}",
                "static boolean areBothSingletons(PredictionContext a, PredictionContext b) {\n    return a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext;\n}",
                "static boolean isEmptyContext(PredictionContext context) {\n    return context instanceof EmptyPredictionContext;\n}",
                "static PredictionContext convertToArrayIfSingleton(PredictionContext context) {\n    if (context instanceof SingletonPredictionContext) {\n        return new ArrayPredictionContext((SingletonPredictionContext) context);\n    }\n    return context;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static PredictionContext merge(\n        PredictionContext a, PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    \n    // share same graph if both same\n    if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n    \n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons((SingletonPredictionContext) a,\n                               (SingletonPredictionContext) b,\n                               rootIsWildcard, mergeCache);\n    }\n\n    // At least one of a or b is array\n    // If one is $ and rootIsWildcard, return $ as * wildcard\n    if (rootIsWildcard) {\n        if (a instanceof EmptyPredictionContext) return a;\n        if (b instanceof EmptyPredictionContext) return b;\n    }\n\n    // convert singleton so both are arrays to normalize\n    if (a instanceof SingletonPredictionContext) {\n        a = new ArrayPredictionContext((SingletonPredictionContext) a);\n    }\n    if (b instanceof SingletonPredictionContext) {\n        b = new ArrayPredictionContext((SingletonPredictionContext) b);\n    }\n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                       rootIsWildcard, mergeCache);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        }
    },
    "L7856": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n        boolean useIdentity = true; // compare node identity\n\t\tthis.treeLayout =\n\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(tree),\n\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n                                 useIdentity);\n\t\tupdatePreferredSize();\n\t\tsetFont(font);\n\t}",
        "AfterRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetRuleNames(ruleNames);\n\t\tif ( tree!=null ) {\n\t\t\tsetTree(tree);\n\t\t}\n\t\tsetFont(font);\n\t}\n\npublic void setTree(Tree root) {\n\t\tif ( root!=null ) {\n\t\t\tboolean useIdentity = true; // compare node identity\n\t\t\tthis.treeLayout =\n\t\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(root),\n\t\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n\t\t\t\t\t\t\t\t\t useIdentity);\n\t\t\t// Let the UI display this new AST.\n\t\t\tupdatePreferredSize();\n\t\t}\n\t\telse {\n\t\t\tthis.treeLayout = null;\n\t\t\trepaint();\n\t\t}\n\t}\npublic void setRuleNames(List<String> ruleNames) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private DefaultTreeTextProvider createTreeTextProvider(@Nullable List<String> ruleNames) {\n    return new DefaultTreeTextProvider(ruleNames);\n}",
                "private TreeLayout<Tree> createTreeLayout(Tree tree, boolean useIdentity) {\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(createTreeTextProvider(ruleNames));\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = createTreeLayout(tree, useIdentity);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree, boolean useIdentity) {\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = createTreeLayout(tree, useIdentity);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree, boolean useIdentity) {\n    return new TreeLayout<>(\n        new TreeLayoutAdaptor(tree),\n        new VariableExtentProvider(this),\n        new DefaultConfiguration<>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    \n    boolean useIdentity = true; // Compare node identity\n    this.treeLayout = createTreeLayout(tree, useIdentity);\n    \n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private void initializeTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout =\n        new TreeLayout<Tree>(new TreeLayoutAdaptor(tree),\n                             new TreeViewer.VariableExtentProvide(this),\n                             new DefaultConfiguration<Tree>(gapBetweenLevels,\n                                                             gapBetweenNodes),\n                             useIdentity);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    initializeTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        }
    },
    "L3524": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tsuper(ruleStart);\n\n\t\tthis.ruleIndex = ruleIndex;\n\n\t\tthis.followState = followState;\n\n\t}",
        "AfterRefact": "public RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tthis(ruleStart, ruleIndex, 0, followState);\n\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n                      int initialRuleIndex,\n\n                      @NotNull ATNState followState)\n\n{\n\n    super(ruleStart);\n\n    this.ruleIndex = initialRuleIndex;\n\n    this.followState = followState;\n\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [
                "class RuleTransition {\n\n    private final RuleStartState ruleStart;\n    private final int ruleIndex;\n    private final ATNState followState;\n\n    public RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n        this.ruleStart = ruleStart;\n        this.ruleIndex = ruleIndex;\n        this.followState = followState;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        }
    },
    "L2447": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = input.getLine(); // updated position tracking\n    this.charPositionInLine = input.getCharPositionInLine(); // updated position tracking\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n                      int index, int line, int charPos, boolean debug)\n{\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n\n    if (isValidAction(actionIndex)) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    updatePosition(input, index, line, charPos);\n}",
                "private void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        String ruleName = (recog != null) ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", ruleName, actionIndex);\n    }\n}",
                "private boolean isValidAction(int actionIndex) {\n    return actionIndex >= 0 && recog != null;\n}",
                "private void updatePosition(@NotNull CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L24470": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index,\n                      int line, int charPos) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", \n                          recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // Reset seek parameters\n    int index = input.index();\n    int line = this.line;\n    int charPos = this.charPositionInLine;\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    \n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logDebugInfo(ruleIndex, actionIndex);\n\n    if (isActionIndexValid(actionIndex)) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    processInput(input, index, line, charPos);\n}",
                "private void logDebugInfo(int ruleIndex, int actionIndex) {\n    if (debug) {\n        String ruleName = (recog != null) ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", ruleName, actionIndex);\n    }\n}",
                "private boolean isActionIndexValid(int actionIndex) {\n    return actionIndex >= 0 && recog != null;\n}",
                "private void processInput(@NotNull CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2288": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t  DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t  @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t  @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t  ParserRuleContext outerContext,\n\t\t\t\t\t\t\t\t\t  int SLL_min_alt) // todo: is this in D as min ambig alts?\n\t{\n\t\t// caller must have write lock on dfa\n\t\tretry_with_context++;\n\t\treportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\tretry_with_context_indicates_no_conflict++;\n\t\t\treportContextSensitivity(dfa, reach, startIndex, input.index());\n\t\t\tif ( predictedAlt == SLL_min_alt ) {\n\t\t\t\tretry_with_context_predicts_same_alt++;\n\t\t\t}\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\tif ( foundExactAmbig ) {\n\t\t\treportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n\t\t}\n\n\t\treturn predictedAlt;\n\t}",
        "AfterRefact": "protected int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t\t DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t\t @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t\t ParserRuleContext outerContext)\n\t{\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\treportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index());\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\treportAmbiguity(dfa, D, startIndex, input.index(), foundExactAmbig, null, reach);\n\n\t\treturn predictedAlt;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input,\n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    \n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n        \n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    \n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    \n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets + \n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" + \n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        \n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        \n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) && \n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D, \n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) \n{\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    \n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets + \n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) + \n                               \", resolvesToJustOneViableAlt=\" + \n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    \n    int t = input.LA(1);\n    int predictedAlt;\n\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) \n{\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) \n            {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2588": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "protected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n\t\treturn 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n\t}",
        "AfterRefact": "protected static int calculateHashCode(PredictionContext parent, int returnState) {\n\t\tint hash = MurmurHash.initialize(INITIAL_HASH);\n\t\thash = MurmurHash.update(hash, parent);\n\t\thash = MurmurHash.update(hash, returnState);\n\t\thash = MurmurHash.finish(hash, 2);\n\t\treturn hash;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return 175 + 5 * parentHashCode + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }",
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    CalculateHashCodeCommand command = new CalculateHashCodeCommand(parentHashCode, returnStateHashCode);\n    return command.execute();\n}"
            ],
            "classes": [
                "class CalculateHashCodeCommand {\n    private int parentHashCode;\n    private int returnStateHashCode;\n\n    public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\nprotected ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return new HashCodeCalculator(parentHashCode, returnStateHashCode).execute();\n}",
                "public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }"
            ],
            "classes": [
                "class HashCodeCalculator {\n    private int parentHashCode;\n    private int returnStateHashCode;\n\n    public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}"
            ],
            "others": [
                "```java\nprotected ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    final int prime1 = 25; // 5 * 5\n    final int prime2 = 7;\n    return prime1 + (5 * parentHashCode) + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return calculateHashCodeImpl(parentHashCode, returnStateHashCode);\n}",
                "static int calculateHashCodeImpl(int parentHashCode, int returnStateHashCode) {\n    return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n\nprivate ",
                "\n```"
            ]
        }
    },
    "L3072": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "AfterRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex)\n{\n}"
            ],
            "classes": [],
            "others": [
                "```csharp\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer,\n                                       DFA dfa,\n                                       int startIndex,\n                                       int stopIndex,\n                                       ATNConfigSet configs) {\n    // Implementation here\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer,\n                                      DFA dfa,\n                                      int startIndex,\n                                      int stopIndex,\n                                      ATNConfigSet configs) {\n    // Method body has been changed to a method object\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5418": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t\t_ctx.altNum = altNum;\n\t}",
        "AfterRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    updateParseTree(localctx);\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}",
                "private void updateParseTree(ParserRuleContext localctx) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext newContext, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != newContext) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(newContext);\n        }\n    }\n    _ctx = newContext;\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    localctx.altNum = altNum; // Changed _ctx to localctx for clarity\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    updateContext(localctx, altNum);\n}",
                "private void updateContext(ParserRuleContext localctx, int altNum) {\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L3446": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "AfterRefact": "protected Token singleTokenDeletion(@NotNull Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\treportMatch(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}\npublic void reportMatch(Parser recognizer) {\n\t\tendErrorCondition(recognizer);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleUnwantedToken(recognizer);\n        return getMatchedSymbol(recognizer);\n    }\n    return null;\n}",
                "private void handleUnwantedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    recognizer.consume(); // simply delete extra token\n    endErrorCondition(recognizer); // we know current token is correct\n}",
                "private Token getMatchedSymbol(Parser recognizer) {\n    return recognizer.getCurrentToken();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleUnwantedToken(recognizer);\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private void handleUnwantedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    recognizer.consume(); // simply delete extra token\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleUnwantedToken(recognizer);\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private void handleUnwantedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    recognizer.consume(); // simply delete extra token\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expectedTokens = getExpectedTokens(recognizer);\n    \n    if (expectedTokens.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); // current token is correct\n        return matchedSymbol;\n    }\n    \n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleMismatchedToken(recognizer);\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private void handleMismatchedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    recognizer.consume(); // simply delete extra token\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L3949": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public TheoryAnchor(FrameworkMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}",
        "AfterRefact": "public TheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tfTestMethod= method;\n            fTestClass= testClass;\n\t\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod fTestMethod) {\n\tthis.fTestMethod = fTestMethod;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method, AnotherParameterType anotherParameter) {\n    fTestMethod = method;\n    this.anotherField = anotherParameter;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    fTestMethod = method;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    fTestMethod = method;\n}\n```"
            ]
        }
    },
    "L8052": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public StubbedTheoryAnchor(FrameworkMethod method) {\n\t\t\tsuper(method);\n\t\t}",
        "AfterRefact": "public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tsuper(method, testClass);\n\t\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, AnotherParameter another) {\n    super(method);\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        }
    },
    "L4884": {
        "RefactMethod": "INLINE VARIABLE",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tfor (Throwable each : ((MultipleFailureException) targetException).getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tfor (Throwable each : ((MultipleFailureException) targetException).getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n\tif (targetException instanceof MultipleFailureException) {\n\t\tfor (Throwable each : ((MultipleFailureException) targetException).getFailures())\n\t\t\taddFailure(each);\n\t\treturn;\n\t}\n\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable failure : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(failure);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n\tif (targetException instanceof MultipleFailureException) {\n\t\tfor (Throwable each : ((MultipleFailureException) targetException).getFailures())\n\t\t\taddFailure(each);\n\t\treturn;\n\t}\n\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5882": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier = makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\texecuteTest(method, eachNotifier);\n\t}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n\t",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier= makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L5880": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\n\n\tprivate void runIgnored(EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestIgnored();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeMethodBlock(method, eachNotifier);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}",
                "private void executeMethodBlock(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    runTest(method, eachNotifier);\n}",
                "private void runTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    executeTest(method, eachNotifier);\n}",
                "private boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L4889": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}\n\n\tprivate void addMultipleFailureException(MultipleFailureException mfe) {\n\t\tfor (Throwable each : mfe.getFailures())\n\t\t\taddFailure(each);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n    } else {\n        fireTestFailure(targetException);\n    }\n}",
                "private void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}",
                "private void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}",
                "private void handleMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        addMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fireTestFailure(targetException);\n}",
                "private void addMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}",
                "private void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(each);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}",
                "private void handleMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L7126": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t}",
        "AfterRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t\tassertEquals(2, result.getRunCount());\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    boolean testSuccessful = result.wasSuccessful();\n    assertTrue(testSuccessful);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    // Adding assertion to ensure the filter is correctly applied\n    assertNotNull(include);\n    \n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    // Assertion to ensure that the category filter is not null\n    assert(include != null);\n    \n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L126": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
        "AfterRefact": "public TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}\n\n\tprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}\n\t",
        "ZeroShotCode": {
            "methods": [
                "private boolean validateConstructor(Class<? extends TestCase> theClass) {\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n    return true;\n}",
                "public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n    return true;\n}\n\nprivate boolean validatePublicClass(Class<? extends TestCase> theClass) {\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private boolean validatePublicClass(Class<? extends TestCase> theClass) {\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return false;\n    }\n    return true;\n}",
                "private void extractTestMethods(Class<? extends TestCase> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    if (!validateConstructor(theClass) || !validatePublicClass(theClass)) {\n        return;\n    }\n    extractTestMethods(theClass);\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void extractTestMethods(final Class<? extends TestCase> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractTestMethods(theClass);\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void extractTestMethods(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractTestMethods(theClass);\n    if (fTests.size() == 0) \n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private boolean isValidTestClass(Class<?> testClass) {\n    try {\n        getTestConstructor(testClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + testClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n\n    if (!Modifier.isPublic(testClass.getModifiers())) {\n        addTest(warning(\"Class \" + testClass.getName() + \" is not public\"));\n        return false;\n    }\n\n    return true;\n}",
                "public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n\n    if (!Modifier.isPublic(testClass.getModifiers())) {"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> testClass) {\n    fName = testClass.getName();\n    \n    if (!isValidTestClass(testClass)) {\n        return;\n    }\n\n    List<String> testMethodNames = new ArrayList<>();\n    Class<?> currentClass = testClass;\n\n    while (Test.class.isAssignableFrom(currentClass)) {\n        for (Method method : currentClass.getDeclaredMethods()) {\n            addTestMethod(method, testMethodNames, testClass);\n        }\n        currentClass = currentClass.getSuperclass();\n    }\n\n    if (fTests.isEmpty()) {\n        addTest(warning(\"No tests found in \" + testClass.getName()));\n    }\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void processTestClass(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    processTestClass(theClass);\n}\n\n",
                "\n```"
            ]
        }
    }
}