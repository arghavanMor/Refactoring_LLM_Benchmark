HEAD is now at ad9bac951 Fix diagrams for ATNState documentation
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3adbd8e21 L10937INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739492986.577891
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e2f541b58 L10937INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739492986.577891
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4ec04ce2a L10937INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739492986.577891
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 26cc00a96 L10937INTRODUCE_EXPLAINING_VARIABLEContextCode1739492986.577891
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a5442be70 L10937INTRODUCE_EXPLAINING_VARIABLERulesCode1739492986.577891
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ff10b04c7 L5343INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739493110.3937322
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6916b5475 L5343INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739493110.3937322
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9c82a1cfd L5343INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739493110.3937322
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4f7ef6a9f L5343INTRODUCE_EXPLAINING_VARIABLEContextCode1739493110.3937322
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 697e9ff6f L5343INTRODUCE_EXPLAINING_VARIABLERulesCode1739493110.3937322
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f1d6f6a7e L3671INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739493205.0202163
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e4889c296 L3671INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739493205.0202163
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2abaac136 L3671INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739493205.0202163
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b64d8e75e L3671INTRODUCE_EXPLAINING_VARIABLEContextCode1739493205.0202163
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4722bb2bd L3671INTRODUCE_EXPLAINING_VARIABLERulesCode1739493205.0202163
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 330353dc2 L3692INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739493357.2779774
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b6abe7382 L3692INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739493357.2779774
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0da19a354 L3692INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739493357.2779774
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 18826d4d0 L3692INTRODUCE_EXPLAINING_VARIABLEContextCode1739493357.2779774
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9b98fab3f L3692INTRODUCE_EXPLAINING_VARIABLERulesCode1739493357.2779774
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 208f793ea L7413INTRODUCE_ASSERTIONContextCode1739493508.17496432
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
=================== is_refactored ===================  1
Refactoring failed
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 236a4a3c9 L1927EXTRACT_METHODRulesCode1739493512.1902196
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8c6056b92 L5431CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739493515.64474912
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a0b79fd13 L5431CONSOLIDATE_COND_EXPRESSIONInstrucCode1739493515.64474912
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at efc3ecf2f L5431CONSOLIDATE_COND_EXPRESSIONFewShotCode1739493515.64474912
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 21689a829 L5431CONSOLIDATE_COND_EXPRESSIONContextCode1739493515.64474912
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 073ae2862 L5431CONSOLIDATE_COND_EXPRESSIONRulesCode1739493515.64474912
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d1a9c18c3 L3844CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739493640.06135313
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9ba637f43 L3844CONSOLIDATE_COND_EXPRESSIONInstrucCode1739493640.06135313
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 11106dee6 L3844CONSOLIDATE_COND_EXPRESSIONFewShotCode1739493640.06135313
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 730758a30 L3844CONSOLIDATE_COND_EXPRESSIONContextCode1739493640.06135313
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 98e1d2d30 L3844CONSOLIDATE_COND_EXPRESSIONRulesCode1739493640.06135313
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 462a9458a L3168CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739493763.82252614
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b762d46f3 L3168CONSOLIDATE_COND_EXPRESSIONInstrucCode1739493763.82252614
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e321d2226 L3168CONSOLIDATE_COND_EXPRESSIONFewShotCode1739493763.82252614
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 49336c593 L3168CONSOLIDATE_COND_EXPRESSIONContextCode1739493763.82252614
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c9900c0fa L3168CONSOLIDATE_COND_EXPRESSIONRulesCode1739493763.82252614
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6e36d7be3 L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739493774.27090115
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 29, column 75.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.WhileStatement(GeneratedJavaParser.java:4402)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3788)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 24, column 75.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.WhileStatement(GeneratedJavaParser.java:4402)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3788)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 187b03e18 L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493774.27090115
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d7bc61c98 L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739493774.27090115
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 176426111 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739493784.69426317
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2926b3b6c L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739493784.69426317
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 93ef89e6e L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739493784.69426317
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b829279be L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493784.69426317
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ccfab6681 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739493784.69426317
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 569eebf07 L156680CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739493800.91421318
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2646f152b L156680CONSOLIDATE_COND_EXPRESSIONInstrucCode1739493800.91421318
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6c3897498 L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739493800.91421318
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b8fc656c3 L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739493800.91421318
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 45de9306c L156680CONSOLIDATE_COND_EXPRESSIONRulesCode1739493800.91421318
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 87b8e990b L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739493816.77089119
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2d6ba358b L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739493816.77089119
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a0edbddbd L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739493816.77089119
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1b4b2f450 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493816.77089119
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ad72a4ae7 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739493816.77089119
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4e75fdc49 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739493827.633720
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b6bc50468 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739493827.633720
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0c026f5e1 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739493827.633720
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8d2314cd3 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493827.633720
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fca9470cf L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739493827.633720
----------------- Refactoring process has started .... -----------------
----------------- load is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 00424946e L13228CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739493838.12876721
----------------- Refactoring process has started .... -----------------
----------------- load is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 631d935b3 L13228CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493838.12876721
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 11, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 17, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0e31c0df2 L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493844.47212822
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 17, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 55f825d5c L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739493848.93597423
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at abf7741e9 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739493848.93597423
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f6cb338ad L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739493848.93597423
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 428d70038 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739493848.93597423
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 595c2e880 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739493848.93597423
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 8, column 91.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- addTransition is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 994a89dbf L1506CONSOLIDATE_COND_EXPRESSIONContextCode1739493946.03949524
----------------- Refactoring process has started .... -----------------
=================== is_refactored ===================  1
Refactoring failed
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 7, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6e7859da9 L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739493949.24559525
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b49e04698 L19910INTRODUCE_NULL_OBJECTZeroShotCode1739493952.90235726
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f52b803aa L19910INTRODUCE_NULL_OBJECTInstrucCode1739493952.90235726
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fa343aaee L19910INTRODUCE_NULL_OBJECTContextCode1739493952.90235726
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d8cbde74a L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739493960.21781127
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6c069e2af L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESInstrucCode1739493960.21781127
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5c3988843 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESFewShotCode1739493960.21781127
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8c517734e L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739493960.21781127
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 87d19a45a L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESRulesCode1739493960.21781127
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 08170a8e1 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739494034.15985928
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1381e0181 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESInstrucCode1739494034.15985928
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d23bfacc9 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESFewShotCode1739494034.15985928
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 40cdbebe2 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739494034.15985928
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9d434b184 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESRulesCode1739494034.15985928
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7b7b697b1 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739494188.31324429
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 06d97984f L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739494188.31324429
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 074530289 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739494188.31324429
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5c9ac85d2 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739494280.14589230
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 39fa64e46 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739494280.14589230
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b25a1be97 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTZeroShotCode1739494342.65968333
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int execute() {
        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class CalculateHashCodeCommand {

        private final int parentHashCode;

        private final int returnStateHashCode;

        public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7a0bef064 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTInstrucCode1739494342.65968333
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int execute() {
        this.result = calculateHashCode();
        return this.result;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        private int parentHashCode;

        private int returnStateHashCode;

        private int result;

        public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            this.result = calculateHashCode();
            return this.result;
        }

        private int calculateHashCode() {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 50c9b8491 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTFewShotCode1739494342.65968333
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 093ab7426 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTContextCode1739494342.65968333
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int calculate(int parentHashCode, int returnStateHashCode) {
        return MULTIPLIER1 * MULTIPLIER1 * MULTIPLIER2 + MULTIPLIER1 * parentHashCode + returnStateHashCode;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        private static final int MULTIPLIER1 = 5;

        private static final int MULTIPLIER2 = 7;

        public int calculate(int parentHashCode, int returnStateHashCode) {
            return MULTIPLIER1 * MULTIPLIER1 * MULTIPLIER2 + MULTIPLIER1 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 571de329a L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTRulesCode1739494342.65968333
Traceback (most recent call last):
  File "/Users/jeancarlorspaul/Documents/Doc_Carl/Poly/LLM_Refactoring_Project/Refactoring_AST/src/utils/main1.py", line 240, in <module>
    main()
  File "/Users/jeancarlorspaul/Documents/Doc_Carl/Poly/LLM_Refactoring_Project/Refactoring_AST/src/utils/main1.py", line 226, in main
    compilation_status = [results_dictionary[item]['compiled'] for item in results_dictionary.keys() if isinstance(results_dictionary[item], dict)]
                          ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^
KeyError: 'compiled'

Process finished with exit code 1
