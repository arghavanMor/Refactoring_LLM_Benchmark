{
    "L10937": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "\n\tpublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "AfterRefact": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tRuleFunction rf = getCurrentRuleFunction();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tdefineImplicitLabel(setAST, matchOp);\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\t\tmatchOp.labels.add(d);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = createMatchSet(invert, setAST);\n    if (labelAST != null) {\n        handleLabelAST(labelAST, setAST, matchOp);\n    }\n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp;\n    if (invert) {\n        matchOp = new MatchNotSet(this, setAST);\n    } else {\n        matchOp = new MatchSet(this, setAST);\n    }\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        boolean isPlusAssign = (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN);\n        if (isPlusAssign) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    boolean needsImplicitLabel = controller.needsImplicitLabel(setAST, matchOp);\n    if (needsImplicitLabel) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n\n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl labelDecl = getTokenLabelDecl(label);\n        matchOp.labels.add(labelDecl);\n        \n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), labelDecl);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl listLabelDecl = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), listLabelDecl);\n        }\n    }\n\n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp;\n    if (invert) matchOp = new MatchNotSet(this, setAST);\n    else matchOp = new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        boolean isPlusAssign = (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN);\n        if (isPlusAssign) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) defineImplicitLabel(setAST, matchOp);\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5343": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public List<ParseTreeListener> getParseListeners() {\n        return _parseListeners;\n    }",
        "AfterRefact": "public List<ParseTreeListener> getParseListeners() {\n\t\tList<ParseTreeListener> listeners = _parseListeners;\n\t\tif (listeners == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn listeners;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> listeners = _parseListeners;\n    return listeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    return new ArrayList<>(_parseListeners);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3671": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": " public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t@NotNull BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportAmbiguity d=\" + dfa.decision +\n\t\t\t\": ambigAlts=\" + ambigAlts + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }",
        "AfterRefact": "public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa,\n\t\t\t\t\t\t\t\tint startIndex,\n\t\t\t\t\t\t\t\tint stopIndex,\n\t\t\t\t\t\t\t\tboolean exact,\n\t\t\t\t\t\t\t\t@Nullable BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n\t{\n\t\tif (exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\n\t\tString format = \"reportAmbiguity d=%s: ambigAlts=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tBitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, conflictingAlts, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String ambiguityMessage = createAmbiguityMessage(recognizer, dfa, ambigAlts, startIndex, stopIndex);\n    recognizer.notifyErrorListeners(ambiguityMessage);\n}",
                "private String createAmbiguityMessage(@NotNull Parser recognizer, DFA dfa, @NotNull BitSet ambigAlts, int startIndex, int stopIndex) {\n    return \"reportAmbiguity d=\" + dfa.decision +\n           \": ambigAlts=\" + ambigAlts + \", input=\\'\" +\n           recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String errorMessage = \"reportAmbiguity d=\" + dfa.decision +\n                          \": ambigAlts=\" + ambigAlts + \", input=\\'\" + inputText + \"\\'\";\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs) {\n    String decisionMessage = \"reportAmbiguity d=\" + dfa.decision +\n            \": ambigAlts=\" + ambigAlts + \n            \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(decisionMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String errorMessage = String.format(\"reportAmbiguity d=%d: ambigAlts=%s, input=\\'%s\\'\",\n            dfa.decision, ambigAlts, \n            recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)));\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs) {\n    String message = \"reportAmbiguity d=\" + dfa.decision +\n                     \": ambigAlts=\" + ambigAlts + \", input=\\'\" +\n                     recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3692": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n                                         int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n\t\t\tdfa.decision + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }\n}",
        "AfterRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n\t{\n\t\tString format = \"reportContextSensitivity d=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = \"reportContextSensitivity d=\" + dfa.decision + \", input=\\'\" + inputText + \"\\'\";\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs)\n{\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n            dfa.decision + \", input=\\'\" + inputText + \"\\'\");\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String decisionInfo = \"reportContextSensitivity d=\" + dfa.decision + \n                          \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(decisionInfo);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                     @NotNull DFA dfa,\n                                     int startIndex, \n                                     int stopIndex,\n                                     @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = String.format(\"reportContextSensitivity d=%d, input=\\'%s\\'\", dfa.decision, inputText);\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String message = \"reportContextSensitivity d=\" + dfa.decision + \", input=\\'\" +\n                     recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L7413": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "AfterRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\n\t\t\tassert s.decision + 1 >= g.decisionLOOK.size();\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n            assert look.length > 0 : \"Lookahead array should have a positive length for non-greedy decision.\";\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n            assert look != null && look.length > 0 : \"Lookahead must not be null and must have positive length.\";\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n        assert disjoint(look) : \"Lookahead sets must be disjoint for LL(1) decisions.\";\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        assert s.decision >= 0 : \"Decision index must be non-negative\"; // Assertion added\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n\n        assert(s.getNumberOfTransitions() >= 0);\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<>(g.atn.getNumberOfDecisions() + 1);\n    \n    for (DecisionState decisionState : g.atn.decisionToState) {\n        logDecisionInformation(decisionState);\n        \n        IntervalSet[] lookaheadSets = createLookaheadSets(decisionState);\n        Utils.setSize(g.decisionLOOK, decisionState.decision + 1);\n        g.decisionLOOK.set(decisionState.decision, lookaheadSets);\n        \n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(lookaheadSets));\n    }\n}",
                "private void logDecisionInformation(DecisionState decisionState) {\n    g.tool.log(\"LL1\", \"\\\nDECISION \" + decisionState.decision + \" in rule \" + g.getRule(decisionState.ruleIndex).name);\n}",
                "private IntervalSet[] createLookaheadSets(DecisionState decisionState) {\n    if (decisionState.nonGreedy) {\n        return new IntervalSet[decisionState.getNumberOfTransitions() + 1];\n    } else {\n        LL1Analyzer analyzer = new LL1Analyzer(g.atn);\n        IntervalSet[] lookaheadSets = analyzer.getDecisionLookahead(decisionState);\n        g.tool.log(\"LL1\", \"look=\" + Arrays.toString(lookaheadSets));\n        return lookaheadSets;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n        \n        // Introduce assertion\n        assert look != null : \"Lookahead array should not be null for decision \" + s.decision;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L10037": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tIntervalSet enterLook = altLookSets[1];\n\t\tIntervalSet exitLook = altLookSets[2];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "AfterRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tassert altLookSets.length == 2;\n\t\tIntervalSet enterLook = altLookSets[0];\n\t\tIntervalSet exitLook = altLookSets[1];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets.length > 2 : \"altLookSets must be of sufficient length\";\n    \n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    assert star != null : \"star must not be null\";\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    assert loopBackStateNumber >= 0 : \"loopBackStateNumber must be non-negative\";\n    this.decision = star.decision;\n    assert decision >= 0 : \"decision must be non-negative\";\n    \n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets != null : \"altLookSets must not be null\";\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n\n    assert(factory.getGrammar().decisionLOOK.containsKey(decision));\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert(altLookSets.length > 2);\n    \n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void initializeLoopParameters(OutputModelFactory factory, GrammarAST starRoot) {\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    \n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n    \n    initializeLoopParameters(factory, starRoot);\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n    \n    // Introduced assertion for enterLook and exitLook\n    assert enterLook != null : \"EnterLook should not be null\";\n    assert exitLook != null : \"ExitLook should not be null\";\n}\n```"
            ]
        }
    },
    "L1927": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(\"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tATNConfigSet closure = s.configs;\n\t\t\tDFAState target = null;\n\t\t\tif ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {\n\t\t\t\ttarget = s.edges[t - MIN_DFA_EDGE];\n\t\t\t\tif (target == ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (debug && target != null) {\n\t\t\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (target == null) {\n\t\t\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t\t\t// if we don't find an existing DFA state\n\t\t\t\t// Fill reach starting from closure, following t transitions\n\t\t\t\tgetReachableConfigSet(input, closure, reach, t);\n\n\t\t\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t\t\t// we reached state associated with closure for sure, so\n\t\t\t\t\t// make sure it's defined. worst case, we define s0 from\n\t\t\t\t\t// start state configs.\n\t\t\t\t\t@NotNull\n\t\t\t\t\tDFAState from = s != null ? s : addDFAState(closure);\n\t\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t\t// cause a failover from DFA later.\n\t\t\t\t\taddDFAEdge(from, t, ERROR);\n\t\t\t\t\tbreak; // stop when we can't match any more char\n\t\t\t\t}\n\n\t\t\t\t// Add an edge from s to target DFA found/created for reach\n\t\t\t\ttarget = addDFAEdge(s, t, reach);\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}",
        "AfterRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(Locale.getDefault(), \"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tDFAState target = getExistingTargetState(s, t);\n\t\t\tif (target == null) {\n\t\t\t\ttarget = computeTargetState(input, s, t);\n\t\t\t}\n\n\t\t\tif (target == ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\t@Nullable\n\tprotected DFAState getExistingTargetState(@NotNull DFAState s, int t) {\n\t\tif (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tDFAState target = s.edges[t - MIN_DFA_EDGE];\n\t\tif (debug && target != null) {\n\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link #ERROR}.\n\t */\n\t@NotNull\n\tprotected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {\n\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tgetReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t// cause a failover from DFA later.\n\t\t\taddDFAEdge(s, t, ERROR);\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ERROR;\n\t\t}\n\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn addDFAEdge(s, t, reach);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = getTargetState(s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug && target != null) {\n                System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        DFAState target = findDFAEdge(s, t);\n        if (target == null) {\n            ATNConfigSet closure = s.configs;\n            ATNConfigSet reach = new OrderedATNConfigSet();\n\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState findDFAEdge(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        \n        return target;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = getDfaTarget(s, t);\n        \n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n            target = handleNoExistingDFAState(closure, s, reach, t);\n            if (target == null) {\n                break; // stop when we can\\'t match any more char\n            }\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getDfaTarget(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}",
                "private DFAState handleNoExistingDFAState(ATNConfigSet closure, DFAState s, ATNConfigSet reach, int t) {\n    if (reach.isEmpty()) { // we got nowhere on t from s\n        @NotNull\n        DFAState from = s != null ? s : addDFAState(closure);\n        addDFAEdge(from, t, ERROR);\n        return null;\n    }\n    return addDFAEdge(s, t, reach);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState initialState) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", initialState.configs);\n    }\n\n    int currentToken = input.LA(1);\n    DFAState currentState = initialState;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", currentState.configs);\n        }\n\n        ATNConfigSet closure = currentState.configs;\n        DFAState targetState = getTargetState(currentState, currentToken);\n\n        if (targetState == null) {\n            ATNConfigSet reachableConfigs = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reachableConfigs, currentToken);\n\n            if (reachableConfigs.isEmpty()) {\n                DFAState fromState = currentState != null ? currentState : addDFAState(closure);\n                addDFAEdge(fromState, currentToken, ERROR);\n                break;\n            }\n\n            targetState = addDFAEdge(currentState, currentToken, reachableConfigs);\n        }\n\n        if (targetState.isAcceptState) {\n            captureSimState(prevAccept, input, targetState);\n            if (currentToken == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (currentToken != IntStream.EOF) {\n            consume(input);\n            currentToken = input.LA(1);\n        }\n\n        currentState = targetState;\n    }\n\n    return failOrAccept(prevAccept, input, currentState.configs, currentToken);\n}",
                "private DFAState getTargetState(DFAState state, int token) {\n    if (state.edges != null && token >= MIN_DFA_EDGE && token <= MAX_DFA_EDGE) {\n        DFAState target = state.edges[token - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + state.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    //System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n    \n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = processDFAState(input, t, s, closure);\n        \n        if (target == null) {\n            break; // stop when we can\\'t match any more char\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState processDFAState(@NotNull CharStream input, int t, @NotNull DFAState s, ATNConfigSet closure) {\n    DFAState target = null;\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n    }\n\n    if (target == null) {\n        ATNConfigSet reach = new OrderedATNConfigSet();\n        // Fill reach starting from closure, following t transitions\n        getReachableConfigSet(input, closure, reach, t);\n        \n        if (reach.isEmpty()) { // we got nowhere on t from s\n            @NotNull\n            DFAState from = s != null ? s : addDFAState(closure);\n            addDFAEdge(from, t, ERROR);\n            return null;\n        }\n\n        // Add an edge from s to target DFA found/created for reach\n        target = addDFAEdge(s, t, reach);\n    }\n    \n    return target;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L540": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t DFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t boolean exact,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, \n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts, \n                     @NotNull ATNConfigSet configs) {\n    // Method implementation\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, \n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts, \n                     @NotNull ATNConfigSet configs) {\n    // Method implementation\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, int startIndex, int stopIndex,\n                     @NotNull BitSet ambiguousAlternatives,\n                     @NotNull ATNConfigSet configs);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex,\n                     @NotNull BitSet ambigAlts,\n                     @NotNull ATNConfigSet configs) {\n    // Method implementation\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, \n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts) {\n    // method implementation\n}\n```"
            ]
        }
    },
    "L561": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t @Nullable BitSet conflictingAlts,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer, @NotNull DFA dfa, int startIndex, int stopIndex, @NotNull ATNConfigSet configs) {\n    // Method implementation goes here\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // method implementation\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                   @NotNull DFA dfa,\n                                   int startIndex, int stopIndex,\n                                   @NotNull ATNConfigSet configs) {\n    // Method implementation here\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Method implementation goes here\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  @NotNull ATNConfigSet configs);\n```"
            ]
        }
    },
    "L5431": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\t\tif (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n\t}",
        "AfterRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\n\t\tif (_buildParseTrees && _parentctx != null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\t_parentctx.addChild(retctx);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t_ctx.stop = _input.LT(-1);\n\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t// unroll so _ctx is as it was before call to recursive method\n\tif (_parseListeners != null && _ctx != _parentctx) {\n\t\twhile (_ctx != _parentctx) {\n\t\t\ttriggerExitRuleEvent();\n\t\t\t_ctx = (ParserRuleContext) _ctx.parent;\n\t\t}\n\t} else {\n\t\t_ctx = _parentctx;\n\t}\n\n\t// hook into tree\n\tretctx.parent = _parentctx;\n\tif (_buildParseTrees) {\n\t\t_parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null || _ctx != _parentctx) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    \n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext parentCtx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext returnCtx = _ctx; // Save current context (return value)\n\n    // Unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null) {\n        while (_ctx != parentCtx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = parentCtx;\n    }\n\n    // Hook into tree\n    returnCtx.parent = parentCtx;\n    if (_buildParseTrees) {\n        parentCtx.addChild(returnCtx); // Add return context into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3844": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "AfterRefact": " public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "ZeroShotCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p >= 0) ? (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size()) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p < 0) ? false : (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size());\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p < 0) ? false : (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size());\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = shouldSkipEofCheck(p, fetchedEOF);\n    \n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}",
                "private boolean shouldSkipEofCheck(int position, boolean fetchedEOF) {\n    if (position < 0) {\n        return false; // not yet initialized\n    }\n    \n    return fetchedEOF ? position < tokens.size() - 1 : position < tokens.size();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck;\n    if (p >= 0) {\n        skipEofCheck = fetchedEOF ? (p < tokens.size() - 1) : (p < tokens.size());\n    } else {\n        skipEofCheck = false;\n    }\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3168": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates.\n\t\t */\n\t\tif (skippedStopStates == null) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "AfterRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates, or when the current symbol is EOF.\n\t\t */\n\t\tif (skippedStopStates == null && t != Token.EOF) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tboolean treatEofAsEpsilon = t == Token.EOF;\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER))\n            ? intermediate : null;\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = determineReach(intermediate, skippedStopStates, fullCtx, t);\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}",
                "private ATNConfigSet determineReach(ATNConfigSet intermediate, List<ATNConfig> skippedStopStates, boolean fullCtx, int t) {\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            return intermediate;\n        }\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L10263": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenDisplayNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        marked.add(s);\n        processStateTransitions(s, buf);\n    }\n    return buf.toString();\n}",
                "private void processStateTransitions(ATNState s, StringBuilder buf) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        handleTransition(s, t, buf);\n    }\n}",
                "private void handleTransition(ATNState s, Transition t, StringBuilder buf) {\n    if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n        if (t instanceof RuleTransition) {\n            work.add(((RuleTransition) t).followState);\n        } else {\n            work.add(t.target);\n        }\n    }\n    buf.append(getStateString(s));\n    appendTransition(buf, t);\n}",
                "private void appendTransition(StringBuilder buf, Transition t) {\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition) t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition) t;\n        boolean not = st instanceof NotSetTransition;\n        appendSetTransition(buf, st, not);\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition) t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}",
                "private void appendSetTransition(StringBuilder buf, SetTransition st, boolean not) {\n    if (g.isLexer()) {\n        buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(st.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(st.target)).append(\\'\\\n\\');\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n            buf.append(getStateString(s));\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof RuleTransition) {\n                buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof ActionTransition) {\n                ActionTransition a = (ActionTransition) t;\n                buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition) t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                } else {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                }\n            } else if (t instanceof AtomTransition) {\n                AtomTransition a = (AtomTransition) t;\n                String label = g.getTokenDisplayName(a.label);\n                buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else {\n                buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            }\n        }\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) {\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n\n            buf.append(getStateString(s));\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof RuleTransition) {\n                buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof ActionTransition) {\n                ActionTransition a = (ActionTransition) t;\n                buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition) t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                } else {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                }\n            } else if (t instanceof AtomTransition) {\n                AtomTransition a = (AtomTransition) t;\n                String label = g.getTokenDisplayName(a.label);\n                buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else {\n                buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            }\n        }\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n\n    marked = new HashSet<>();\n    work = new ArrayList<>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n\n    while (!work.isEmpty()) {\n        ATNState s = work.remove(0);\n        if (marked.contains(s)) continue;\n\n        marked.add(s);\n        int n = s.getNumberOfTransitions();\n\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) {\n                addFollowStateToWork(t);\n            }\n            appendTransitionInfo(buf, s, t);\n        }\n    }\n    return buf.toString();\n}",
                "private void addFollowStateToWork(Transition t) {\n    if (t instanceof RuleTransition) {\n        work.add(((RuleTransition) t).followState);\n    } else {\n        work.add(t.target);\n    }\n}",
                "private void appendTransitionInfo(StringBuilder buf, ATNState s, Transition t) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name)\n            .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        appendSetTransitionInfo(buf, (SetTransition) t);\n    } else if (t instanceof AtomTransition) {\n        appendAtomTransitionInfo(buf, (AtomTransition) t);\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}",
                "private void appendSetTransitionInfo(StringBuilder buf, SetTransition st) {\n    boolean not = st instanceof NotSetTransition;\n    String label = g.isLexer() ? (not ? \"~\" : \"\") + st.toString() : (not ? \"~\" : \"\") + st.label().toString(g.getTokenNames());\n    buf.append(\"-\").append(label).append(\"->\").append(getStateString(st.target)).append(\\'\\\n\\');\n}",
                "private void appendAtomTransitionInfo(StringBuilder buf, AtomTransition a) {\n    String label = g.getTokenDisplayName(a.label);\n    buf.append(\"-\").append(label).append(\"->\").append(getStateString(a.target)).append(\\'\\\n\\');\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n\n    marked = new HashSet<ATNState>();\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n\n        marked.add(s);\n        for (int i = 0; i < s.getNumberOfTransitions(); i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n            buf.append(getStateString(s)).append(\"-\");\n\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof RuleTransition) {\n                buf.append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof ActionTransition) {\n                buf.append(((ActionTransition) t).toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition) t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                } else {\n                    buf.append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                }\n            } else if (t instanceof AtomTransition) {\n                String label = g.getTokenDisplayName(((AtomTransition) t).label);\n                buf.append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else {\n                buf.append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            }\n        }\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L102630": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "AfterRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String prefix = \"s\" + n;\n\n    if (s instanceof StarBlockStartState) {\n        prefix = \"StarBlockStart_\";\n    } else if (s instanceof PlusBlockStartState) {\n        prefix = \"PlusBlockStart_\";\n    } else if (s instanceof BlockStartState) {\n        prefix = \"BlockStart_\";\n    } else if (s instanceof BlockEndState) {\n        prefix = \"BlockEnd_\";\n    } else if (s instanceof RuleStartState) {\n        prefix = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\";\n    } else if (s instanceof RuleStopState) {\n        prefix = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\";\n    } else if (s instanceof PlusLoopbackState) {\n        prefix = \"PlusLoopBack_\";\n    } else if (s instanceof StarLoopbackState) {\n        prefix = \"StarLoopBack_\";\n    } else if (s instanceof StarLoopEntryState) {\n        prefix = \"StarLoopEntry_\";\n    }\n\n    return prefix + n;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    } else {\n        stateStr = \"s\" + n; // Default case\n    }\n\n    return stateStr;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr;\n    \n    if (s instanceof StarBlockStartState) \n        stateStr = \"StarBlockStart_\" + n;\n    else if (s instanceof PlusBlockStartState) \n        stateStr = \"PlusBlockStart_\" + n;\n    else if (s instanceof BlockStartState) \n        stateStr = \"BlockStart_\" + n;\n    else if (s instanceof BlockEndState) \n        stateStr = \"BlockEnd_\" + n;\n    else if (s instanceof RuleStartState) \n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    else if (s instanceof RuleStopState) \n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    else if (s instanceof PlusLoopbackState) \n        stateStr = \"PlusLoopBack_\" + n;\n    else if (s instanceof StarLoopbackState) \n        stateStr = \"StarLoopBack_\" + n;\n    else if (s instanceof StarLoopEntryState) \n        stateStr = \"StarLoopEntry_\" + n;\n    else \n        stateStr = \"s\" + n;\n    \n    return stateStr;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private String getPrefix(ATNState s) {\n    if (s instanceof StarBlockStartState) return \"StarBlockStart_\";\n    if (s instanceof PlusBlockStartState) return \"PlusBlockStart_\";\n    if (s instanceof BlockStartState) return \"BlockStart_\";\n    if (s instanceof BlockEndState) return \"BlockEnd_\";\n    if (s instanceof PlusLoopbackState) return \"PlusLoopBack_\";\n    if (s instanceof StarLoopbackState) return \"StarLoopBack_\";\n    if (s instanceof StarLoopEntryState) return \"StarLoopEntry_\";\n    return \"\";\n}"
            ],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    StringBuilder stateStr = new StringBuilder(\"s\").append(n);\n\n    if (s instanceof RuleStartState || s instanceof RuleStopState) {\n        String ruleName = g.getRule(s.ruleIndex).name;\n        stateStr = new StringBuilder(getPrefix(s)).append(ruleName).append(\"_\").append(n);\n    } else {\n        stateStr = new StringBuilder(getPrefix(s)).append(n);\n    }\n\n    return stateStr.toString();\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof StarBlockStartState)\n        stateStr = \"StarBlockStart_\" + n;\n    else if (s instanceof PlusBlockStartState)\n        stateStr = \"PlusBlockStart_\" + n;\n    else if (s instanceof BlockStartState)\n        stateStr = \"BlockStart_\" + n;\n    else if (s instanceof BlockEndState)\n        stateStr = \"BlockEnd_\" + n;\n    else if (s instanceof RuleStartState)\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    else if (s instanceof RuleStopState)\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    else if (s instanceof PlusLoopbackState)\n        stateStr = \"PlusLoopBack_\" + n;\n    else if (s instanceof StarLoopbackState)\n        stateStr = \"StarLoopBack_\" + n;\n    else if (s instanceof StarLoopEntryState)\n        stateStr = \"StarLoopEntry_\" + n;\n\n    return stateStr;\n}\n```"
            ]
        }
    },
    "L15668": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addAcceptStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addAcceptStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1;\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // Define stop states first to avoid issues with doublecircle in DOT\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    // Define regular states\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) continue;\n        if (d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    // Define edges\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null) continue;\n                if (target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // Shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if ( dfa.s0 == null ) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // define stop states first; seems to be a bug in DOT where doublecircle\n    for (DFAState d : dfa.states.keySet()) {\n        if ( !d.isAcceptState ) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if ( d.isAcceptState ) continue;\n        if ( d.stateNumber == Integer.MAX_VALUE ) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if ( d.edges != null ) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if ( target == null ) continue;\n                if ( target.stateNumber == Integer.MAX_VALUE ) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if ( isLexer ) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if ( grammar != null ) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    setupDotHeader(dot, dfa);\n\n    addStopStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void setupDotHeader(ST dot, DFA dfa) {\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n}",
                "private void addStopStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (!state.isAcceptState) continue;\n        ST stopStateTemplate = stlib.getInstanceOf(\"stopstate\");\n        stopStateTemplate.add(\"name\", \"s\" + state.stateNumber);\n        stopStateTemplate.add(\"label\", getStateLabel(state));\n        dot.add(\"states\", stopStateTemplate);\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.isAcceptState || state.stateNumber == Integer.MAX_VALUE) continue;\n        ST regularStateTemplate = stlib.getInstanceOf(\"state\");\n        regularStateTemplate.add(\"name\", \"s\" + state.stateNumber);\n        regularStateTemplate.add(\"label\", getStateLabel(state));\n        dot.add(\"states\", regularStateTemplate);\n    }\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.edges != null) {\n            for (int i = 0; i < state.edges.length; i++) {\n                DFAState target = state.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n\n                String label = getEdgeLabel(i, isLexer);\n                ST edgeTemplate = stlib.getInstanceOf(\"edge\");\n                edgeTemplate.add(\"label\", label);\n                edgeTemplate.add(\"src\", \"s\" + state.stateNumber);\n                edgeTemplate.add(\"target\", \"s\" + target.stateNumber);\n                edgeTemplate.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", edgeTemplate);\n            }\n        }\n    }\n}",
                "private String getEdgeLabel(int index, boolean isLexer) {\n    int ttype = index - 1; // Shift up for EOF as -1 for parser\n    if (isLexer) {\n        return \"\\'\" + getEdgeLabel(String.valueOf((char) index)) + \"\\'\";\n    } else if (grammar != null) {\n        return grammar.getTokenDisplayName(ttype);\n    }\n    return String.valueOf(ttype);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        ST st;\n        if (d.isAcceptState) {\n            st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n        } else {\n            continue;\n        }\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L156680": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; \n                    String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" :\n                                             (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // define stop states first\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // shift up for EOF as -1 for parser\n                    String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // define stop states first\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState && d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // shift up for EOF as -1 for parser\n                    String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" \n                                           : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    initializeDOT(dot, dfa);\n\n    addAcceptStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void initializeDOT(ST dot, DFA dfa) {\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n}",
                "private void addAcceptStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.isAcceptState) {\n            addState(dot, state, \"stopstate\");\n        }\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (!state.isAcceptState && state.stateNumber != Integer.MAX_VALUE) {\n            addState(dot, state, \"state\");\n        }\n    }\n}",
                "private void addState(ST dot, DFAState state, String template) {\n    ST st = stlib.getInstanceOf(template);\n    st.add(\"name\", \"s\" + state.stateNumber);\n    st.add(\"label\", getStateLabel(state));\n    dot.add(\"states\", st);\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.edges != null) {\n            for (int i = 0; i < state.edges.length; i++) {\n                DFAState target = state.edges[i];\n                if (isValidTarget(target)) {\n                    addEdge(dot, state, target, i, isLexer);\n                }\n            }\n        }\n    }\n}",
                "private boolean isValidTarget(DFAState target) {\n    return target != null && target.stateNumber != Integer.MAX_VALUE;\n}",
                "private void addEdge(ST dot, DFAState source, DFAState target, int i, boolean isLexer) {\n    int ttype = i - 1;\n    String label = getEdgeLabel(isLexer, i, ttype);\n    ST st = stlib.getInstanceOf(\"edge\");\n    st.add(\"label\", label);\n    st.add(\"src\", \"s\" + source.stateNumber);\n    st.add(\"target\", \"s\" + target.stateNumber);\n    st.add(\"arrowhead\", arrowhead);\n    dot.add(\"edges\", st);\n}",
                "private String getEdgeLabel(boolean isLexer, int i, int ttype) {\n    if (isLexer) {\n        return \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n    } else if (grammar != null) {\n        return grammar.getTokenDisplayName(ttype);\n    } else {\n        return String.valueOf(ttype);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        ST st;\n        if (d.isAcceptState) {\n            st = stlib.getInstanceOf(\"stopstate\");\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            st = stlib.getInstanceOf(\"state\");\n        } else {\n            continue;\n        }\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                \n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3347": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(ATNConfig config,\n\t\t\t\t\t\t\tATNConfigSet configs,\n\t\t\t\t\t\t\tSet<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_dfa != null && _dfa.isPrecedenceDfa()) {\n\t\t\t\t\t\tint outermostPrecedenceReturn = ((EpsilonTransition)t).outermostPrecedenceReturn();\n\t\t\t\t\t\tif (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {\n\t\t\t\t\t\t\tc.setPrecedenceFilterSuppressed(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void closure_( \n    @NotNull ATNConfig config,\n    @NotNull ATNConfigSet configs,\n    @NotNull Set<ATNConfig> closureBusy,\n    boolean collectPredicates,\n    boolean fullCtx,\n    int depth,\n    boolean treatEofAsEpsilon) {\n\n    ATNState p = config.state;\n\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        \n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\tint depth,\n\t\t\t\t\t\tboolean treatEofAsEpsilon) {\n\tATNState p = config.state;\n\t// optimization\n\tif (!p.onlyHasEpsilonTransitions()) {\n\t\tconfigs.add(config, mergeCache);\n\t\t// make sure to not return here, because EOF transitions can act as\n\t\t// both epsilon transitions and non-epsilon transitions.\n\t\t// if ( debug ) System.out.println(\"added config \"+configs);\n\t}\n\n\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\tTransition t = p.transition(i);\n\t\tboolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\tif (c != null) {\n\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint newDepth = depth;\n\t\t\tif (config.state instanceof RuleStopState) {\n\t\t\t\tassert !fullCtx;\n\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t// We can\\'t get here if incoming config was rule stop and we had context\n\t\t\t\t// track how far we dip into outer context. Might\n\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t// preds if this is > 0.\n\n\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\tnewDepth--;\n\t\t\t\tif (debug) System.out.println(\"dips into outer ctx: \" + c);\n\t\t\t} else if (t instanceof RuleTransition) {\n\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can\\'t return\n\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\tnewDepth++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t}\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void closure(\n        @NotNull ATNConfig config,\n        @NotNull ATNConfigSet configs,\n        @NotNull Set<ATNConfig> closureBusy,\n        boolean collectPredicates,\n        boolean fullCtx,\n        int depth,\n        boolean treatEofAsEpsilon\n) {\n    ATNState state = config.state;\n\n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean shouldCollect = !(transition instanceof ActionTransition) && collectPredicates;\n        ATNConfig targetConfig = getEpsilonTarget(config, transition, shouldCollect, depth == 0, fullCtx, treatEofAsEpsilon);\n\n        if (targetConfig != null) {\n            if (!transition.isEpsilon() && !closureBusy.add(targetConfig)) {\n                continue; // Avoid infinite recursion for EOF* and EOF+\n            }\n\n            int currentDepth = depth;\n\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(targetConfig)) {\n                    continue; // Avoid infinite recursion for right-recursive rules\n                }\n\n                targetConfig.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert currentDepth > Integer.MIN_VALUE;\n                currentDepth--;\n\n                if (debug) {\n                    System.out.println(\"Dips into outer context: \" + targetConfig);\n                }\n            } else if (transition instanceof RuleTransition) {\n                if (currentDepth >= 0) {\n                    currentDepth++;\n                }\n            }\n\n            closureCheckingStopState(targetConfig, configs, closureBusy, shouldCollect, fullCtx, currentDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting =\n            !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n                                       depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true; \n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting,\n                                     fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2755": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof AbstractPredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        handleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, stopState, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        return;\n    }\n\n    processTransitions(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n}",
                "private void handleStopState(@Nullable PredictionContext ctx, @NotNull IntervalSet look, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n}",
                "private void handleRuleStopState(@Nullable PredictionContext ctx, @Nullable ATNState stopState,\n                                  @NotNull IntervalSet look, @NotNull Set<ATNConfig> lookBusy,\n                                  @NotNull BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n\n    if (ctx != PredictionContext.EMPTY) {\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}",
                "private void processTransitions(@NotNull ATNState s, @Nullable ATNState stopState,\n                                @Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                boolean seeThruPreds, boolean addEOF) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            processRuleTransition((RuleTransition) t, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            processPredicateTransition(t, seeThruPreds, ctx, look, lookBusy, calledRuleStack, stopState, addEOF);\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            addTransitionLabelToLook(t, look);\n        }\n    }\n}",
                "private void processRuleTransition(RuleTransition t, @Nullable ATNState stopState,\n                                    @Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                    @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                    boolean seeThruPreds, boolean addEOF) {\n    if (calledRuleStack.get(t.target.ruleIndex)) {\n        return;\n    }\n\n    PredictionContext newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n    try {\n        calledRuleStack.set(t.target.ruleIndex);\n        _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } finally {\n        calledRuleStack.clear(t.target.ruleIndex);\n    }\n}",
                "private void processPredicateTransition(Transition t, boolean seeThruPreds,\n                                        @Nullable PredictionContext ctx, @NotNull IntervalSet look,\n                                        @NotNull Set<ATNConfig> lookBusy,\n                                        @NotNull BitSet calledRuleStack, @Nullable ATNState stopState,\n                                        boolean addEOF) {\n    if (seeThruPreds) {\n        _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } else {\n        look.add(HIT_PRED);\n    }\n}",
                "private void addTransitionLabelToLook(Transition t, @NotNull IntervalSet look) {\n    IntervalSet set = t.label();\n    if (set != null) {\n        if (t instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        look.addAll(set);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds,\n                     boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext = \n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void lookAhead(@NotNull ATNState state,\n                         @Nullable ATNState stopState,\n                         @Nullable PredictionContext context,\n                         @NotNull IntervalSet lookaheadSet,\n                         @NotNull Set<ATNConfig> lookBusy,\n                         @NotNull BitSet calledRuleStack,\n                         boolean seeThroughPredicates, boolean addEOF) {\n    \n    ATNConfig config = new ATNConfig(state, 0, context);\n    if (!lookBusy.add(config)) return;\n\n    if (state == stopState) {\n        handleStopState(context, lookaheadSet, addEOF);\n        return;\n    }\n\n    if (state instanceof RuleStopState) {\n        handleRuleStopState(context, lookaheadSet, addEOF);\n        return;\n    }\n\n    processTransitions(state, stopState, context, lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n}",
                "private void handleStopState(@Nullable PredictionContext context, IntervalSet lookaheadSet, boolean addEOF) {\n    if (context == null) {\n        lookaheadSet.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookaheadSet.add(Token.EOF);\n    }\n}",
                "private void handleRuleStopState(@Nullable PredictionContext context, IntervalSet lookaheadSet, boolean addEOF) {\n    if (context == null) {\n        lookaheadSet.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookaheadSet.add(Token.EOF);\n    } else if (context != PredictionContext.EMPTY) {\n        for (int i = 0; i < context.size(); i++) {\n            ATNState returnState = atn.states.get(context.getReturnState(i));\n            boolean wasRemoved = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                lookAhead(returnState, stopState, context.getParent(i), lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n            } finally {\n                if (wasRemoved) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}",
                "private void processTransitions(ATNState state, \n                                @Nullable ATNState stopState, \n                                @Nullable PredictionContext context, \n                                IntervalSet lookaheadSet, \n                                Set<ATNConfig> lookBusy, \n                                BitSet calledRuleStack, \n                                boolean seeThroughPredicates, \n                                boolean addEOF) {\n    int transitionCount = state.getNumberOfTransitions();\n    for (int i = 0; i < transitionCount; i++) {\n        Transition transition = state.transition(i);\n        if (transition instanceof RuleTransition) {\n            handleRuleTransition((RuleTransition) transition, stopState, context, lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n        } else if (transition instanceof PredicateTransition) {\n            handlePredicateTransition(transition, stopState, context, lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n        } else if (transition.isEpsilon()) {\n            lookAhead(transition.target, stopState, context, lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n        } else if (transition instanceof WildcardTransition) {\n            lookaheadSet.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            handleOtherTransitions(transition, lookaheadSet);\n        }\n    }\n}",
                "private void handleRuleTransition(RuleTransition transition, \n                                   @Nullable ATNState stopState, \n                                   @Nullable PredictionContext context, \n                                   IntervalSet lookaheadSet, \n                                   Set<ATNConfig> lookBusy, \n                                   BitSet calledRuleStack, \n                                   boolean seeThroughPredicates, \n                                   boolean addEOF) {\n    if (calledRuleStack.get(transition.target.ruleIndex)) {\n        return;\n    }\n\n    PredictionContext newContext = SingletonPredictionContext.create(context, transition.followState.stateNumber);\n    try {\n        calledRuleStack.set(transition.target.ruleIndex);\n        lookAhead(transition.target, stopState, newContext, lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } finally {\n        calledRuleStack.clear(transition.target.ruleIndex);\n    }\n}",
                "private void handlePredicateTransition(Transition transition, \n                                       @Nullable ATNState stopState, \n                                       @Nullable PredictionContext context, \n                                       IntervalSet lookaheadSet, \n                                       Set<ATNConfig> lookBusy, \n                                       BitSet calledRuleStack, \n                                       boolean seeThroughPredicates, \n                                       boolean addEOF) {\n    if (seeThroughPredicates) {\n        lookAhead(transition.target, stopState, context, lookaheadSet, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } else {\n        lookaheadSet.add(HIT_PRED);\n    }\n}",
                "private void handleOtherTransitions(Transition transition, IntervalSet lookaheadSet) {\n    IntervalSet labels = transition.label();\n    if (labels != null) {\n        if (transition instanceof NotSetTransition) {\n            labels = labels.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        lookaheadSet.addAll(labels);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState || (s instanceof RuleStopState && (ctx == null || (ctx.isEmpty() && addEOF)))) {\n        look.add(ctx == null ? Token.EPSILON : Token.EOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState && ctx != PredictionContext.EMPTY) {\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n        return;\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L13228": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tFileReader fr = new FileReader(fullFile);\n\t\t\tBufferedReader br = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  ioe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\treturn tokens;\n\t}",
        "AfterRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\tFileReader fr = null;\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tfr = new FileReader(fullFile);\n\t\t\tbr = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token type: \"+tokenTypeS,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t\ttokenType = Token.INVALID_TOKEN_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ( br!=null ) br.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t\t  ioe);\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private void processTokenDefinition(String tokenDef, int lineNum, Map<String, Integer> tokens, Pattern tokenDefPattern) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (tokenDef.length() > 0) {\n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                \" bad token def: \" + tokenDef,\n                lineNum);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    \n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        String tokenDef;\n        int lineNum = 1;\n\n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokenDef, lineNum, tokens, tokenDefPattern);\n            lineNum++;\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    \n    return tokens;\n}\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n    \n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        String tokenDef;\n        int lineNum = 1;\n        \n        while ((tokenDef = br.readLine()) != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                int tokenType = Integer.valueOf(matcher.group(2));\n                tool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) { // ignore blank lines\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \"+tokenDef,\n                                          lineNum);\n                }\n            }\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    \n    return tokens;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    File fullFile = getImportedVocabFile();\n    int maxTokenType = -1;\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n        int lineNum = 1;\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) { // ignore blank lines\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \" + tokenDef,\n                                          lineNum);\n                }\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n                              fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              e);\n    }\n    return tokens;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void processTokenDefinition(Map<String, Integer> tokens, String tokenDef, \n                                    Pattern tokenDefPattern, int lineNum) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    \n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (!tokenDef.trim().isEmpty()) {\n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR, \n                                vocabName + CodeGenerator.VOCAB_FILE_EXTENSION, \n                                \" bad token def: \" + tokenDef, \n                                lineNum);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n\n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        String tokenDef;\n        int lineNum = 1;\n\n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokens, tokenDef, tokenDefPattern, lineNum);\n            lineNum++;\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n\n    return tokens;\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\tint maxTokenType = -1;\n\tFile fullFile = getImportedVocabFile();\n\ttry {\n\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n\t\tFileReader fr = new FileReader(fullFile);\n\t\tBufferedReader br = new BufferedReader(fr);\n\t\tString tokenDef = br.readLine();\n\t\tint lineNum = 1;\n\t\twhile (tokenDef != null) {\n\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\tif (matcher.find()) {\n\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\tint tokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\ttool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\tmaxTokenType = Math.max(maxTokenType, tokenType);\n\t\t\t\tlineNum++;\n\t\t\t} else if (tokenDef.length() > 0) { // ignore blank lines\n\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\tvocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\" bad token def: \" + tokenDef,\n\t\t\t\t\t\tlineNum);\n\t\t\t}\n\t\t\ttokenDef = br.readLine();\n\t\t}\n\t\tbr.close();\n\t} catch (FileNotFoundException fnfe) {\n\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n\t} catch (IOException ioe) {\n\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n\t} catch (Exception e) {\n\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n\t}\n\treturn tokens;\n}\n```"
            ]
        }
    },
    "L8024": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i - 1).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\");\n\t\t\tfor (int j=1; j<=nintervals; j++) {\n\t\t\t\tif ( j>1 ) buf.append(\", \");\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tUUID uuid = ATNSimulator.toUUID(data, p);\n\t\tp += 8;\n\t\tif (!uuid.equals(ATNSimulator.SERIALIZED_UUID)) {\n\t\t\tString reason = String.format(Locale.getDefault(), \"Could not deserialize ATN with UUID %s (expected %s).\", uuid, ATNSimulator.SERIALIZED_UUID);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tif (ruleIndex == Character.MAX_VALUE) {\n\t\t\t\truleIndex = -1;\n\t\t\t}\n\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n\t\t\t\tif (arg2 == Character.MAX_VALUE) {\n\t\t\t\t\targ2 = -1;\n\t\t\t\t}\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\");\n\t\t\tboolean containsEof = data[p++] != 0;\n\t\t\tif (containsEof) {\n\t\t\t\tbuf.append(getTokenName(Token.EOF));\n\t\t\t}\n\n\t\t\tfor (int j=0; j<nintervals; j++) {\n\t\t\t\tif ( containsEof || j>0 ) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t}\n\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    decodeData(data);\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = verifyVersion(data, p);\n    p++; // Increment p after version check\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    appendStateInfo(buf, data, p, nstates);\n    p += nstates * 4; // Increment p based on states processed\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    p += numNonGreedyStates; // Skip non-greedy states\n    int nrules = ATNSimulator.toInt(data[p++]);\n    appendRuleInfo(buf, data, p, nrules);\n    p += nrules * (g.isLexer() ? 3 : 1); // Increment p based on rules processed\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    appendModeInfo(buf, data, p, nmodes);\n    p += nmodes; // Increment p based on modes processed\n    int nsets = ATNSimulator.toInt(data[p++]);\n    appendSetInfo(buf, data, p, nsets);\n    p += nsets * 3; // Increment p based on sets processed\n    int nedges = ATNSimulator.toInt(data[p++]);\n    appendEdgeInfo(buf, data, p, nedges);\n    p += nedges * 6; // Increment p based on edges processed\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    appendDecisionInfo(buf, data, p, ndecisions);\n    return buf.toString();\n}",
                "private void decodeData(char[] data) {\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n}",
                "private int verifyVersion(char[] data, int p) {\n    int version = ATNSimulator.toInt(data[p]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n    return version;\n}",
                "private void appendStateInfo(StringBuilder buf, char[] data, int p, int nstates) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n}",
                "private void appendRuleInfo(StringBuilder buf, char[] data, int p, int nrules) {\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n}",
                "private void appendModeInfo(StringBuilder buf, char[] data, int p, int nmodes) {\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n}",
                "private void appendSetInfo(StringBuilder buf, char[] data, int p, int nsets) {\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n}",
                "private void appendEdgeInfo(StringBuilder buf, char[] data, int p, int nedges) {\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n}",
                "private void appendDecisionInfo(StringBuilder buf, char[] data, int p, int ndecisions) {\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    // don\\'t adjust the first value since that\\'s the version number\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char) (data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    validateVersion(data, p);\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    \n    int nstates = ATNSimulator.toInt(data[p++]);\n    decodeStates(data, buf, nstates, p);\n    \n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    decodeNonGreedyStates(data, p, numNonGreedyStates);\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    decodeRules(data, buf, nrules, p, g.isLexer());\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    decodeModes(data, buf, nmodes, p);\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    decodeSets(data, buf, nsets, p);\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    decodeEdges(data, buf, nedges, p);\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    decodeDecisions(data, buf, ndecisions, p);\n\n    return buf.toString();\n}",
                "private void validateVersion(char[] data, int p) {\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n}",
                "private void decodeStates(char[] data, StringBuilder buf, int nstates, int p) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = getStateArgument(data, p, stype);\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n}",
                "private String getStateArgument(char[] data, int p, int stype) {\n    int argValue = 0;\n    if (stype == ATNState.LOOP_END) {\n        argValue = ATNSimulator.toInt(data[p++]);\n        return \" \" + argValue;\n    } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n        argValue = ATNSimulator.toInt(data[p++]);\n        return \" \" + argValue;\n    }\n    return \"\";\n}",
                "private void decodeNonGreedyStates(char[] data, int p, int numNonGreedyStates) {\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        ATNSimulator.toInt(data[p++]);\n    }\n}",
                "private void decodeRules(char[] data, StringBuilder buf, int nrules, int p, boolean isLexer) {\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"rule \").append(i).append(\":\").append(s);\n        if (isLexer) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\" \").append(arg1).append(\",\").append(arg2);\n        }\n        buf.append(\\'\\\n\\');\n    }\n}",
                "private void decodeModes(char[] data, StringBuilder buf, int nmodes, int p) {\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n}",
                "private void decodeSets(char[] data, StringBuilder buf, int nsets, int p) {\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenRange(data, p));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n}",
                "private String getTokenRange(char[] data, int p) {\n    return getTokenName(ATNSimulator.toInt(data[p])) + \"..\" + getTokenName(ATNSimulator.toInt(data[p + 1]));\n}",
                "private void decodeEdges(char[] data, StringBuilder buf, int nedges, int p) {\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n}",
                "private void decodeDecisions(char[] data, StringBuilder buf, int ndecisions, int p) {\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        ATNSimulator.toInt(data[p++]);\n    }\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L9806": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.target.getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "AfterRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.getTarget().getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.getTarget().getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.getTarget().getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d = createDecl(ast);\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}",
                "private Decl createDecl(GrammarAST ast) {\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        return createSetOrWildcardDecl(ast);\n    } else if (ast.getType() == ANTLRParser.RULE_REF) {\n        return createRuleRefDecl(ast);\n    } else {\n        return createTokenDecl(ast);\n    }\n}",
                "private Decl createSetOrWildcardDecl(GrammarAST ast) {\n    String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n    TokenDecl d = getTokenLabelDecl(implLabel);\n    d.isImplicit = true;\n    return d;\n}",
                "private Decl createRuleRefDecl(GrammarAST ast) {\n    Rule r = g.getRule(ast.getText());\n    String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n    String ctxName = gen.target.getRuleFunctionContextStructName(r);\n    RuleContextDecl d = new RuleContextDecl(this, implLabel, ctxName);\n    d.isImplicit = true;\n    return d;\n}",
                "private Decl createTokenDecl(GrammarAST ast) {\n    String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n    TokenDecl d = getTokenLabelDecl(implLabel);\n    d.isImplicit = true;\n    return d;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    \n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl) d).isImplicit = true;\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    }\n    \n    // Move this part after the declarations\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl) d).isImplicit = true;\n    } else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    }\n    op.getLabels().add(d);\n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl labelDeclaration;\n    \n    if (isSetOrWildcard(ast)) {\n        labelDeclaration = handleSetOrWildcard(ast);\n    } else if (isRuleReference(ast)) {\n        labelDeclaration = handleRuleReference(ast);\n    } else {\n        labelDeclaration = handleTokenLabel(ast);\n    }\n    \n    op.getLabels().add(labelDeclaration);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), labelDeclaration);\n}",
                "private boolean isSetOrWildcard(GrammarAST ast) {\n    return ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD;\n}",
                "private Decl handleSetOrWildcard(GrammarAST ast) {\n    String implicitLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n    TokenDecl tokenDecl = (TokenDecl) getTokenLabelDecl(implicitLabel);\n    tokenDecl.isImplicit = true;\n    return tokenDecl;\n}",
                "private boolean isRuleReference(GrammarAST ast) {\n    return ast.getType() == ANTLRParser.RULE_REF;\n}",
                "private Decl handleRuleReference(GrammarAST ast) {\n    Rule rule = g.getRule(ast.getText());\n    String implicitLabel = gen.target.getImplicitRuleLabel(ast.getText());\n    String contextName = gen.target.getRuleFunctionContextStructName(rule);\n    \n    RuleContextDecl ruleContextDecl = new RuleContextDecl(this, implicitLabel, contextName);\n    ruleContextDecl.isImplicit = true;\n    return ruleContextDecl;\n}",
                "private Decl handleTokenLabel(GrammarAST ast) {\n    String implicitLabel = gen.target.getImplicitTokenLabel(ast.getText());\n    TokenDecl tokenDecl = (TokenDecl) getTokenLabelDecl(implicitLabel);\n    tokenDecl.isImplicit = true;\n    return tokenDecl;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n    \n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl)d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) {\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl)d).isImplicit = true;\n    } else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl)d).isImplicit = true;\n    }\n    \n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L1506": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void addTransition(Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(e);\n\t}",
        "AfterRefact": "public void addTransition(Transition e) {\n\t\taddTransition(transitions.size(), e);\n\t}\n\n\tpublic void addTransition(int index, Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(Locale.getDefault(), \"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(index, e);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = e.isEpsilon();\n    } else if (epsilonOnlyTransitions != e.isEpsilon()) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    if (transitions.isEmpty() || (epsilonOnlyTransitions != isEpsilon)) {\n        if (transitions.isEmpty()) {\n            epsilonOnlyTransitions = isEpsilon;\n        } else {\n            System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n            epsilonOnlyTransitions = false;\n        }\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    if (isInconsistentTransition(e)) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n    \n    transitions.add(e);\n}",
                "private boolean isInconsistentTransition(Transition e) {\n    return !transitions.isEmpty() && epsilonOnlyTransitions != e.isEpsilon();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addTransition(Transition transition) {\n    boolean isEpsilon = transition.isEpsilon();\n\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilon;\n    } else if (epsilonOnlyTransitions != isEpsilon) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(transition);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean newEpsilonOnly = e.isEpsilon();\n    \n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = newEpsilonOnly;\n    } else if (epsilonOnlyTransitions != newEpsilonOnly) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L1991": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions() && \n        (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) {\n                            System.out.println(\"FALLING off token \" +\n                                    recog.getRuleNames()[config.state.ruleIndex] +\n                                    \" record \" + c);\n                        }\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions() && (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Don\\'t pursue but\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions() && \n        (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        logRuleStopState(config);\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            handleEmptyContext(config, configs);\n            return currentAltReachedAcceptState;\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            currentAltReachedAcceptState = processPredictionContexts(config, currentAltReachedAcceptState, configs);\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    return processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n}",
                "private void logRuleStopState(LexerATNConfig config) {\n    if (debug) {\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\\n\", config);\n        }\n    }\n}",
                "private void handleEmptyContext(LexerATNConfig config, ATNConfigSet configs) {\n    if (config.context == null || config.context.isEmpty()) {\n        configs.add(config);\n    } else {\n        configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n    }\n}",
                "private boolean processPredictionContexts(LexerATNConfig config, boolean currentAltReachedAcceptState, ATNConfigSet configs) {\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            PredictionContext newContext = ctx.parent;\n\n            if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                handleEmptyReturnState(config, ctx, configs);\n                continue;\n            }\n\n            ATNState returnState = atn.states.get(ctx.returnState);\n            LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}",
                "private void handleEmptyReturnState(LexerATNConfig config, SingletonPredictionContext ctx, ATNConfigSet configs) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n    }\n    configs.add(c);\n}",
                "private boolean processTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\tif (debug) {\n\t\tSystem.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n\t}\n\n\tif (!(config.state instanceof RuleStopState)) {\n\t\t// optimization\n\t\tif (!config.state.onlyHasEpsilonTransitions()) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif (c != null) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\tif (debug) {\n\t\tif (recog != null) {\n\t\t\tSystem.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t} else {\n\t\t\tSystem.out.format(\"closure at rule stop %s\\\n\", config);\n\t\t}\n\t}\n\n\tif (config.context == null || config.context.hasEmptyPath()) {\n\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\tconfigs.add(config);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\tcurrentAltReachedAcceptState = true;\n\t\t}\n\t}\n\n\tif (config.context != null && !config.context.isEmpty()) {\n\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\tif (!ctx.isEmpty()) {\n\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\tif (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t// we have no context info. Don\\'t pursue but\n\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\tif (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L19910": {
        "RefactMethod": "INTRODUCE SPECIAL CASE",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (isRuleStopState(config)) {\n        currentAltReachedAcceptState = handleRuleStopState(input, config, configs, currentAltReachedAcceptState, speculative);\n    } else {\n        if (!config.state.onlyHasEpsilonTransitions()) {\n            if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n                configs.add(config);\n            }\n        }\n\n        currentAltReachedAcceptState = handleTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    return currentAltReachedAcceptState;\n}",
                "private boolean isRuleStopState(LexerATNConfig config) {\n    return config.state instanceof RuleStopState;\n}",
                "private boolean handleRuleStopState(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        logRuleStopState(config);\n    }\n\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n            return true;\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n        }\n    }\n\n    handleNonEmptyContext(config, configs, currentAltReachedAcceptState);\n    return currentAltReachedAcceptState;\n}",
                "private void logRuleStopState(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\\n\", config);\n    }\n}",
                "private void handleNonEmptyContext(LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState) {\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent;  // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    recordFallbackConfig(config, ctx, configs);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n}",
                "private void recordFallbackConfig(LexerATNConfig config, SingletonPredictionContext ctx, ATNConfigSet configs) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n    }\n    configs.add(c);\n}",
                "private boolean handleTransitions(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (isRuleStopState(config)) {\n        if (debug) {\n            logRuleStop(config);\n        }\n\n        if (isEmptyContext(config.context)) {\n            configs.add(config);\n            return true;\n        } else {\n            addConfigWithEmptyContext(config, configs);\n            currentAltReachedAcceptState = true;\n        }\n\n        processPredictionContexts(input, config, configs, currentAltReachedAcceptState, speculative);\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    return processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n}",
                "private boolean isRuleStopState(LexerATNConfig config) {\n    return config.state instanceof RuleStopState;\n}",
                "private void logRuleStop(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\\n\", config);\n    }\n}",
                "private boolean isEmptyContext(PredictionContext context) {\n    return context == null || context.hasEmptyPath() || context.isEmpty();\n}",
                "private void addConfigWithEmptyContext(LexerATNConfig config, ATNConfigSet configs) {\n    configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n}",
                "private void processPredictionContexts(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    recordConfigAtEnd(configs, config, ctx);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig newConfig = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, newConfig, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n}",
                "private void recordConfigAtEnd(ATNConfigSet configs, LexerATNConfig config, SingletonPredictionContext ctx) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) System.out.println(\"FALLING off token \" +\n            recog.getRuleNames()[config.state.ruleIndex] +\n            \" record \" + c);\n    configs.add(c);\n}",
                "private boolean processTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Don\\'t pursue but\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                          @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                          boolean speculative) {\n    logDebugInfo(config);\n\n    if (config.state instanceof RuleStopState) {\n        handleRuleStopState(config, configs);\n        return currentAltReachedAcceptState;\n    }\n\n    // Optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    currentAltReachedAcceptState = processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n    return currentAltReachedAcceptState;\n}",
                "private void logDebugInfo(LexerATNConfig config) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n}",
                "private void handleRuleStopState(LexerATNConfig config, ATNConfigSet configs) {\n    if (debug) {\n        logRuleStopState(config);\n    }\n\n    if (config.context == null || config.context.hasEmptyPath()) {\n        handleEmptyContext(config, configs);\n    } else {\n        processNonEmptyContexts(config, configs);\n    }\n}",
                "private void logRuleStopState(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\\n\", config);\n    }\n}",
                "private void handleEmptyContext(LexerATNConfig config, ATNConfigSet configs) {\n    if (config.context == null || config.context.isEmpty()) {\n        configs.add(config);\n    } else {\n        configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n    }\n}",
                "private void processNonEmptyContexts(LexerATNConfig config, ATNConfigSet configs) {\n    boolean currentAltReachedAcceptState = false;\n\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            PredictionContext newContext = ctx.parent; // \"pop\" return state\n            currentAltReachedAcceptState = handleReturnState(config, configs, currentAltReachedAcceptState, ctx, newContext);\n        }\n    }\n}",
                "private boolean handleReturnState(LexerATNConfig config, ATNConfigSet configs, \n                                   boolean currentAltReachedAcceptState, SingletonPredictionContext ctx, \n                                   PredictionContext newContext) {\n    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n        logFallingOffToken(config);\n        configs.add(new LexerATNConfig(config, config.state, ctx));\n        return currentAltReachedAcceptState;\n    }\n\n    ATNState returnState = atn.states.get(ctx.returnState);\n    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n    return closure(input, c, configs, currentAltReachedAcceptState, speculative);\n}",
                "private void logFallingOffToken(LexerATNConfig config) {\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex]);\n    }\n}",
                "private boolean processTransitions(CharStream input, LexerATNConfig config, ATNConfigSet configs, \n                                   boolean currentAltReachedAcceptState, boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2113": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (SingletonPredictionContext p : ctx) {\n\t\t\t\t\tATNState returnState = atn.states.get(p.returnState);\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\t\t\t\t\t_LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\t\t\t\t_LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            PredictionContext newContext =\n                    SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext = \n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void lookAhead(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                         @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n                         boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                lookAhead(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            lookAhead(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                lookAhead(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            lookAhead(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState state, @Nullable PredictionContext context,\n                     @NotNull IntervalSet lookaheadSet, @NotNull Set<ATNConfig> busySet,\n                     boolean resolvePreds, boolean includeEOF) {\n    ATNConfig config = new ATNConfig(state, 0, context);\n    if (!busySet.add(config)) return;\n\n    if (state instanceof RuleStopState) {\n        handleRuleStopState(context, lookaheadSet, includeEOF, state);\n        return;\n    }\n\n    processTransitions(state, context, lookaheadSet, busySet, resolvePreds, includeEOF);\n}",
                "private void handleRuleStopState(@Nullable PredictionContext context, \n                                  @NotNull IntervalSet lookaheadSet, \n                                  boolean includeEOF, \n                                  @NotNull ATNState state) {\n    if (context == null) {\n        lookaheadSet.add(Token.EPSILON);\n    } else if (context.isEmpty() && includeEOF) {\n        lookaheadSet.add(Token.EOF);\n    } else if (context != PredictionContext.EMPTY) {\n        for (SingletonPredictionContext predictionContext : context) {\n            ATNState returnState = atn.states.get(predictionContext.returnState);\n            _LOOK(returnState, predictionContext.parent, lookaheadSet, new HashSet<>(), false, includeEOF);\n        }\n    }\n}",
                "private void processTransitions(@NotNull ATNState state, \n                                 @Nullable PredictionContext context, \n                                 @NotNull IntervalSet lookaheadSet, \n                                 @NotNull Set<ATNConfig> busySet, \n                                 boolean resolvePreds, \n                                 boolean includeEOF) {\n    int transitionCount = state.getNumberOfTransitions();\n    for (int i = 0; i < transitionCount; i++) {\n        Transition transition = state.transition(i);\n        if (transition instanceof RuleTransition) {\n            PredictionContext newContext = SingletonPredictionContext.create(context, ((RuleTransition) transition).followState.stateNumber);\n            _LOOK(transition.target, newContext, lookaheadSet, busySet, resolvePreds, includeEOF);\n        } else if (transition instanceof PredicateTransition) {\n            if (resolvePreds) {\n                _LOOK(transition.target, context, lookaheadSet, busySet, resolvePreds, includeEOF);\n            } else {\n                lookaheadSet.add(HIT_PRED);\n            }\n        } else if (transition.isEpsilon()) {\n            _LOOK(transition.target, context, lookaheadSet, busySet, resolvePreds, includeEOF);\n        } else if (transition instanceof WildcardTransition) {\n            lookaheadSet.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = transition.label();\n            if (set != null) {\n                if (transition instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                lookaheadSet.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty()) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2427": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n\n    ATNState p = config.state;\n\n    if (p.onlyHasEpsilonTransitions()) {\n        return;\n    }\n\n    configs.add(config, mergeCache);\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n            continue;\n        }\n\n        if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\tint depth)\n{\n\tATNState p = config.state;\n\n\tif (!p.onlyHasEpsilonTransitions()) {\n\t\tconfigs.add(config, mergeCache);\n\t}\n\n\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\tTransition t = p.transition(i);\n\t\tboolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n\t\tif (c == null) continue;\n\n\t\tint newDepth = depth;\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tassert !fullCtx;\n\t\t\tc.reachesIntoOuterContext++;\n\t\t\tconfigs.dipsIntoOuterContext = true;\n\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\tnewDepth--;\n\t\t\tif (debug) System.out.println(\"dips into outer ctx: \" + c);\n\t\t} else if (t instanceof RuleTransition) {\n\t\t\tif (newDepth >= 0) {\n\t\t\t\tnewDepth++;\n\t\t\t}\n\t\t}\n\n\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState state = config.state;\n\n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean continueCollecting = !(transition instanceof ActionTransition) && collectPredicates;\n        ATNConfig targetConfig = getEpsilonTarget(config, transition, continueCollecting, depth == 0, fullCtx);\n\n        if (targetConfig != null) {\n            int newDepth = depth;\n\n            if (config.state instanceof RuleStopState) {\n                handleRuleStopState(targetConfig, configs, newDepth);\n            } else if (transition instanceof RuleTransition) {\n                newDepth = updateDepthForRuleTransition(newDepth);\n            }\n\n            closureCheckingStopState(targetConfig, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n        }\n    }\n}",
                "private void handleRuleStopState(ATNConfig targetConfig, ATNConfigSet configs, int newDepth) {\n    targetConfig.reachesIntoOuterContext++;\n    configs.dipsIntoOuterContext = true;\n    newDepth--;\n}",
                "private int updateDepthForRuleTransition(int newDepth) {\n    return newDepth >= 0 ? newDepth + 1 : newDepth;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L9795": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.target.getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.target.getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "AfterRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.getTarget().getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.getTarget().getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private void initializeStateAndName(GrammarAST ast) {\n    RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n    stateNumber = ast.atnState.stateNumber;\n    this.name = ast.getText();\n}",
                "private void defineContextDeclarations(ParserFactory factory, GrammarAST labelAST, GrammarAST ast) {\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = generateListLabel(factory, label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n}",
                "private String generateListLabel(ParserFactory factory, String label) {\n    CodeGenerator gen = factory.getGenerator();\n    return gen.target.getListLabel(label);\n}",
                "private void processActionArgs(ParserFactory factory, GrammarAST ast) {\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, factory.getCurrentRuleFunction(), arg.token, arg);\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast, CodeGenerator gen) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        factory.getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        initializeStateAndName(ast);\n    }\n    \n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    defineContextDeclarations(factory, labelAST, ast);\n    processActionArgs(factory, ast);\n    defineImplicitLabelIfNeeded(factory, ast, gen);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif (ast.atnState != null) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\t\t\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tthis.name = ast.getText();\n\t\tctxName = gen.target.getRuleFunctionContextStructName(factory.getGrammar().getRule(name));\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif (labelAST != null) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.target.getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t} else {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif (ast.getChildCount() > 0) {\n\t\t\tActionAST arg = (ActionAST) ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n\t\t\tString label = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void initializeState(GrammarAST ast) {\n    RuleTransition ruleTransition = (RuleTransition) ast.atnState.transition(0);\n    stateNumber = ast.atnState.stateNumber;\n}",
                "private void handleLabelAST(ParserFactory factory, CodeGenerator generator, GrammarAST ast, GrammarAST labelAST, RuleFunction ruleFunction) {\n    String label = labelAST.getText();\n    \n    if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n        factory.defineImplicitLabel(ast, this);\n        String listLabel = generator.target.getListLabel(label);\n        RuleContextListDecl listDecl = new RuleContextListDecl(factory, listLabel, ctxName);\n        ruleFunction.addContextDecl(ast.getAltLabel(), listDecl);\n    } else {\n        RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n        labels.add(contextDecl);\n        ruleFunction.addContextDecl(ast.getAltLabel(), contextDecl);\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast, CodeGenerator generator, RuleFunction ruleFunction) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = generator.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n        labels.add(contextDecl);\n        ruleFunction.addContextDecl(ast.getAltLabel(), contextDecl);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    \n    if (ast.atnState != null) {\n        initializeState(ast);\n    }\n\n    this.name = ast.getText();\n    CodeGenerator generator = factory.getGenerator();\n    Rule rule = factory.getGrammar().getRule(name);\n    ctxName = generator.target.getRuleFunctionContextStructName(rule);\n\n    RuleFunction ruleFunction = factory.getCurrentRuleFunction();\n    if (labelAST != null) {\n        handleLabelAST(factory, generator, ast, labelAST, ruleFunction);\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST actionAST = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, ruleFunction, actionAST.token, actionAST);\n    }\n\n    defineImplicitLabelIfNeeded(factory, ast, generator, ruleFunction);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    \n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    } else if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
            ]
        }
    },
    "L9861": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.target.getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "AfterRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.getTarget().getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "ZeroShotCode": {
            "methods": [
                "private String extractGrammarFileName(Grammar g) {\n    return new File(g.fileName).getName();\n}",
                "private String[] processTokenNames(Grammar g) {\n    String[] tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        tokenNames[i] = formatTokenName(tokenNames[i], gen);\n    }\n    return tokenNames;\n}",
                "private String formatTokenName(String tokenName, CodeGenerator gen) {\n    if (tokenName.charAt(0) == \\'\\\\\\'\\') {\n        boolean addQuotes = false;\n        tokenName = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, addQuotes);\n        return \"\\\\\"\\'\" + tokenName + \"\\'\\\\\"\";\n    } else {\n        return gen.target.getTargetStringLiteralFromString(tokenName, true);\n    }\n}",
                "private ActionText determineSuperClass(Grammar g) {\n    String superClassOption = g.getOptionString(\"superClass\");\n    return (superClassOption != null)\n        ? new ActionText(null, superClassOption)\n        : new DefaultLexerSuperClass();\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; \n    Grammar g = factory.getGrammar();\n    this.grammarFileName = extractGrammarFileName(g);\n    this.name = g.getRecognizerName();\n    this.tokens = createTokens(g);\n    LexerGrammar lg = (LexerGrammar) g;\n    this.atn = new SerializedATN(factory, lg.atn);\n    this.modes = lg.modes.keySet();\n    this.tokenNames = processTokenNames(g);\n    this.ruleNames = g.rules.keySet();\n    this.superClass = determineSuperClass(g);\n}\n\n",
                "\n\nprivate LinkedHashMap<String, Integer> createTokens(Grammar g) {\n    LinkedHashMap<String, Integer> tokens = new LinkedHashMap<>();\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n    return tokens;\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    String grammarFileName = new File(g.fileName).getName();\n    String name = g.getRecognizerName();\n    LinkedHashMap<String, Integer> tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    SerializedATN atn = new SerializedATN(factory, lg.atn);\n    Set<String> modes = lg.modes.keySet();\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    String[] tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n    Set<String> ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private String extractFileName(Grammar grammar) {\n        return new File(grammar.fileName).getName();\n    }",
                "private String[] initializeTokenNames(Grammar grammar) {\n        String[] names = grammar.getTokenDisplayNames();\n        CodeGenerator generator = factory.getGenerator();\n        \n        for (int i = 0; i < names.length; i++) {\n            if (names[i] != null) {\n                names[i] = formatTokenName(names[i], generator);\n            }\n        }\n        return names;\n    }",
                "private String formatTokenName(String name, CodeGenerator generator) {\n        boolean addQuotes = false;\n        if (name.charAt(0) == \\'\\\\\\'\\') {\n            name = generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator, name, addQuotes);\n            return \"\\\\\"\\'\" + name + \"\\'\\\\\"\";\n        } \n        return generator.target.getTargetStringLiteralFromString(name, true);\n    }",
                "private ActionText getSuperClass(Grammar grammar) {\n        String superClassOption = grammar.getOptionString(\"superClass\");\n        return (superClassOption != null) ? new ActionText(null, superClassOption) : new DefaultLexerSuperClass();\n    }"
            ],
            "classes": [
                "class Lexer {\n    private final OutputModelFactory factory;\n    private final LexerFile file;\n    private final String grammarFileName;\n    private final String name;\n    private final Map<String, Integer> tokens;\n    private final Set<String> modes;\n    private final SerializedATN atn;\n    private final String[] tokenNames;\n    private final Set<String> ruleNames;\n    private final ActionText superClass;\n\n    public Lexer(OutputModelFactory factory, LexerFile file) {\n        this.factory = factory;\n        this.file = file;\n        Grammar grammar = factory.getGrammar();\n        \n        this.grammarFileName = extractFileName(grammar);\n        this.name = grammar.getRecognizerName();\n        this.tokens = initializeTokens(grammar);\n        this.modes = ((LexerGrammar) grammar).modes.keySet();\n        this.tokenNames = initializeTokenNames(grammar);\n        this.ruleNames = grammar.rules.keySet();\n        this.superClass = getSuperClass(grammar);\n        this.atn = new SerializedATN(factory, ((LexerGrammar) grammar).atn);\n    }\n\n    private String extractFileName(Grammar grammar) {\n        return new File(grammar.fileName).getName();\n    }\n\n    private Map<String, Integer> initializeTokens(Grammar grammar) {\n        Map<String, Integer> result = new LinkedHashMap<>();\n        for (Map.Entry<String, Integer> entry : grammar.tokenNameToTypeMap.entrySet()) {\n            Integer tokenType = entry.getValue();\n            if (tokenType > 0) {\n                result.put(entry.getKey(), tokenType);\n            }\n        }\n        return result;\n    }\n\n    private String[] initializeTokenNames(Grammar grammar) {\n        String[] names = grammar.getTokenDisplayNames();\n        CodeGenerator generator = factory.getGenerator();\n        \n        for (int i = 0; i < names.length; i++) {\n            if (names[i] != null) {\n                names[i] = formatTokenName(names[i], generator);\n            }\n        }\n        return names;\n    }\n\n    private String formatTokenName(String name, CodeGenerator generator) {\n        boolean addQuotes = false;\n        if (name.charAt(0) == \\'\\\\\\'\\') {\n            name = generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator, name, addQuotes);\n            return \"\\\\\"\\'\" + name + \"\\'\\\\\"\";\n        } \n        return generator.target.getTargetStringLiteralFromString(name, true);\n    }\n\n    private ActionText getSuperClass(Grammar grammar) {\n        String superClassOption = grammar.getOptionString(\"superClass\");\n        return (superClassOption != null) ? new ActionText(null, superClassOption) : new DefaultLexerSuperClass();\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        boolean addQuotes = tokenNames[i].charAt(0) == \\'\\\\\\'\\';\n        tokenNames[i] = addQuotes \n            ? \"\\\\\"\\'\\\\\"\" + gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], false) + \"\\\\\"\\'\\\\\"\"\n            : gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n    }\n    \n    ruleNames = g.rules.keySet();\n\n    superClass = g.getOptionString(\"superClass\") != null \n        ? new ActionText(null, g.getOptionString(\"superClass\")) \n        : new DefaultLexerSuperClass();\n}\n```"
            ]
        }
    },
    "L2093": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\tATNState s;\n\t\tswitch (type) {\n\t\t\tcase ATNState.INVALID_TYPE: return null;\n\t\t\tcase ATNState.BASIC : s = new BasicState(); break;\n\t\t\tcase ATNState.RULE_START : s = new RuleStartState(); break;\n\t\t\tcase ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n\t\t\tcase ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n\t\t\tcase ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n\t\t\tcase ATNState.TOKEN_START : s = new TokensStartState(); break;\n\t\t\tcase ATNState.RULE_STOP : s = new RuleStopState(); break;\n\t\t\tcase ATNState.BLOCK_END : s = new BlockEndState(); break;\n\t\t\tcase ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n\t\t\tcase ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n\t\t\tcase ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n\t\t\tcase ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n\t\t\t\tString message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\n\t\ts.ruleIndex = ruleIndex;\n\t\treturn s;\n\t}",
        "AfterRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\treturn new ATNDeserializer().stateFactory(type, ruleIndex);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    if (type == ATNState.INVALID_TYPE) return null;\n\n    ATNState s = switch (type) {\n        case ATNState.BASIC -> new BasicState();\n        case ATNState.RULE_START -> new RuleStartState();\n        case ATNState.BLOCK_START -> new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START -> new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START -> new StarBlockStartState();\n        case ATNState.TOKEN_START -> new TokensStartState();\n        case ATNState.RULE_STOP -> new RuleStopState();\n        case ATNState.BLOCK_END -> new BlockEndState();\n        case ATNState.STAR_LOOP_BACK -> new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY -> new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK -> new PlusLoopbackState();\n        case ATNState.LOOP_END -> new LoopEndState();\n        default -> throw new IllegalArgumentException(String.format(Locale.getDefault(),\n                \"The specified state type %d is not valid.\", type));\n    };\n\n    s.ruleIndex = ruleIndex;\n    return s;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC : s = new BasicState(); break;\n            case ATNState.RULE_START : s = new RuleStartState(); break;\n            case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START : s = new TokensStartState(); break;\n            case ATNState.RULE_STOP : s = new RuleStopState(); break;\n            case ATNState.BLOCK_END : s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }",
                "static ATNState stateFactory(int type, int ruleIndex) {\n    return new StateFactoryCommand(type, ruleIndex).execute();\n}"
            ],
            "classes": [
                "class StateFactoryCommand {\n    private int type;\n    private int ruleIndex;\n\n    public StateFactoryCommand(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC : s = new BasicState(); break;\n            case ATNState.RULE_START : s = new RuleStartState(); break;\n            case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START : s = new TokensStartState(); break;\n            case ATNState.RULE_STOP : s = new RuleStopState(); break;\n            case ATNState.BLOCK_END : s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Forwarding function\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }"
            ],
            "classes": [
                "class ATNStateFactory {\n    private int type;\n    private int ruleIndex;\n\n    public ATNStateFactory(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState state = createState(type);\n    if (state != null) {\n        state.ruleIndex = ruleIndex;\n    }\n    return state;\n}",
                "static ATNState createState(int type) {\n    switch (type) {\n        case ATNState.INVALID_TYPE: return null;\n        case ATNState.BASIC: return new BasicState();\n        case ATNState.RULE_START: return new RuleStartState();\n        case ATNState.BLOCK_START: return new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n        case ATNState.TOKEN_START: return new TokensStartState();\n        case ATNState.RULE_STOP: return new RuleStopState();\n        case ATNState.BLOCK_END: return new BlockEndState();\n        case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n        case ATNState.LOOP_END: return new LoopEndState();\n        default:\n            String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n            throw new IllegalArgumentException(message);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState s = StateFactory.createState(type);\n    if (s != null) {\n        s.ruleIndex = ruleIndex;\n    }\n    return s;\n}",
                "static ATNState createState(int type) {\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: return new BasicState();\n            case ATNState.RULE_START: return new RuleStartState();\n            case ATNState.BLOCK_START: return new BasicBlockStartState();\n            case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n            case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n            case ATNState.TOKEN_START: return new TokensStartState();\n            case ATNState.RULE_STOP: return new RuleStopState();\n            case ATNState.BLOCK_END: return new BlockEndState();\n            case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n            case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n            case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n            case ATNState.LOOP_END: return new LoopEndState();\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n    }"
            ],
            "classes": [
                "class StateFactory {\n    static ATNState createState(int type) {\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: return new BasicState();\n            case ATNState.RULE_START: return new RuleStartState();\n            case ATNState.BLOCK_START: return new BasicBlockStartState();\n            case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n            case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n            case ATNState.TOKEN_START: return new TokensStartState();\n            case ATNState.RULE_STOP: return new RuleStopState();\n            case ATNState.BLOCK_END: return new BlockEndState();\n            case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n            case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n            case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n            case ATNState.LOOP_END: return new LoopEndState();\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\nprivate static ",
                "\n```"
            ]
        }
    },
    "L2083": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\tATNState target = atn.states.get(trg);\n\t\tswitch (type) {\n\t\t\tcase Transition.EPSILON : return new EpsilonTransition(target);\n\t\t\tcase Transition.RANGE :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase Transition.RULE :\n\t\t\t\tRuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n\t\t\t\treturn rt;\n\t\t\tcase Transition.PREDICATE :\n\t\t\t\tPredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn pt;\n\t\t\tcase Transition.ATOM :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase Transition.ACTION :\n\t\t\t\tActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn a;\n\t\t\tcase Transition.SET : return new SetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.WILDCARD : return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"The specified transition type is not valid.\");\n\t}",
        "AfterRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\treturn new ATNDeserializer().edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    Transition transition;\n\n    switch (type) {\n        case Transition.EPSILON:\n            transition = new EpsilonTransition(target);\n            break;\n        case Transition.RANGE:\n            transition = (arg3 != 0) ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n            break;\n        case Transition.RULE:\n            transition = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n            break;\n        case Transition.PREDICATE:\n            transition = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.ATOM:\n            transition = (arg3 != 0) ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n            break;\n        case Transition.ACTION:\n            transition = new ActionTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.SET:\n            transition = new SetTransition(target, sets.get(arg1));\n            break;\n        case Transition.NOT_SET:\n            transition = new NotSetTransition(target, sets.get(arg1));\n            break;\n        case Transition.WILDCARD:\n            transition = new WildcardTransition(target);\n            break;\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n\n    return transition;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }",
                "static Transition edgeFactory(@NotNull ATN atn,\n                                          int type, int src, int trg,\n                                          int arg1, int arg2, int arg3,\n                                          List<IntervalSet> sets) {\n        return new EdgeFactoryCommand(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n    }"
            ],
            "classes": [
                "class EdgeFactoryCommand {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public EdgeFactoryCommand(@NotNull ATN atn,\n                               int type, int src, int trg,\n                               int arg1, int arg2, int arg3,\n                               List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n\n    public static Transition edgeFactory(@NotNull ATN atn,\n                                          int type, int src, int trg,\n                                          int arg1, int arg2, int arg3,\n                                          List<IntervalSet> sets) {\n        return new EdgeFactoryCommand(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    return new TransitionFactory(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n}",
                "public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON:\n                return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET:\n                return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET:\n                return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD:\n                return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }"
            ],
            "classes": [
                "class TransitionFactory {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public TransitionFactory(@NotNull ATN atn,\n                             int type, int src, int trg,\n                             int arg1, int arg2, int arg3,\n                             List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON:\n                return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET:\n                return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET:\n                return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD:\n                return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    \n    switch (type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 != 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.ATOM:\n            return arg3 != 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.SET:\n            return new SetTransition(target, sets.get(arg1));\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets.get(arg1));\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, \n                                      int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    TransitionFactory factory = new TransitionFactory(target, arg1, arg2, arg3, sets);\n    return factory.createTransition(type);\n}",
                "public Transition createTransition(int type) {\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n            default: throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n        }\n    }"
            ],
            "classes": [
                "class TransitionFactory {\n    private final ATNState target;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public TransitionFactory(ATNState target, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.target = target;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition createTransition(int type) {\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n            default: throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n        }\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L2079": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\tlong leastSigBits = toLong(data, offset);\n\t\tlong mostSigBits = toLong(data, offset + 4);\n\t\treturn new UUID(mostSigBits, leastSigBits);\n\t}",
        "AfterRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\treturn ATNDeserializer.toUUID(data, offset);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    long leastSigBits = toLong(data, offset);\n    long mostSigBits = toLong(data, offset + 4);\n    return createUUID(mostSigBits, leastSigBits);\n}",
                "static UUID createUUID(long mostSigBits, long leastSigBits) {\n    return new UUID(mostSigBits, leastSigBits);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }",
                "private long toLong(char[] data, int offset) {\n        // Implementation of the toLong method\n    }"
            ],
            "classes": [
                "class ToUUIDCommand {\n    private char[] data;\n    private int offset;\n\n    public ToUUIDCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implementation of the toLong method\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public UUID execute() {\n        this.leastSigBits = toLong(data, offset);\n        this.mostSigBits = toLong(data, offset + 4);\n        this.result = new UUID(mostSigBits, leastSigBits);\n        return result;\n    }",
                "private long toLong(char[] data, int offset) {\n        // Implement the logic to convert the character array to long\n        // ...\n    }"
            ],
            "classes": [
                "class UUIDConverter {\n    private char[] data;\n    private int offset;\n    private long leastSigBits;\n    private long mostSigBits;\n    private UUID result;\n\n    public UUIDConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public UUID execute() {\n        this.leastSigBits = toLong(data, offset);\n        this.mostSigBits = toLong(data, offset + 4);\n        this.result = new UUID(mostSigBits, leastSigBits);\n        return result;\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implement the logic to convert the character array to long\n        // ...\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    long leastSigBits = toLong(data, offset);\n    long mostSigBits = toLong(data, offset + Long.BYTES);\n    return new UUID(mostSigBits, leastSigBits);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    return UUIDFactory.toUUID(data, offset);\n}",
                "static UUID toUUID(char[] data, int offset) {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }"
            ],
            "classes": [
                "class UUIDFactory {\n    public static UUID toUUID(char[] data, int offset) {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\npublic ",
                "\n```"
            ]
        }
    },
    "L2075": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static long toLong(char[] data, int offset) {\n\t\tlong lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n\t\treturn lowOrder | ((long)toInt32(data, offset + 2) << 32);\n\t}",
        "AfterRefact": "public static long toLong(char[] data, int offset) {\n\t\treturn ATNDeserializer.toLong(data, offset);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    return (toInt32(data, offset) & 0x00000000FFFFFFFFL) | \n           ((long) toInt32(data, offset + 2) << 32);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }",
                "private int toInt32(char[] data, int offset) {\n        // Assume this method converts a portion of the char array to an int\n        // The implementation of this method is not provided in the original code\n        return 0; // Replace with actual implementation\n    }",
                "static long toLong(char[] data, int offset) {\n    return new ToLongCommand(data, offset).execute();\n}"
            ],
            "classes": [
                "class ToLongCommand {\n    private char[] data;\n    private int offset;\n\n    public ToLongCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Assume this method converts a portion of the char array to an int\n        // The implementation of this method is not provided in the original code\n        return 0; // Replace with actual implementation\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Forwarding function\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public long execute() {\n        this.result = 0;\n        this.result = toLong();\n        return this.result;\n    }",
                "private long toLong() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }",
                "private int toInt32(char[] data, int offset) {\n        // Implementation of toInt32 method goes here\n        return 0; // placeholder return for compilation; replace with actual implementation\n    }"
            ],
            "classes": [
                "class LongConverter {\n    private char[] data;\n    private int offset;\n    private long result;\n    \n    public LongConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    \n    public long execute() {\n        this.result = 0;\n        this.result = toLong();\n        return this.result;\n    }\n    \n    private long toLong() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Implementation of toInt32 method goes here\n        return 0; // placeholder return for compilation; replace with actual implementation\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    int lowOrder = toInt32(data, offset) & 0xFFFFFFFF;\n    int highOrder = toInt32(data, offset + 2);\n    return ((long) highOrder << 32) | (lowOrder & 0xFFFFFFFFL);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    return toLongMethod(data, offset);\n}",
                "static long toLongMethod(char[] data, int offset) {\n    long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n    return lowOrder | ((long)toInt32(data, offset + 2) << 32);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        }
    },
    "L1276": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\t// share same graph if both same\n\t\tif ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "AfterRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\tassert a!=null && b!=null; // must be empty context, never null\n\n\t\t// share same graph if both same\n\t\tif ( a==b || a.equals(b) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\t\t\n\t\tif ((a == null && b == null) || a == b || (a != null && a.equals(b))) {\n\t\t\treturn a;\n\t\t}\n\n\t\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext) a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext) b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\tif (rootIsWildcard) {\n\t\t\tif (a instanceof EmptyPredictionContext) return a;\n\t\t\tif (b instanceof EmptyPredictionContext) return b;\n\t\t}\n\n\t\ta = replaceIfSingleton(a);\n\t\tb = replaceIfSingleton(b);\n\t\t\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
                "static PredictionContext replaceIfSingleton(PredictionContext context) {\n\t\tif (context instanceof SingletonPredictionContext) {\n\t\t\treturn new ArrayPredictionContext((SingletonPredictionContext) context);\n\t\t}\n\t\treturn context;\n\t}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\n\tprivate ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }"
            ],
            "classes": [
                "class MergePredictionContextCommand {\n    private final PredictionContext a;\n    private final PredictionContext b;\n    private final boolean rootIsWildcard;\n    private final DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n\n    public MergePredictionContextCommand(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static PredictionContext merge(PredictionContext a, PredictionContext b,\n                                       boolean rootIsWildcard,\n                                       DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    return new Merger(a, b, rootIsWildcard, mergeCache).execute();\n}",
                "public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a,\n                                   (SingletonPredictionContext) b,\n                                   rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                           rootIsWildcard, mergeCache);\n    }"
            ],
            "classes": [
                "class Merger {\n    private PredictionContext a;\n    private PredictionContext b;\n    private boolean rootIsWildcard;\n    private DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n\n    public Merger(PredictionContext a, PredictionContext b, boolean rootIsWildcard,\n                  DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a,\n                                   (SingletonPredictionContext) b,\n                                   rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                           rootIsWildcard, mergeCache);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static PredictionContext merge(\n    PredictionContext a, PredictionContext b,\n    boolean rootIsWildcard,\n    DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\n    if (areBothNullOrEqual(a, b)) {\n        return a;\n    }\n\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n    }\n\n    if (rootIsWildcard) {\n        if (isEmptyContext(a) || isEmptyContext(b)) {\n            return a != null ? a : b;\n        }\n    }\n\n    a = convertToArrayIfSingleton(a);\n    b = convertToArrayIfSingleton(b);\n\n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n}",
                "static boolean areBothNullOrEqual(PredictionContext a, PredictionContext b) {\n    return (a == null && b == null) || a == b || (a != null && a.equals(b));\n}",
                "static boolean isEmptyContext(PredictionContext context) {\n    return context instanceof EmptyPredictionContext;\n}",
                "static PredictionContext convertToArrayIfSingleton(PredictionContext context) {\n    return context instanceof SingletonPredictionContext\n        ? new ArrayPredictionContext((SingletonPredictionContext) context) \n        : context;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\t\n\tif ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons((SingletonPredictionContext) a,\n\t\t\t\t\t\t\t   (SingletonPredictionContext) b,\n\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}\n\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) return a;\n\t\tif (b instanceof EmptyPredictionContext) return b;\n\t}\n\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext((SingletonPredictionContext) a);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext((SingletonPredictionContext) b);\n\t}\n\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t   rootIsWildcard, mergeCache);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        }
    },
    "L7856": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n        boolean useIdentity = true; // compare node identity\n\t\tthis.treeLayout =\n\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(tree),\n\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n                                 useIdentity);\n\t\tupdatePreferredSize();\n\t\tsetFont(font);\n\t}",
        "AfterRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetRuleNames(ruleNames);\n\t\tif ( tree!=null ) {\n\t\t\tsetTree(tree);\n\t\t}\n\t\tsetFont(font);\n\t}\n\npublic void setTree(Tree root) {\n\t\tif ( root!=null ) {\n\t\t\tboolean useIdentity = true; // compare node identity\n\t\t\tthis.treeLayout =\n\t\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(root),\n\t\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n\t\t\t\t\t\t\t\t\t useIdentity);\n\t\t\t// Let the UI display this new AST.\n\t\t\tupdatePreferredSize();\n\t\t}\n\t\telse {\n\t\t\tthis.treeLayout = null;\n\t\t\trepaint();\n\t\t}\n\t}\npublic void setRuleNames(List<String> ruleNames) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private DefaultTreeTextProvider createTreeTextProvider(@Nullable List<String> ruleNames) {\n    return new DefaultTreeTextProvider(ruleNames);\n}",
                "private TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(new TreeLayoutAdaptor(tree),\n                                 new TreeViewer.VariableExtentProvide(this),\n                                 new DefaultConfiguration<Tree>(gapBetweenLevels,\n                                                                 gapBetweenNodes),\n                                 useIdentity);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(createTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree, boolean useIdentity) {\n    return new TreeLayout<>(\n        new TreeLayoutAdaptor(tree),\n        new VariableExtentProvider(),\n        new DefaultConfiguration<>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [
                "class VariableExtentProvider implements TreeViewer.VariableExtentProvide {\n    // Implementation details for VariableExtentProvide if necessary\n}"
            ],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    \n    boolean useIdentity = true; // Compare node identity\n    this.treeLayout = createTreeLayout(tree, useIdentity);\n    \n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private void initializeTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    initializeTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        }
    },
    "L3524": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tsuper(ruleStart);\n\n\t\tthis.ruleIndex = ruleIndex;\n\n\t\tthis.followState = followState;\n\n\t}",
        "AfterRefact": "public RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tthis(ruleStart, ruleIndex, 0, followState);\n\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public int getRuleIndex() {\n        return ruleIndex;\n    }",
                "public ATNState getFollowState() {\n        return followState;\n    }"
            ],
            "classes": [
                "class TransitionData {\n    private final int ruleIndex;\n    private final ATNState followState;\n\n    public TransitionData(int ruleIndex, @NotNull ATNState followState) {\n        this.ruleIndex = ruleIndex;\n        this.followState = followState;\n    }\n\n    public int getRuleIndex() {\n        return ruleIndex;\n    }\n\n    public ATNState getFollowState() {\n        return followState;\n    }\n}"
            ],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n\npublic RuleTransition(@NotNull RuleStartState ruleStart, TransitionData transitionData) {\n    this(ruleStart, transitionData.getRuleIndex(), transitionData.getFollowState());\n}\n\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n                      int ruleIndex,\n\n                      @NotNull ATNState followState)\n\n{\n\n    super(ruleStart);\n\n    final int initialRuleIndex = ruleIndex;\n\n    this.ruleIndex = initialRuleIndex;\n\n    this.followState = followState;\n\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n\nprivate int ruleIndex;\nprivate ATNState followState;\n```"
            ]
        }
    },
    "L2447": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    int line = input.getLine();\n    int charPos = input.getCharPositionInLine();\n\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // assume logic for index, line, and charPos handling is done here\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void acceptAction(@NotNull CharStream input, int ruleIndex, int actionIndex,\n                            int index, int line, int charPos)\n{\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n\n    if (isActionValid(actionIndex)) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    processInput(input, index, line, charPos);\n}",
                "private void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", getRuleName(ruleIndex), actionIndex);\n    }\n}",
                "private String getRuleName(int ruleIndex) {\n    return recog != null ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n}",
                "private boolean isActionValid(int actionIndex) {\n    return actionIndex >= 0 && recog != null;\n}",
                "private void processInput(CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    \n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L24470": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    accept(input, ruleIndex, actionIndex, input.index(), input.getLine(), input.getCharPositionInLine());\n}",
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    \n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void acceptInput(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n{\n\tif ( debug ) {\n\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t}\n\n\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t// seek to after last char in token\n\tinput.seek(index);\n\tthis.line = line;\n\tthis.charPositionInLine = charPos;\n\tif (input.LA(1) != IntStream.EOF) {\n\t\tconsume(input);\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n\n    if (isValidAction(actionIndex)) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    updateInputPosition(input, index, line, charPos);\n}",
                "private void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        String ruleName = (recog != null) ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", ruleName, actionIndex);\n    }\n}",
                "private boolean isValidAction(int actionIndex) {\n    return actionIndex >= 0 && recog != null;\n}",
                "private void updateInputPosition(CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n    \n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n    \n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2288": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t  DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t  @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t  @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t  ParserRuleContext outerContext,\n\t\t\t\t\t\t\t\t\t  int SLL_min_alt) // todo: is this in D as min ambig alts?\n\t{\n\t\t// caller must have write lock on dfa\n\t\tretry_with_context++;\n\t\treportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\tretry_with_context_indicates_no_conflict++;\n\t\t\treportContextSensitivity(dfa, reach, startIndex, input.index());\n\t\t\tif ( predictedAlt == SLL_min_alt ) {\n\t\t\t\tretry_with_context_predicts_same_alt++;\n\t\t\t}\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\tif ( foundExactAmbig ) {\n\t\t\treportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n\t\t}\n\n\t\treturn predictedAlt;\n\t}",
        "AfterRefact": "protected int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t\t DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t\t @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t\t ParserRuleContext outerContext)\n\t{\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\treportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index());\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\treportAmbiguity(dfa, D, startIndex, input.index(), foundExactAmbig, null, reach);\n\n\t\treturn predictedAlt;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex, \n                                   ParserRuleContext outerContext, \n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets + \n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) + \n                               \", resolvesToJustOneViableAlt=\" + \n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        \n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) && \n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    \n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public int executeFullContextWithDFA(DFA dfa,\n                                       DFAState D, // how far we got before failing over\n                                       @NotNull ATNConfigSet s0,\n                                       @NotNull TokenStream input, int startIndex,\n                                       ParserRuleContext outerContext,\n                                       int SLL_min_alt) // todo: is this in D as min ambig alts?\n{\n    // caller must have write lock on dfa\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"executeFullContextWithDFA \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    \n    while (true) { // while more work\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D, \n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt = ATN.INVALID_ALT_NUMBER;\n\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) && \n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), \n                        getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2588": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "protected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n\t\treturn 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n\t}",
        "AfterRefact": "protected static int calculateHashCode(PredictionContext parent, int returnState) {\n\t\tint hash = MurmurHash.initialize(INITIAL_HASH);\n\t\thash = MurmurHash.update(hash, parent);\n\t\thash = MurmurHash.update(hash, returnState);\n\t\thash = MurmurHash.finish(hash, 2);\n\t\treturn hash;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return 175 + 5 * parentHashCode + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }",
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    CalculateHashCodeCommand command = new CalculateHashCodeCommand(parentHashCode, returnStateHashCode);\n    return command.execute();\n}"
            ],
            "classes": [
                "class CalculateHashCodeCommand {\n    private int parentHashCode;\n    private int returnStateHashCode;\n\n    public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Original function retained as a forwarding function\nprotected ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public int execute() {\n        this.result = 5 * 5 * 7 + 5 * this.parentHashCode + this.returnStateHashCode;\n        return this.result;\n    }",
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n        return new HashCodeCalculator(parentHashCode, returnStateHashCode).execute();\n    }"
            ],
            "classes": [
                "class HashCodeCalculator {\n    private int parentHashCode;\n    private int returnStateHashCode;\n    private int result;\n\n    public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        this.result = 5 * 5 * 7 + 5 * this.parentHashCode + this.returnStateHashCode;\n        return this.result;\n    }\n\n    public static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n        return new HashCodeCalculator(parentHashCode, returnStateHashCode).execute();\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    final int multiplier1 = 25; // 5 * 5\n    final int multiplier2 = 5;\n    final int baseValue = 7;\n\n    return multiplier1 + (multiplier2 * parentHashCode) + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return new HashCodeCalculator(parentHashCode, returnStateHashCode).compute();\n}",
                "public int compute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }"
            ],
            "classes": [
                "class HashCodeCalculator {\n    private final int parentHashCode;\n    private final int returnStateHashCode;\n\n    public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int compute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}"
            ],
            "others": [
                "```java\nprotected ",
                "\n\nprivate static ",
                "\n```"
            ]
        }
    },
    "L3072": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "AfterRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer,\n                                      DFA dfa,\n                                      int startIndex,\n                                      int stopIndex,\n                                      ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5418": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t\t_ctx.altNum = altNum;\n\t}",
        "AfterRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    updateContext(localctx);\n    setAltNum(localctx, altNum);\n}",
                "private void updateContext(ParserRuleContext localctx) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n}",
                "private void setAltNum(ParserRuleContext localctx, int altNum) {\n    localctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    ParserRuleContext updatedCtx = localctx;\n    updatedCtx.altNum = altNum;\n    _ctx = updatedCtx;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    ParserRuleContext currentContext = localctx;\n    int currentAltNum = altNum;\n    _ctx = currentContext;\n    _ctx.altNum = currentAltNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3446": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "AfterRefact": "protected Token singleTokenDeletion(@NotNull Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\treportMatch(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}\npublic void reportMatch(Parser recognizer) {\n\t\tendErrorCondition(recognizer);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    return performTokenDeletion(recognizer);\n}",
                "private Token performTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // simply delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        Token matchedSymbol = deleteExtraToken(recognizer);\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private Token deleteExtraToken(Parser recognizer) {\n    recognizer.consume(); // simply delete extra token\n    return recognizer.getCurrentToken(); // return the token we're actually matching\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        Token matchedSymbol = recoverFromMismatchedToken(recognizer);\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private Token recoverFromMismatchedToken(Parser recognizer) {\n    recognizer.consume(); // simply delete extra token\n    return recognizer.getCurrentToken();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    \n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // Delete extra token\n        \n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); // Current token is correct\n        return matchedSymbol;\n    }\n    \n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleUnwantedToken(recognizer);\n        recognizer.consume(); // simply delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private void handleUnwantedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    /*\n    System.err.println(\"recoverFromMismatchedToken deleting \"+\n                       ((TokenStream)recognizer.getInputStream()).LT(1)+\n                       \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n                       \" is what we want\");\n    */\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L3949": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public TheoryAnchor(FrameworkMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}",
        "AfterRefact": "public TheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tfTestMethod= method;\n            fTestClass= testClass;\n\t\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod testMethod) {\n    fTestMethod = testMethod;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod fTestMethod) {\n\t\t\tthis.fTestMethod = fTestMethod;\n\t\t}\n```"
            ]
        }
    },
    "L8052": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public StubbedTheoryAnchor(FrameworkMethod method) {\n\t\t\tsuper(method);\n\t\t}",
        "AfterRefact": "public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tsuper(method, testClass);\n\t\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, String additionalParameter) {\n    super(method);\n    // Use additionalParameter as needed\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, String additionalParameter) {\n    super(method);\n    // Additional logic using additionalParameter can be added here\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic CircumstanceTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, SomeType addedParam) {\n    super(method);\n}\n```"
            ]
        }
    },
    "L4884": {
        "RefactMethod": "INLINE VARIABLE",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(each);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5882": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        runTestMethod(method, eachNotifier);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}",
                "private void runTestMethod(FrameworkMethod method, EachTestNotifier eachNotifier) throws Throwable {\n    methodBlock(method).evaluate();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeMethodBlock(method);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private void executeMethodBlock(FrameworkMethod method) throws Throwable {\n    methodBlock(method).evaluate();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L5880": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\n\n\tprivate void runIgnored(EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestIgnored();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeMethodBlock(method, eachNotifier);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}",
                "private void executeMethodBlock(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        runTestMethod(method);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private void runTestMethod(FrameworkMethod method) throws Throwable {\n    methodBlock(method).evaluate();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n\n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L4889": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}\n\n\tprivate void addMultipleFailureException(MultipleFailureException mfe) {\n\t\tfor (Throwable each : mfe.getFailures())\n\t\t\taddFailure(each);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n    } else {\n        fireTestFailure(targetException);\n    }\n}",
                "private void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}",
                "private void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}",
                "private void handleMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n        return;\n    }\n    fireTestFailure(targetException);\n}",
                "private void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}",
                "private void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException mfe) {\n        for (Throwable failure : mfe.getFailures()) {\n            addFailure(failure);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}",
                "private void handleMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L7126": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t}",
        "AfterRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t\tassertEquals(2, result.getRunCount());\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertCount(result, 1);\n}",
                "private void assertCount(Result result, int expectedCount) {\n    assertEquals(expectedCount, result.getRunCount());\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    // Assert that the category filter is expected to be valid\n    assert include != null : \"Expected a valid CategoryFilter\";\n    \n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    \n    // Assert that the result of the test run should be successful\n    assert result != null : \"Expected a non-null Result\";\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    assert(include != null);  // Assertion to ensure include is not null\n\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n    assertNotNull(result);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L126": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
        "AfterRefact": "public TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}\n\n\tprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}\n\t",
        "ZeroShotCode": {
            "methods": [
                "private void validateConstructor(Class<? extends TestCase> theClass) {\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n    }\n}",
                "public constructor TestCase(String name) or TestCase()\"));\n    }\n}\n\nprivate void validatePublicModifier(Class<?> theClass) {\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void validatePublicModifier(Class<?> theClass) {\n    if (!Modifier.isPublic(theClass.getModifiers())) {\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n    }\n}",
                "private void collectTestMethods(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    validateConstructor(theClass);\n    validatePublicModifier(theClass);\n    collectTestMethods(theClass);\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void extractTestsFromSuperClass(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractTestsFromSuperClass(theClass);\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void extractTestMethods(Class<?> superClass, List<String> names, Class<? extends TestCase> theClass) {\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    extractTestMethods(superClass, names, theClass);\n    \n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private boolean isValidTestClass(Class<? extends TestCase> testClass) {\n    try {\n        getTestConstructor(testClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + testClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n\n    if (!Modifier.isPublic(testClass.getModifiers())) {\n        addTest(warning(\"Class \" + testClass.getName() + \" is not public\"));\n        return false;\n    }\n\n    return true;\n}",
                "public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n\n    if (!Modifier.isPublic(testClass.getModifiers())) {"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> testClass) {\n    fName = testClass.getName();\n    \n    if (!isValidTestClass(testClass)) {\n        return;\n    }\n\n    List<String> methodNames = new ArrayList<>();\n    Class<?> currentClass = testClass;\n\n    while (Test.class.isAssignableFrom(currentClass)) {\n        for (Method method : currentClass.getDeclaredMethods()) {\n            addTestMethod(method, methodNames, testClass);\n        }\n        currentClass = currentClass.getSuperclass();\n    }\n\n    if (fTests.isEmpty()) {\n        addTest(warning(\"No tests found in \" + testClass.getName()));\n    }\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void processTestClass(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    \n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n    \n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    processTestClass(theClass);\n}\n\n",
                "\n```"
            ]
        }
    }
}