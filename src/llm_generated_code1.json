{
    "L7413": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) {\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t}\n\t}",
        "InstrucCode": "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        assert !s.nonGreedy : \"nongreedy decisions can't be LL(1)\";\n        g.tool.log(\"LL1\", \"\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if (s.nonGreedy) {\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}",
        "FewShotCode": "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        IntervalSet[] look;\n        if (s.nonGreedy) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n    }\n}",
        "AfterRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\n\t\t\tassert s.decision + 1 >= g.decisionLOOK.size();\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}"
    },
    "L1506": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void addTransition(Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(e);\n\t}",
        "ZeroShotCode": "public void addTransition(Transition e) {\n\tepsilonOnlyTransitions = transitions.isEmpty() ? e.isEpsilon() : epsilonOnlyTransitions && e.isEpsilon();\n\tif (!epsilonOnlyTransitions) {\n\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t}\n\ttransitions.add(e);\n}",
        "InstrucCode": "public void addTransition(Transition e) {\n\tif (transitions.isEmpty() || (epsilonOnlyTransitions != e.isEpsilon())) {\n\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\tepsilonOnlyTransitions = false;\n\t}\n\n\ttransitions.add(e);\n}\n",
        "FewShotCode": "public void addTransition(Transition e) {\n    if (transitions.isEmpty() || epsilonOnlyTransitions != e.isEpsilon()) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n    \n    transitions.add(e);\n}",
        "AfterRefact": "public void addTransition(Transition e) {\n\t\taddTransition(transitions.size(), e);\n\t}\n\n\tpublic void addTransition(int index, Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(Locale.getDefault(), \"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(index, e);\n\t}"
    }
}

