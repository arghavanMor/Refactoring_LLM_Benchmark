/usr/local/bin/python3.12 /Users/jeancarlorspaul/IdeaProjects/Refactoring_LLM_Benchmark/src/utils/main.py
HEAD is now at ad9bac951 Fix diagrams for ATNState documentation
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4226c706d L10937INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739853347.4755051
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e64c48333 L10937INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739853347.4755052
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3f911f30b L10937INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739853347.4755053
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 408fb9b8a L10937INTRODUCE_EXPLAINING_VARIABLEContextCode1739853347.4755054
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 07b55ea67 L10937INTRODUCE_EXPLAINING_VARIABLERulesCode1739853347.4755055
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 908ca046a L5343INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739853469.3469961
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4d05f71ee L5343INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739853469.3469962
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5a6330e27 L5343INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739853469.3469963
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2f046198a L5343INTRODUCE_EXPLAINING_VARIABLEContextCode1739853469.3469964
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1fe216de5 L5343INTRODUCE_EXPLAINING_VARIABLERulesCode1739853469.3469965
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c60b23bd5 L3671INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739853562.0317821
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2190e8143 L3671INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739853562.0317822
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  testAmbiguityNoLoop(org.antlr.v4.test.TestFullContextParsing): expected:<...a@'(..)
  testExprAmbiguity(org.antlr.v4.test.TestFullContextParsing): expected:<...text d=1, input='*'(..)
  testFullContextIF_THEN_ELSEParse(org.antlr.v4.test.TestFullContextParsing): expected:<...t d=1, input='else'(..)
  testLoopsSimulateTailRecursion(org.antlr.v4.test.TestFullContextParsing): expected:<...t d=3, input='a(i)'(..)
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  test2UnpredicatedAlts(org.antlr.v4.test.TestSemPredEvalParser): expected:<...0, input='x'(..)
  test2UnpredicatedAltsAndOneOrthogonalAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<...0, input='x'(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 30, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c8fecaaee L3671INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739853562.0317823
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8b3a1c183 L3671INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739853562.0317824
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f571c8220 L3671INTRODUCE_EXPLAINING_VARIABLEContextCode1739853562.0317825
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5c0937b97 L3671INTRODUCE_EXPLAINING_VARIABLERulesCode1739853562.0317826
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2fca69296 L3692INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739853712.3998411
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 939d406db L3692INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739853712.3998412
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  testCtxSensitiveDFATwoDiffInput(org.antlr.v4.test.TestFullContextParsing): expected:<...nput='34abc'(..)
  testFullContextIF_THEN_ELSEParse(org.antlr.v4.test.TestFullContextParsing): expected:<...t d=1, input='else'(..)
  testCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<... d=1, input='34abc'(..)
  testSLLSeesEOFInLLGrammar(org.antlr.v4.test.TestFullContextParsing): expected:<... d=0, input='34abc'(..)
  testAmbiguityNoLoop(org.antlr.v4.test.TestFullContextParsing): expected:<...ext d=1, input='a@'(..)
  testExprAmbiguity(org.antlr.v4.test.TestFullContextParsing): expected:<...text d=1, input='+'(..)
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 30, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 988cc6165 L3692INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739853712.3998413
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 992f180a7 L3692INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739853712.3998414
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 48dbcda75 L3692INTRODUCE_EXPLAINING_VARIABLEContextCode1739853712.3998415
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 78bf2b870 L3692INTRODUCE_EXPLAINING_VARIABLERulesCode1739853712.3998416
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 05650889d L7413INTRODUCE_ASSERTIONZeroShotCode1739853861.7587042
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b8472e149 L7413INTRODUCE_ASSERTIONContextCode1739853861.7587045
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 2, column 25.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at eaaa168f5 L7413INTRODUCE_ASSERTIONContextCode1739853861.7587047
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 51fd646f7 L7413INTRODUCE_ASSERTIONContextCode1739853861.7587048
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 700097478 L1927EXTRACT_METHODZeroShotCode1739853876.1811822
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0e2adae5b L1927EXTRACT_METHODInstrucCode1739853876.1811824
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 67ef871b1 L1927EXTRACT_METHODFewShotCode1739853876.1811826
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0ecb87688 L1927EXTRACT_METHODContextCode1739853876.1811828
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 143b0c824 L1927EXTRACT_METHODRulesCode1739853876.18118210
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2112c321f L5431CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739853888.5121291
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at df03bb3c0 L5431CONSOLIDATE_COND_EXPRESSIONInstrucCode1739853888.5121292
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 69e8a9d3f L5431CONSOLIDATE_COND_EXPRESSIONFewShotCode1739853888.5121293
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d80ada224 L5431CONSOLIDATE_COND_EXPRESSIONFewShotCode1739853888.5121294
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at bd47fefa3 L5431CONSOLIDATE_COND_EXPRESSIONContextCode1739853888.5121295
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at df6fde52c L5431CONSOLIDATE_COND_EXPRESSIONRulesCode1739853888.5121296
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 12ccd32ea L3844CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739854060.2467821
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c3b08a465 L3844CONSOLIDATE_COND_EXPRESSIONInstrucCode1739854060.2467822
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 040d0f0bd L3844CONSOLIDATE_COND_EXPRESSIONFewShotCode1739854060.2467823
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at cc41356b8 L3844CONSOLIDATE_COND_EXPRESSIONContextCode1739854060.2467824
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ab3f2d6f6 L3844CONSOLIDATE_COND_EXPRESSIONContextCode1739854060.2467825
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f02ffe4fd L3844CONSOLIDATE_COND_EXPRESSIONRulesCode1739854060.2467826
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8a9f3c48e L3168CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739854183.3019011
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fcf3acf3c L3168CONSOLIDATE_COND_EXPRESSIONInstrucCode1739854183.3019012
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 020e10b70 L3168CONSOLIDATE_COND_EXPRESSIONFewShotCode1739854183.3019013
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7e0bb00d5 L3168CONSOLIDATE_COND_EXPRESSIONContextCode1739854183.3019014
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 92cd153fb L3168CONSOLIDATE_COND_EXPRESSIONContextCode1739854183.3019015
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 66deb4603 L3168CONSOLIDATE_COND_EXPRESSIONRulesCode1739854183.3019016
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5f5cf3223 L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854195.4965741
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e50371b29 L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854195.4965742
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 67.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 26, column 75.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.WhileStatement(GeneratedJavaParser.java:4402)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3788)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 26, column 75.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.WhileStatement(GeneratedJavaParser.java:4402)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3788)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 77ae76ad2 L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854195.4965746
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 67.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 90.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4bfde43dc L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739854195.4965749
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 62.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 61f7ab57d L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854209.8208361
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d474957f7 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854209.8208362
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c7fe06fb9 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854209.8208363
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5a1550bc7 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854209.8208364
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 997f0f463 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739854209.8208365
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f7ebb40d3 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739854209.8208366
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7142b37c2 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854209.8208367
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 46245548b L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854209.8208368
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2a78d8833 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854209.8208369
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 80b54b18c L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854209.82083610
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3332476ed L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854209.82083611
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at def34ca70 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854209.82083612
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 880c7f310 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739854209.82083613
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d60fc2523 L156680CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739854250.7735991
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ee9594de0 L156680CONSOLIDATE_COND_EXPRESSIONInstrucCode1739854250.7735992
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d97e235ea L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739854250.7735993
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6c7c82cbb L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739854250.7735994
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3d91bb436 L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739854250.7735995
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e7cd415b6 L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739854250.7735996
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b37288ff2 L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739854250.7735997
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b202a577d L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739854250.7735998
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at da6f166bc L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739854250.7735999
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3de41501b L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739854250.77359910
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 136c0e5ee L156680CONSOLIDATE_COND_EXPRESSIONRulesCode1739854250.77359911
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 39235f7db L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854285.3865451
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c4c5798a3 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739854285.3865452
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f8b723c56 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739854285.3865453
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 39c7315e6 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854285.3865454
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 141406530 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739854285.3865455
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 26aa7601f L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753921
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5807865d7 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753922
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0fa29fee6 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753923
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 06c0b0d77 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753924
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 73240856b L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753925
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9b25b3175 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753926
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 39f48c7de L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854296.0753927
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 535586b0f L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739854296.0753928
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 31c786626 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739854296.0753929
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1ece3989b L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539210
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at cb3d0068a L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539211
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 68f715c62 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539212
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 48c71e2b3 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539213
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c93e8f4d8 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539214
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 309a4d756 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539215
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 301bd0204 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854296.07539216
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 251641279 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739854296.07539217
----------------- Refactoring process has started .... -----------------
----------------- load is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3088f4fca L13228CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854330.796031
----------------- Refactoring process has started .... -----------------
----------------- load is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f764fbb41 L13228CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854330.796032
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 15, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2493fd3ee L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854337.1165032
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 16, column 52.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 7, column 123.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 69.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 10, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 12, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 58.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 13, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 812cf9603 L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854337.11650312
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 10, column 52.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fa441109a L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854337.11650314
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d27bbb601 L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854337.11650315
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 8, column 123.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 69.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 11, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 13, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 58.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f8143781f L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854355.2905131
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d64528114 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854355.2905132
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5d5a5ea91 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854355.2905133
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7db26c308 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739854355.2905134
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 00141b10e L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739854355.2905135
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 247fe1193 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854355.2905136
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f646cafd3 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739854355.2905137
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  testLabels(org.antlr.v4.test.TestParserExec)
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 25, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- addTransition is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0b4e344d9 L1506CONSOLIDATE_COND_EXPRESSIONFewShotCode1739854483.5838184
----------------- Refactoring process has started .... -----------------
----------------- addTransition is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4dc73df97 L1506CONSOLIDATE_COND_EXPRESSIONContextCode1739854483.5838185
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2043e34e0 L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854516.0697824
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 84.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_scan_token(GeneratedJavaParser.java:10536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_112(GeneratedJavaParser.java:9553)
  com.github.javaparser.GeneratedJavaParser.jj_3R_208(GeneratedJavaParser.java:9652)
  com.github.javaparser.GeneratedJavaParser.jj_3R_171(GeneratedJavaParser.java:9677)
  com.github.javaparser.GeneratedJavaParser.jj_3R_398(GeneratedJavaParser.java:9780)
  com.github.javaparser.GeneratedJavaParser.jj_3R_394(GeneratedJavaParser.java:9863)
  com.github.javaparser.GeneratedJavaParser.jj_3R_392(GeneratedJavaParser.java:9971)
  com.github.javaparser.GeneratedJavaParser.jj_3R_389(GeneratedJavaParser.java:10086)
  com.github.javaparser.GeneratedJavaParser.jj_3R_381(GeneratedJavaParser.java:10147)
  com.github.javaparser.GeneratedJavaParser.jj_3R_371(GeneratedJavaParser.java:10251)
  com.github.javaparser.GeneratedJavaParser.jj_3R_354(GeneratedJavaParser.java:10276)
  com.github.javaparser.GeneratedJavaParser.jj_3R_330(GeneratedJavaParser.java:10338)
  com.github.javaparser.GeneratedJavaParser.jj_3R_302(GeneratedJavaParser.java:10367)
  com.github.javaparser.GeneratedJavaParser.jj_3R_250(GeneratedJavaParser.java:6449)
  com.github.javaparser.GeneratedJavaParser.jj_3R_201(GeneratedJavaParser.java:6500)
  com.github.javaparser.GeneratedJavaParser.jj_3R_150(GeneratedJavaParser.java:6536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_92(GeneratedJavaParser.java:6960)
  com.github.javaparser.GeneratedJavaParser.jj_3R_267(GeneratedJavaParser.java:7794)
  com.github.javaparser.GeneratedJavaParser.jj_3R_215(GeneratedJavaParser.java:7816)
  com.github.javaparser.GeneratedJavaParser.jj_3R_184(GeneratedJavaParser.java:7832)
  com.github.javaparser.GeneratedJavaParser.jj_3R_257(GeneratedJavaParser.java:8209)
  com.github.javaparser.GeneratedJavaParser.jj_3R_206(GeneratedJavaParser.java:8271)
  com.github.javaparser.GeneratedJavaParser.jj_3R_163(GeneratedJavaParser.java:8327)
  com.github.javaparser.GeneratedJavaParser.jj_3R_101(GeneratedJavaParser.java:8376)
  com.github.javaparser.GeneratedJavaParser.jj_3_37(GeneratedJavaParser.java:8419)
  com.github.javaparser.GeneratedJavaParser.jj_3R_100(GeneratedJavaParser.java:8455)
  com.github.javaparser.GeneratedJavaParser.jj_3_31(GeneratedJavaParser.java:8952)
  com.github.javaparser.GeneratedJavaParser.jj_3R_212(GeneratedJavaParser.java:9080)
  com.github.javaparser.GeneratedJavaParser.jj_3R_305(GeneratedJavaParser.java:9319)
  com.github.javaparser.GeneratedJavaParser.jj_3R_254(GeneratedJavaParser.java:9243)
  com.github.javaparser.GeneratedJavaParser.jj_3R_203(GeneratedJavaParser.java:9383)
  com.github.javaparser.GeneratedJavaParser.jj_3R_211(GeneratedJavaParser.java:9570)
  com.github.javaparser.GeneratedJavaParser.jj_3R_171(GeneratedJavaParser.java:9683)
  com.github.javaparser.GeneratedJavaParser.jj_3R_398(GeneratedJavaParser.java:9780)
  com.github.javaparser.GeneratedJavaParser.jj_3R_394(GeneratedJavaParser.java:9863)
  com.github.javaparser.GeneratedJavaParser.jj_3R_392(GeneratedJavaParser.java:9971)
  com.github.javaparser.GeneratedJavaParser.jj_3R_389(GeneratedJavaParser.java:10086)
  com.github.javaparser.GeneratedJavaParser.jj_3R_381(GeneratedJavaParser.java:10147)
  com.github.javaparser.GeneratedJavaParser.jj_3R_371(GeneratedJavaParser.java:10251)
  com.github.javaparser.GeneratedJavaParser.jj_3R_354(GeneratedJavaParser.java:10276)
  com.github.javaparser.GeneratedJavaParser.jj_3R_330(GeneratedJavaParser.java:10338)
  com.github.javaparser.GeneratedJavaParser.jj_3R_302(GeneratedJavaParser.java:10367)
  com.github.javaparser.GeneratedJavaParser.jj_3R_250(GeneratedJavaParser.java:6449)
  com.github.javaparser.GeneratedJavaParser.jj_3R_201(GeneratedJavaParser.java:6500)
  com.github.javaparser.GeneratedJavaParser.jj_3R_150(GeneratedJavaParser.java:6536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_92(GeneratedJavaParser.java:6960)
  com.github.javaparser.GeneratedJavaParser.jj_3R_307(GeneratedJavaParser.java:6528)
  com.github.javaparser.GeneratedJavaParser.jj_3R_150(GeneratedJavaParser.java:6539)
  com.github.javaparser.GeneratedJavaParser.jj_3R_92(GeneratedJavaParser.java:6960)
  com.github.javaparser.GeneratedJavaParser.jj_3R_125(GeneratedJavaParser.java:9171)
  com.github.javaparser.GeneratedJavaParser.jj_3R_80(GeneratedJavaParser.java:9224)
  com.github.javaparser.GeneratedJavaParser.jj_3R_174(GeneratedJavaParser.java:9201)
  com.github.javaparser.GeneratedJavaParser.jj_3R_114(GeneratedJavaParser.java:9364)
  com.github.javaparser.GeneratedJavaParser.jj_3R_111(GeneratedJavaParser.java:7074)
  com.github.javaparser.GeneratedJavaParser.jj_3_43(GeneratedJavaParser.java:7085)
  com.github.javaparser.GeneratedJavaParser.jj_2_43(GeneratedJavaParser.java:6283)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3894)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 011ccebbd L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854516.0697826
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8f207f8b0 L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854516.0697827
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 42f10bc55 L19910INTRODUCE_NULL_OBJECTZeroShotCode1739854524.0304861
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 49da585f7 L19910INTRODUCE_NULL_OBJECTZeroShotCode1739854524.0304862
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 50.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4abcd9af9 L19910INTRODUCE_NULL_OBJECTInstrucCode1739854524.0304864
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at dcc6c3f49 L19910INTRODUCE_NULL_OBJECTInstrucCode1739854524.0304865
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 55.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 871617a40 L19910INTRODUCE_NULL_OBJECTInstrucCode1739854524.0304867
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ea3aaff42 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.0304869
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 59.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ffd9778a8 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048611
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 30bb7476a L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048612
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a77ab9ac5 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048613
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7ebad71c1 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048614
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b58ad29cd L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048615
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8935562d7 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048616
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 070a13778 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048617
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 576042809 L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048618
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b3059593f L19910INTRODUCE_NULL_OBJECTContextCode1739854524.03048619
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 32eb627e7 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739854557.875731
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0b81b1378 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESInstrucCode1739854557.875732
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d7595e01a L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESFewShotCode1739854557.875733
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 263f14987 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854557.875734
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b77d27dbd L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854557.875735
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0eed12e84 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854557.875736
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 937a62b6b L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854557.875737
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1b6ba5f31 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESRulesCode1739854557.875738
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0acbdb762 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739854822.8079831
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testRuleGetters(org.antlr.v4.test.TestListeners): expected:<(a [(b 1) (b 2))(..)
  testLR(org.antlr.v4.test.TestListeners)
  testPEGAchillesHeel(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<2>
  testLL1Ambig(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testLL2Ambig(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testContinuePrediction2(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testNoViableAltAvoidance(org.antlr.v4.test.TestParseErrors): expected:<...nput '.' expecting '[!]'(..)
  testLL3(org.antlr.v4.test.TestParseErrors): expected:<line 1:2 [no viable alternative at input 'abe]'(..)
  testLLStar(org.antlr.v4.test.TestParseErrors): expected:<line 1:[3 no viable alternative at input 'aaae]'(..)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  testIfIfElseGreedyBinding(org.antlr.v4.test.TestParserExec): expected:<if y x else x(..)
  testOptional(org.antlr.v4.test.TestParserExec)
  testPredicatedIfIfElse(org.antlr.v4.test.TestParserExec)
  testIfIfElseNonGreedyBinding(org.antlr.v4.test.TestParserExec): expected:<if y x[(..)
  testCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 1:(..)
  testSLLSeesEOFInLLGrammar(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 0:(..)
  testAmbiguityNoLoop(org.antlr.v4.test.TestFullContextParsing): expected:<[alt 1(..)
  testExprAmbiguity(org.antlr.v4.test.TestFullContextParsing): expected:<(expr a + [(expr b)])(..)
  testAmbigYieldsCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<[Decision 0:(..)
  testCtxSensitiveDFATwoDiffInput(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 2:(..)
  testFullContextIF_THEN_ELSEParse(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 1:(..)
  testLoopsSimulateTailRecursion(org.antlr.v4.test.TestFullContextParsing): expected:<[pass: a(i)<-x(..)
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testPEGAchillesHeel(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<2>
  testAmbigAltChooseFirst2(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<3>
  testMustTrackPreviousGoodAlt(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<2>
  testDelegatorRuleOverridesLookaheadInDelegate(org.antlr.v4.test.TestCompositeGrammars): expected:<[JavaDecl: floatx=3;(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimpleValidate2(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  test2UnpredicatedAlts(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testRewindBeforePredEval(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testUnpredicatedPathsInAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testActionHidesPreds(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testSimple(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testToLeft(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  test2UnpredicatedAltsAndOneOrthogonalAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<alt 1(..)
  testToLeftWithVaryingPredicate(org.antlr.v4.test.TestSemPredEvalParser): expected:<[i=1(..)
  testPredicateDependentOnArg(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testDependentPredNotInOuterCtxShouldBeIgnored(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testIndependentPredNotPassedOuterCtxToAvoidCastException(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)

Tests in error:
  testEmptyInput(org.antlr.v4.test.TestATNParserPrediction)
  testRuleRefxory(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefix(org.antlr.v4.test.TestATNParserPrediction)
  testContinuePrediction(org.antlr.v4.test.TestATNParserPrediction)
  testOptionalRuleChasesGlobalFollow(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefixWithAorABIssue(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefix(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirst(org.antlr.v4.test.TestATNInterpreter)
  testArbitraryLeftPrefix(org.antlr.v4.test.TestATNInterpreter)
  testMustTrackPreviousGoodAltWithEOF(org.antlr.v4.test.TestATNInterpreter): Unexpected exception, expected<org.antlr.v4.runtime.NoViableAltException> but was<java.lang.AssertionError>
  testMustTrackPreviousGoodAlt2(org.antlr.v4.test.TestATNInterpreter)
  testMustTrackPreviousGoodAlt3(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirstWithFollowingToken(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirstWithFollowingToken2(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirst2WithEOF(org.antlr.v4.test.TestATNInterpreter): Unexpected exception, expected<org.antlr.v4.runtime.NoViableAltException> but was<java.lang.AssertionError>
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 60, Errors: 17, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 046c83059 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESInstrucCode1739854822.8079832
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8b9ac048e L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESFewShotCode1739854822.8079833
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testRuleGetters(org.antlr.v4.test.TestListeners): expected:<(a [(b 1) (b 2))(..)
  testPEGAchillesHeel(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<2>
  testLL1Ambig(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testLL2Ambig(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testContinuePrediction2(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testLL3(org.antlr.v4.test.TestParseErrors): expected:<line 1:2 [no viable alternative at input 'abe]'(..)
  testLLStar(org.antlr.v4.test.TestParseErrors): expected:<line 1:[3 no viable alternative at input 'aaae]'(..)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testNoViableAltAvoidance(org.antlr.v4.test.TestParseErrors): expected:<...nput '.' expecting '[!]'(..)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  testIfIfElseGreedyBinding(org.antlr.v4.test.TestParserExec): expected:<if y x else x(..)
  testOptional(org.antlr.v4.test.TestParserExec)
  testPredicatedIfIfElse(org.antlr.v4.test.TestParserExec)
  testIfIfElseNonGreedyBinding(org.antlr.v4.test.TestParserExec): expected:<if y x[(..)
  testCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 1:(..)
  testSLLSeesEOFInLLGrammar(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 0:(..)
  testAmbiguityNoLoop(org.antlr.v4.test.TestFullContextParsing): expected:<[alt 1(..)
  testExprAmbiguity(org.antlr.v4.test.TestFullContextParsing): expected:<(expr a + [(expr b)])(..)
  testAmbigYieldsCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<[Decision 0:(..)
  testCtxSensitiveDFATwoDiffInput(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 2:(..)
  testFullContextIF_THEN_ELSEParse(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 1:(..)
  testLoopsSimulateTailRecursion(org.antlr.v4.test.TestFullContextParsing): expected:<[pass: a(i)<-x(..)
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testPEGAchillesHeel(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<2>
  testAmbigAltChooseFirst2(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<3>
  testMustTrackPreviousGoodAlt(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<2>
  testDelegatorRuleOverridesLookaheadInDelegate(org.antlr.v4.test.TestCompositeGrammars): expected:<[JavaDecl: floatx=3;(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testDependentPredNotInOuterCtxShouldBeIgnored(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testIndependentPredNotPassedOuterCtxToAvoidCastException(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testSimple(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testToLeft(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testSimpleValidate2(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  test2UnpredicatedAlts(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testRewindBeforePredEval(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testUnpredicatedPathsInAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testActionHidesPreds(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  test2UnpredicatedAltsAndOneOrthogonalAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<alt 1(..)
  testToLeftWithVaryingPredicate(org.antlr.v4.test.TestSemPredEvalParser): expected:<[i=1(..)
  testPredicateDependentOnArg(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)

Tests in error:
  testEmptyInput(org.antlr.v4.test.TestATNParserPrediction)
  testRuleRefxory(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefix(org.antlr.v4.test.TestATNParserPrediction)
  testContinuePrediction(org.antlr.v4.test.TestATNParserPrediction)
  testOptionalRuleChasesGlobalFollow(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefixWithAorABIssue(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefix(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirst(org.antlr.v4.test.TestATNInterpreter)
  testArbitraryLeftPrefix(org.antlr.v4.test.TestATNInterpreter)
  testMustTrackPreviousGoodAltWithEOF(org.antlr.v4.test.TestATNInterpreter): Unexpected exception, expected<org.antlr.v4.runtime.NoViableAltException> but was<java.lang.AssertionError>
  testMustTrackPreviousGoodAlt2(org.antlr.v4.test.TestATNInterpreter)
  testMustTrackPreviousGoodAlt3(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirstWithFollowingToken(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirstWithFollowingToken2(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirst2WithEOF(org.antlr.v4.test.TestATNInterpreter): Unexpected exception, expected<org.antlr.v4.runtime.NoViableAltException> but was<java.lang.AssertionError>
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 60, Errors: 17, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 059928f6e L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739854822.8079834
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at cfb459c5d L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESRulesCode1739854822.8079835
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testRuleGetters(org.antlr.v4.test.TestListeners): expected:<(a [(b 1) (b 2))(..)
  testLR(org.antlr.v4.test.TestListeners)
  testPEGAchillesHeel(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<2>
  testLL1Ambig(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testLL2Ambig(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testContinuePrediction2(org.antlr.v4.test.TestATNParserPrediction): expected:<1> but was:<3>
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testNoViableAltAvoidance(org.antlr.v4.test.TestParseErrors): expected:<...nput '.' expecting '[!]'(..)
  testLL3(org.antlr.v4.test.TestParseErrors): expected:<line 1:2 [no viable alternative at input 'abe]'(..)
  testLLStar(org.antlr.v4.test.TestParseErrors): expected:<line 1:[3 no viable alternative at input 'aaae]'(..)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  testIfIfElseGreedyBinding(org.antlr.v4.test.TestParserExec): expected:<if y x else x(..)
  testOptional(org.antlr.v4.test.TestParserExec)
  testPredicatedIfIfElse(org.antlr.v4.test.TestParserExec)
  testIfIfElseNonGreedyBinding(org.antlr.v4.test.TestParserExec): expected:<if y x[(..)
  testCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 1:(..)
  testSLLSeesEOFInLLGrammar(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 0:(..)
  testAmbiguityNoLoop(org.antlr.v4.test.TestFullContextParsing): expected:<[alt 1(..)
  testExprAmbiguity(org.antlr.v4.test.TestFullContextParsing): expected:<(expr a + [(expr b)])(..)
  testAmbigYieldsCtxSensitiveDFA(org.antlr.v4.test.TestFullContextParsing): expected:<[Decision 0:(..)
  testCtxSensitiveDFATwoDiffInput(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 2:(..)
  testFullContextIF_THEN_ELSEParse(org.antlr.v4.test.TestFullContextParsing): expected:<Decision 1:(..)
  testLoopsSimulateTailRecursion(org.antlr.v4.test.TestFullContextParsing): expected:<[pass: a(i)<-x(..)
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testAmbigAltChooseFirst2(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<3>
  testPEGAchillesHeel(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<2>
  testMustTrackPreviousGoodAlt(org.antlr.v4.test.TestATNInterpreter): expected:<1> but was:<2>
  testDelegatorRuleOverridesLookaheadInDelegate(org.antlr.v4.test.TestCompositeGrammars): expected:<[JavaDecl: floatx=3;(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimpleValidate2(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  test2UnpredicatedAlts(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testRewindBeforePredEval(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testUnpredicatedPathsInAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testActionHidesPreds(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 1(..)
  testSimple(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testToLeft(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  test2UnpredicatedAltsAndOneOrthogonalAlt(org.antlr.v4.test.TestSemPredEvalParser): expected:<alt 1(..)
  testToLeftWithVaryingPredicate(org.antlr.v4.test.TestSemPredEvalParser): expected:<[i=1(..)
  testPredicateDependentOnArg(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testDependentPredNotInOuterCtxShouldBeIgnored(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)
  testIndependentPredNotPassedOuterCtxToAvoidCastException(org.antlr.v4.test.TestSemPredEvalParser): expected:<[alt 2(..)

Tests in error:
  testEmptyInput(org.antlr.v4.test.TestATNParserPrediction)
  testRuleRefxory(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefix(org.antlr.v4.test.TestATNParserPrediction)
  testContinuePrediction(org.antlr.v4.test.TestATNParserPrediction)
  testOptionalRuleChasesGlobalFollow(org.antlr.v4.test.TestATNParserPrediction)
  testRecursiveLeftPrefixWithAorABIssue(org.antlr.v4.test.TestATNParserPrediction)
  testAmbigAltChooseFirst(org.antlr.v4.test.TestATNInterpreter)
  testArbitraryLeftPrefix(org.antlr.v4.test.TestATNInterpreter)
  testRecursiveLeftPrefix(org.antlr.v4.test.TestATNInterpreter)
  testMustTrackPreviousGoodAltWithEOF(org.antlr.v4.test.TestATNInterpreter): Unexpected exception, expected<org.antlr.v4.runtime.NoViableAltException> but was<java.lang.AssertionError>
  testMustTrackPreviousGoodAlt2(org.antlr.v4.test.TestATNInterpreter)
  testMustTrackPreviousGoodAlt3(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirstWithFollowingToken(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirstWithFollowingToken2(org.antlr.v4.test.TestATNInterpreter)
  testAmbigAltChooseFirst2WithEOF(org.antlr.v4.test.TestATNInterpreter): Unexpected exception, expected<org.antlr.v4.runtime.NoViableAltException> but was<java.lang.AssertionError>
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 60, Errors: 17, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fa168f6ae L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854968.3287951
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ea9b59ee3 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854968.3287952
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5880cd47d L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739854968.3287953
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1925d22b6 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854968.3287954
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c19de9346 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854968.3287955
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f93760d55 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854968.3287956
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 824a72296 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739854968.3287957
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4bbdd66ed L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739855176.8002031
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 917c6de65 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739855176.8002032
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 41.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2511)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4376)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 17.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_scan_token(GeneratedJavaParser.java:10536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_163(GeneratedJavaParser.java:8320)
  com.github.javaparser.GeneratedJavaParser.jj_3R_101(GeneratedJavaParser.java:8376)
  com.github.javaparser.GeneratedJavaParser.jj_3_37(GeneratedJavaParser.java:8419)
  com.github.javaparser.GeneratedJavaParser.jj_3R_100(GeneratedJavaParser.java:8455)
  com.github.javaparser.GeneratedJavaParser.jj_3_31(GeneratedJavaParser.java:8952)
  com.github.javaparser.GeneratedJavaParser.jj_2_31(GeneratedJavaParser.java:6187)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:2996)
  com.github.javaparser.GeneratedJavaParser.PostfixExpression(GeneratedJavaParser.java:2894)
  com.github.javaparser.GeneratedJavaParser.UnaryExpressionNotPlusMinus(GeneratedJavaParser.java:2875)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2777)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ReturnStatement(GeneratedJavaParser.java:4884)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3808)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f7eb156a5 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739855176.8002035
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 719e2ecb6 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739855176.8002036
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6dbb2b8f8 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739855176.8002037
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 2, column 33.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2511)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4376)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1d01d1ef2 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739855176.8002039
test_result_summary
Results :

Failed tests:   testLR(org.antlr.v4.test.TestListeners)
  testLRWithLabels(org.antlr.v4.test.TestListeners)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSimple(org.antlr.v4.test.TestLeftRecursion)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f289c2368 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTZeroShotCode1739855354.7620141
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int execute() {
        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class CalculateHashCodeCommand {

        private final int parentHashCode;

        private final int returnStateHashCode;

        public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e9b7f8bbf L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTInstrucCode1739855354.7620142
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
        return new CalculateHashCodeCommand(parentHashCode, returnStateHashCode).execute();
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class CalculateHashCodeCommand {

        private final int parentHashCode;

        private final int returnStateHashCode;

        public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2160e733b L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTInstrucCode1739855354.7620143
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
        return new HashCodeCalculator(parentHashCode, returnStateHashCode).execute();
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        private int parentHashCode;

        private int returnStateHashCode;

        private int result;

        public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
            return result;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 267393649 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTFewShotCode1739855354.7620144
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int execute() {
        result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        return result;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        private int parentHashCode;

        private int returnStateHashCode;

        private int result;

        public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
            return result;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b7b04d8ac L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTFewShotCode1739855354.7620145
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0be189d19 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTContextCode1739855354.7620146
test_result_summary
Results :

Failed tests:   testLRWithLabels(org.antlr.v4.test.TestListeners)
  testLR(org.antlr.v4.test.TestListeners)
  testMultiTokenDeletionBeforeLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testSingleTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c]'}(..)
  testMultiTokenDeletionDuringLoop2(org.antlr.v4.test.TestParseErrors): expected:<...a' expecting {'b', '[z', 'c'}(..)
  testDuplicatedLeftRecursiveCall(org.antlr.v4.test.TestParseErrors)
  testConjuringUpTokenFromSet(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testConjuringUpToken(org.antlr.v4.test.TestParseErrors): expected:<...-1='<missing 'b'>',<[1]>,1:1](..)
  testInvalidATNStateRemoval(org.antlr.v4.test.TestParseErrors)
  testFairlyLargeGraph(org.antlr.v4.test.TestTopologicalSort): expected:<[H, F, E, D, [G, A, B], C]> but was:<[H, F, E, D, [A, B, G], C]>
  testSimpleTokenDependence(org.antlr.v4.test.TestTopologicalSort): expected:<...va.g4, Java.tokens, [Ref.g4, D]ef.g4]> but was:<...va.g4, Java.tokens, [Def.g4, R]ef.g4]>
  testParserLexerCombo(org.antlr.v4.test.TestTopologicalSort): expected:<...ens, JavaParser.g4, [Ref.g4, D]ef.g4]> but was:<...ens, JavaParser.g4, [Def.g4, R]ef.g4]>
  compileJdk(org.antlr.v4.test.TestPerformance): The JDK_SOURCE_ROOT environment variable must be set for performance testing.
  testReturnValueAndActionsAndLabels(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testPrefixOpWithActionAndLabel(org.antlr.v4.test.TestLeftRecursion): expected:<[a(..)
  testSemPred(org.antlr.v4.test.TestLeftRecursion)
  testTernaryExpr(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e a) <EOF>)(..)
  testJavaExpressions(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e (e a) | (e (e b) & (e c))) <EOF>)(..)
  testDeclarations(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (declarator a) <EOF>)(..)
  testReturnValueAndActions(org.antlr.v4.test.TestLeftRecursion): expected:<[4(..)
  testLabelsOnOpSubrule(org.antlr.v4.test.TestLeftRecursion): expected:<[(s (e 4))(..)
  testAmbigLR(org.antlr.v4.test.TestLeftRecursion)
  testSimple(org.antlr.v4.test.TestLeftRecursion)

Tests in error:
  testCheckForNonLeftRecursiveRule(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0
  testCheckForLeftRecursiveEmptyFollow(org.antlr.v4.test.TestLeftRecursion): Index 0 out of bounds for length 0

Tests run: 656, Failures: 24, Errors: 2, Skipped: 2


----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
        return HashCodeCalculator.calculate(parentHashCode, returnStateHashCode);
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        public static int calculate(int parentHashCode, int returnStateHashCode) {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c5149ee61 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTRulesCode1739855354.7620147
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculate(int parentHashCode, int returnStateHashCode) {
        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        public static int calculate(int parentHashCode, int returnStateHashCode) {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4db1fa45f L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTRulesCode1739855354.7620148

Process finished with exit code 0
