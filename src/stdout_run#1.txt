/usr/local/bin/python3.12 /Users/jeancarlorspaul/Documents/Doc_Carl/Poly/LLM_Refactoring_Project/Refactoring_AST/src/utils/main1.py
HEAD is now at ad9bac951 Fix diagrams for ATNState documentation
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e44b34cc7 L10937INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739515379.1829141
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9ee7b7173 L10937INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739515379.1829142
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at dc680e673 L10937INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739515379.1829143
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b5bff4eda L10937INTRODUCE_EXPLAINING_VARIABLEContextCode1739515379.1829144
----------------- Refactoring process has started .... -----------------
----------------- set is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at bfb36d821 L10937INTRODUCE_EXPLAINING_VARIABLERulesCode1739515379.1829145
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 041375058 L5343INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739515504.046021
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at dfed0768d L5343INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739515504.046022
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e70488964 L5343INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739515504.046023
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at d833ac1b9 L5343INTRODUCE_EXPLAINING_VARIABLEContextCode1739515504.046024
----------------- Refactoring process has started .... -----------------
----------------- getParseListeners is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 723cabbfe L5343INTRODUCE_EXPLAINING_VARIABLERulesCode1739515504.046025
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at dc5b134cb L3671INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739515600.0659661
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fde2d75f7 L3671INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739515600.0659662
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0ad633fd2 L3671INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739515600.0659663
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 221b0811c L3671INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739515600.0659664
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at bf29ea8ac L3671INTRODUCE_EXPLAINING_VARIABLEContextCode1739515600.0659665
----------------- Refactoring process has started .... -----------------
----------------- reportAmbiguity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b571c4d1b L3671INTRODUCE_EXPLAINING_VARIABLERulesCode1739515600.0659666
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 31c9be3c2 L3692INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739515754.3086071
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6a733ea42 L3692INTRODUCE_EXPLAINING_VARIABLEZeroShotCode1739515754.3086072
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9dc98afd6 L3692INTRODUCE_EXPLAINING_VARIABLEInstrucCode1739515754.3086073
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fb1d6acef L3692INTRODUCE_EXPLAINING_VARIABLEFewShotCode1739515754.3086074
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ecfaa633b L3692INTRODUCE_EXPLAINING_VARIABLEContextCode1739515754.3086075
----------------- Refactoring process has started .... -----------------
----------------- reportContextSensitivity is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5d766fc99 L3692INTRODUCE_EXPLAINING_VARIABLERulesCode1739515754.3086076
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at cc7b12956 L7413INTRODUCE_ASSERTIONZeroShotCode1739515906.4142442
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 07744dc27 L7413INTRODUCE_ASSERTIONContextCode1739515906.4142445
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 2, column 25.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 892cd7603 L7413INTRODUCE_ASSERTIONContextCode1739515906.4142447
----------------- Refactoring process has started .... -----------------
----------------- processParser is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5af98f578 L7413INTRODUCE_ASSERTIONContextCode1739515906.4142448
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 29.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ArgumentList(GeneratedJavaParser.java:3543)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3516)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e7b3c4ee2 L1927EXTRACT_METHODZeroShotCode1739515921.2512
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b80a850ed L1927EXTRACT_METHODInstrucCode1739515921.2514
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 182471973 L1927EXTRACT_METHODFewShotCode1739515921.2516
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 21c85c9f6 L1927EXTRACT_METHODContextCode1739515921.2518
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 51.  Encountered: "\n" (10), after : "\"start state closure=%s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- execATN is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 709ceb404 L1927EXTRACT_METHODRulesCode1739515921.25110
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 70f8af38f L5431CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739515933.9941411
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 36b35e37d L5431CONSOLIDATE_COND_EXPRESSIONInstrucCode1739515933.9941412
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a4924a7b1 L5431CONSOLIDATE_COND_EXPRESSIONFewShotCode1739515933.9941413
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a3031b9f5 L5431CONSOLIDATE_COND_EXPRESSIONFewShotCode1739515933.9941414
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a590ba60e L5431CONSOLIDATE_COND_EXPRESSIONContextCode1739515933.9941415
----------------- Refactoring process has started .... -----------------
----------------- unrollRecursionContexts is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 99e0e2266 L5431CONSOLIDATE_COND_EXPRESSIONRulesCode1739515933.9941416
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 72aa3330c L3844CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739516087.9511931
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 99b0a07fe L3844CONSOLIDATE_COND_EXPRESSIONInstrucCode1739516087.9511932
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0411e1c07 L3844CONSOLIDATE_COND_EXPRESSIONFewShotCode1739516087.9511933
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e2f946cb6 L3844CONSOLIDATE_COND_EXPRESSIONContextCode1739516087.9511934
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at abff3fdba L3844CONSOLIDATE_COND_EXPRESSIONContextCode1739516087.9511935
----------------- Refactoring process has started .... -----------------
----------------- consume is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1d90bacde L3844CONSOLIDATE_COND_EXPRESSIONRulesCode1739516087.9511936
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b51cd71b3 L3168CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739516212.6119161
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at bba630b12 L3168CONSOLIDATE_COND_EXPRESSIONInstrucCode1739516212.6119162
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 849e58a26 L3168CONSOLIDATE_COND_EXPRESSIONFewShotCode1739516212.6119163
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 12e70cf63 L3168CONSOLIDATE_COND_EXPRESSIONContextCode1739516212.6119164
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 44f30fbfb L3168CONSOLIDATE_COND_EXPRESSIONContextCode1739516212.6119165
----------------- Refactoring process has started .... -----------------
----------------- computeReachSet is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3c37a7312 L3168CONSOLIDATE_COND_EXPRESSIONRulesCode1739516212.6119166
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b080c38ea L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516224.9284111
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 571910f8f L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516224.9284112
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 67.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 26, column 75.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.WhileStatement(GeneratedJavaParser.java:4402)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3788)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 26, column 75.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.WhileStatement(GeneratedJavaParser.java:4402)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3788)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2e397ed7f L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516224.9284116
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 67.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 90.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- asString is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 5e6a3f69a L10263CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739516224.9284119
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 62.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b8837a618 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516239.405261
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ceed30da4 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516239.405262
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3c1f9dc4a L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516239.405263
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 008a17219 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516239.405264
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 32eb36dee L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739516239.405265
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f55f43f4e L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739516239.405266
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4f64a495e L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516239.405267
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2b85f1a92 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516239.405268
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f49970fba L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516239.405269
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c8c0e3a8b L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516239.4052610
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 21d8d307d L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516239.4052611
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at db14b12d8 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516239.4052612
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9cfa58db1 L15668CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739516239.4052613
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 53dd0b678 L156680CONSOLIDATE_COND_EXPRESSIONZeroShotCode1739516280.5009831
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 261321263 L156680CONSOLIDATE_COND_EXPRESSIONInstrucCode1739516280.5009832
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4297d8ee6 L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739516280.5009833
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 053150f74 L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739516280.5009834
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8817ad140 L156680CONSOLIDATE_COND_EXPRESSIONFewShotCode1739516280.5009835
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 74c1904ac L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739516280.5009836
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e305ca84b L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739516280.5009837
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2ab743a11 L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739516280.5009838
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at da19d2c78 L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739516280.5009839
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4e67a53e0 L156680CONSOLIDATE_COND_EXPRESSIONContextCode1739516280.50098310
----------------- Refactoring process has started .... -----------------
----------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ---------------------------------- getDOT is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f4c4372a4 L156680CONSOLIDATE_COND_EXPRESSIONRulesCode1739516280.50098311
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at bf427be7c L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516315.4099521
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3647ac2c1 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739516315.4099522
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 10db5c6d6 L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739516315.4099523
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e13b1218f L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516315.4099524
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ab2f61a8f L3347CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739516315.4099525
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3b9562e35 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842361
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9780ecb65 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842362
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 197aebb2b L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842363
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 55a2d0540 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842364
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e17b22282 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842365
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 44ae22e8a L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842366
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 36b1d0498 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516326.1842367
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3b1f08e11 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739516326.1842368
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 80ab51e05 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739516326.1842369
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1b35b6ffa L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423610
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2ee276c97 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423611
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 24eb2f1f8 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423612
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a0d8f3b7c L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423613
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at da177fd9b L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423614
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fd47cda3d L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423615
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 327797c5f L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516326.18423616
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3b2e31359 L2755CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739516326.18423617
----------------- Refactoring process has started .... -----------------
----------------- load is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c3e8709f9 L13228CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516361.48271
----------------- Refactoring process has started .... -----------------
----------------- load is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 389de47a7 L13228CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516361.48272
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 15, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 00201ce3c L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516367.7552882
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 16, column 52.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 7, column 123.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 69.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 10, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 12, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 58.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 13, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e66fde8eb L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516367.75528812
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 10, column 52.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9d5e26b20 L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516367.75528814
----------------- Refactoring process has started .... -----------------
----------------- decode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at b5bc1535c L8024CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516367.75528815
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 8, column 123.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 69.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 11, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 13, column 22.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 58.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 18, column 54.  Encountered: "\n" (10), after : "\"\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a515f6e0a L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516386.4928571
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 559066043 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516386.4928572
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e6b8a4587 L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739516386.4928573
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f9bb0804f L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSInstrucCode1739516386.4928574
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at da1184a3f L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSFewShotCode1739516386.4928575
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ae1fa7c5a L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739516386.4928576
----------------- Refactoring process has started .... -----------------
----------------- defineImplicitLabel is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at bd509a53b L9806CONSOLIDATE_DUPLICATE_COND_FRAGMENTSRulesCode1739516386.4928577
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- addTransition is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9394cf809 L1506CONSOLIDATE_COND_EXPRESSIONFewShotCode1739516518.1224944
----------------- Refactoring process has started .... -----------------
----------------- addTransition is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f2fdc2923 L1506CONSOLIDATE_COND_EXPRESSIONContextCode1739516518.1224945
----------------- Refactoring process has started .... -----------------
=================== is_refactored ===================  1
Refactoring failed
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 87.  Encountered: "\n" (10), after : "\"ATN state %d has both epsilon and non-epsilon transitions.\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4384)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 9a1b650f0 L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516551.5352334
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 84.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_scan_token(GeneratedJavaParser.java:10536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_112(GeneratedJavaParser.java:9553)
  com.github.javaparser.GeneratedJavaParser.jj_3R_208(GeneratedJavaParser.java:9652)
  com.github.javaparser.GeneratedJavaParser.jj_3R_171(GeneratedJavaParser.java:9677)
  com.github.javaparser.GeneratedJavaParser.jj_3R_398(GeneratedJavaParser.java:9780)
  com.github.javaparser.GeneratedJavaParser.jj_3R_394(GeneratedJavaParser.java:9863)
  com.github.javaparser.GeneratedJavaParser.jj_3R_392(GeneratedJavaParser.java:9971)
  com.github.javaparser.GeneratedJavaParser.jj_3R_389(GeneratedJavaParser.java:10086)
  com.github.javaparser.GeneratedJavaParser.jj_3R_381(GeneratedJavaParser.java:10147)
  com.github.javaparser.GeneratedJavaParser.jj_3R_371(GeneratedJavaParser.java:10251)
  com.github.javaparser.GeneratedJavaParser.jj_3R_354(GeneratedJavaParser.java:10276)
  com.github.javaparser.GeneratedJavaParser.jj_3R_330(GeneratedJavaParser.java:10338)
  com.github.javaparser.GeneratedJavaParser.jj_3R_302(GeneratedJavaParser.java:10367)
  com.github.javaparser.GeneratedJavaParser.jj_3R_250(GeneratedJavaParser.java:6449)
  com.github.javaparser.GeneratedJavaParser.jj_3R_201(GeneratedJavaParser.java:6500)
  com.github.javaparser.GeneratedJavaParser.jj_3R_150(GeneratedJavaParser.java:6536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_92(GeneratedJavaParser.java:6960)
  com.github.javaparser.GeneratedJavaParser.jj_3R_267(GeneratedJavaParser.java:7794)
  com.github.javaparser.GeneratedJavaParser.jj_3R_215(GeneratedJavaParser.java:7816)
  com.github.javaparser.GeneratedJavaParser.jj_3R_184(GeneratedJavaParser.java:7832)
  com.github.javaparser.GeneratedJavaParser.jj_3R_257(GeneratedJavaParser.java:8209)
  com.github.javaparser.GeneratedJavaParser.jj_3R_206(GeneratedJavaParser.java:8271)
  com.github.javaparser.GeneratedJavaParser.jj_3R_163(GeneratedJavaParser.java:8327)
  com.github.javaparser.GeneratedJavaParser.jj_3R_101(GeneratedJavaParser.java:8376)
  com.github.javaparser.GeneratedJavaParser.jj_3_37(GeneratedJavaParser.java:8419)
  com.github.javaparser.GeneratedJavaParser.jj_3R_100(GeneratedJavaParser.java:8455)
  com.github.javaparser.GeneratedJavaParser.jj_3_31(GeneratedJavaParser.java:8952)
  com.github.javaparser.GeneratedJavaParser.jj_3R_212(GeneratedJavaParser.java:9080)
  com.github.javaparser.GeneratedJavaParser.jj_3R_305(GeneratedJavaParser.java:9319)
  com.github.javaparser.GeneratedJavaParser.jj_3R_254(GeneratedJavaParser.java:9243)
  com.github.javaparser.GeneratedJavaParser.jj_3R_203(GeneratedJavaParser.java:9383)
  com.github.javaparser.GeneratedJavaParser.jj_3R_211(GeneratedJavaParser.java:9570)
  com.github.javaparser.GeneratedJavaParser.jj_3R_171(GeneratedJavaParser.java:9683)
  com.github.javaparser.GeneratedJavaParser.jj_3R_398(GeneratedJavaParser.java:9780)
  com.github.javaparser.GeneratedJavaParser.jj_3R_394(GeneratedJavaParser.java:9863)
  com.github.javaparser.GeneratedJavaParser.jj_3R_392(GeneratedJavaParser.java:9971)
  com.github.javaparser.GeneratedJavaParser.jj_3R_389(GeneratedJavaParser.java:10086)
  com.github.javaparser.GeneratedJavaParser.jj_3R_381(GeneratedJavaParser.java:10147)
  com.github.javaparser.GeneratedJavaParser.jj_3R_371(GeneratedJavaParser.java:10251)
  com.github.javaparser.GeneratedJavaParser.jj_3R_354(GeneratedJavaParser.java:10276)
  com.github.javaparser.GeneratedJavaParser.jj_3R_330(GeneratedJavaParser.java:10338)
  com.github.javaparser.GeneratedJavaParser.jj_3R_302(GeneratedJavaParser.java:10367)
  com.github.javaparser.GeneratedJavaParser.jj_3R_250(GeneratedJavaParser.java:6449)
  com.github.javaparser.GeneratedJavaParser.jj_3R_201(GeneratedJavaParser.java:6500)
  com.github.javaparser.GeneratedJavaParser.jj_3R_150(GeneratedJavaParser.java:6536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_92(GeneratedJavaParser.java:6960)
  com.github.javaparser.GeneratedJavaParser.jj_3R_307(GeneratedJavaParser.java:6528)
  com.github.javaparser.GeneratedJavaParser.jj_3R_150(GeneratedJavaParser.java:6539)
  com.github.javaparser.GeneratedJavaParser.jj_3R_92(GeneratedJavaParser.java:6960)
  com.github.javaparser.GeneratedJavaParser.jj_3R_125(GeneratedJavaParser.java:9171)
  com.github.javaparser.GeneratedJavaParser.jj_3R_80(GeneratedJavaParser.java:9224)
  com.github.javaparser.GeneratedJavaParser.jj_3R_174(GeneratedJavaParser.java:9201)
  com.github.javaparser.GeneratedJavaParser.jj_3R_114(GeneratedJavaParser.java:9364)
  com.github.javaparser.GeneratedJavaParser.jj_3R_111(GeneratedJavaParser.java:7074)
  com.github.javaparser.GeneratedJavaParser.jj_3_43(GeneratedJavaParser.java:7085)
  com.github.javaparser.GeneratedJavaParser.jj_2_43(GeneratedJavaParser.java:6283)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3894)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at cc7d496b1 L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516551.5352336
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e034ccc23 L1991REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516551.5352337
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f8ca167f3 L19910INTRODUCE_NULL_OBJECTZeroShotCode1739516559.76811
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1dd980c13 L19910INTRODUCE_NULL_OBJECTZeroShotCode1739516559.76812
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 50.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0fcebf60c L19910INTRODUCE_NULL_OBJECTInstrucCode1739516559.76814
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e2b57b385 L19910INTRODUCE_NULL_OBJECTInstrucCode1739516559.76815
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 3, column 55.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 2bf0fa01f L19910INTRODUCE_NULL_OBJECTInstrucCode1739516559.76817
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 08838c049 L19910INTRODUCE_NULL_OBJECTContextCode1739516559.76819
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 5, column 59.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 960301285 L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768111
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at e7df65e30 L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768112
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 10ae493f7 L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768113
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 3d480820a L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768114
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f1445014d L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768115
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f1122715b L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768116
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6642fa655 L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768117
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 07bce6255 L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768118
----------------- Refactoring process has started .... -----------------
----------------- closure is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at f6aeb15ac L19910INTRODUCE_NULL_OBJECTContextCode1739516559.768119
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 9, column 63.  Encountered: "\n" (10), after : "\"closure at %s rule stop %s\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.Arguments(GeneratedJavaParser.java:3471)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffixWithoutSuper(GeneratedJavaParser.java:3360)
  com.github.javaparser.GeneratedJavaParser.PrimarySuffix(GeneratedJavaParser.java:3309)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:3001)
  com.github.javaparser.GeneratedJavaParser.StatementExpression(GeneratedJavaParser.java:4114)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3776)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4379)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at eb71e787e L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739516594.208161
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a323b3865 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESInstrucCode1739516594.208162
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0eff1ac51 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESFewShotCode1739516594.208163
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6ca059b9d L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516594.208164
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0ff9fabad L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516594.208165
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a603de1ff L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516594.208166
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c6740470b L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739516594.208167
----------------- Refactoring process has started .... -----------------
----------------- _LOOK is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 862de1cd4 L2113REPLACE_NESTED_COND_WITH_GUARD_CLAUSESRulesCode1739516594.208168
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 1b915f853 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739517704.5892571
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 066214121 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESInstrucCode1739517704.5892572
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at ea99db4f9 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESFewShotCode1739517704.5892573
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 598f8ccd1 L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739517704.5892574
----------------- Refactoring process has started .... -----------------
----------------- closure_ is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6b685eecd L2427REPLACE_NESTED_COND_WITH_GUARD_CLAUSESRulesCode1739517704.5892575
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7849c6840 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739519758.1368561
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 7915c74e8 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739519758.1368562
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 17298279d L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSZeroShotCode1739519758.1368563
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c328fb01b L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739519758.1368564
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 66903ee56 L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739519758.1368565
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at fa46ca2dc L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739519758.1368566
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 456e75baf L9795CONSOLIDATE_DUPLICATE_COND_FRAGMENTSContextCode1739519758.1368567
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 4681f8c93 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739523640.921351
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at db848e67c L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739523640.921352
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 6, column 41.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2511)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4376)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3731)
  com.github.javaparser.GeneratedJavaParser.ForStatement(GeneratedJavaParser.java:4669)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3796)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
=================== is_refactored ===================  1
Refactoring failed
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 4, column 17.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_scan_token(GeneratedJavaParser.java:10536)
  com.github.javaparser.GeneratedJavaParser.jj_3R_163(GeneratedJavaParser.java:8320)
  com.github.javaparser.GeneratedJavaParser.jj_3R_101(GeneratedJavaParser.java:8376)
  com.github.javaparser.GeneratedJavaParser.jj_3_37(GeneratedJavaParser.java:8419)
  com.github.javaparser.GeneratedJavaParser.jj_3R_100(GeneratedJavaParser.java:8455)
  com.github.javaparser.GeneratedJavaParser.jj_3_31(GeneratedJavaParser.java:8952)
  com.github.javaparser.GeneratedJavaParser.jj_2_31(GeneratedJavaParser.java:6187)
  com.github.javaparser.GeneratedJavaParser.PrimaryExpression(GeneratedJavaParser.java:2996)
  com.github.javaparser.GeneratedJavaParser.PostfixExpression(GeneratedJavaParser.java:2894)
  com.github.javaparser.GeneratedJavaParser.UnaryExpressionNotPlusMinus(GeneratedJavaParser.java:2875)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2777)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2482)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.ReturnStatement(GeneratedJavaParser.java:4884)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3808)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8742015ca L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESZeroShotCode1739523640.921355
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 56b87b6e8 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739523640.921356
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 0d539a140 L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739523640.921357
----------------- Refactoring process has started .... -----------------
Exception in thread "main" com.github.javaparser.ParseProblemException: Lexical error at line 2, column 33.  Encountered: "\'" (39), after : "\\"
Problem stacktrace :
  com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:3003)
  com.github.javaparser.GeneratedJavaParser.jj_ntk_f(GeneratedJavaParser.java:10575)
  com.github.javaparser.GeneratedJavaParser.UnaryExpression(GeneratedJavaParser.java:2706)
  com.github.javaparser.GeneratedJavaParser.MultiplicativeExpression(GeneratedJavaParser.java:2662)
  com.github.javaparser.GeneratedJavaParser.AdditiveExpression(GeneratedJavaParser.java:2624)
  com.github.javaparser.GeneratedJavaParser.ShiftExpression(GeneratedJavaParser.java:2588)
  com.github.javaparser.GeneratedJavaParser.RelationalExpression(GeneratedJavaParser.java:2538)
  com.github.javaparser.GeneratedJavaParser.InstanceOfExpression(GeneratedJavaParser.java:2520)
  com.github.javaparser.GeneratedJavaParser.EqualityExpression(GeneratedJavaParser.java:2511)
  com.github.javaparser.GeneratedJavaParser.AndExpression(GeneratedJavaParser.java:2460)
  com.github.javaparser.GeneratedJavaParser.ExclusiveOrExpression(GeneratedJavaParser.java:2439)
  com.github.javaparser.GeneratedJavaParser.InclusiveOrExpression(GeneratedJavaParser.java:2418)
  com.github.javaparser.GeneratedJavaParser.ConditionalAndExpression(GeneratedJavaParser.java:2397)
  com.github.javaparser.GeneratedJavaParser.ConditionalOrExpression(GeneratedJavaParser.java:2376)
  com.github.javaparser.GeneratedJavaParser.ConditionalExpression(GeneratedJavaParser.java:2357)
  com.github.javaparser.GeneratedJavaParser.Expression(GeneratedJavaParser.java:2191)
  com.github.javaparser.GeneratedJavaParser.IfStatement(GeneratedJavaParser.java:4376)
  com.github.javaparser.GeneratedJavaParser.Statement(GeneratedJavaParser.java:3784)
  com.github.javaparser.GeneratedJavaParser.BlockStatement(GeneratedJavaParser.java:3953)
  com.github.javaparser.GeneratedJavaParser.Statements(GeneratedJavaParser.java:1659)
  com.github.javaparser.GeneratedJavaParser.Block(GeneratedJavaParser.java:3871)
  com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1264)
  com.github.javaparser.GeneratedJavaParser.MethodDeclarationParseStart(GeneratedJavaParser.java:5939)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parseMethodDeclaration(JavaParser.java:539)
  com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
  org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
  org.refactoring.CodeModifier.main(CodeModifier.java:67)

	at com.github.javaparser.StaticJavaParser.handleResult(StaticJavaParser.java:260)
	at com.github.javaparser.StaticJavaParser.parseMethodDeclaration(StaticJavaParser.java:480)
	at org.refactoring.CodeModifier.codeModifier(CodeModifier.java:32)
	at org.refactoring.CodeModifier.main(CodeModifier.java:67)
=================== is_refactored ===================  1
Refactoring failed
----------------- Refactoring process has started .... -----------------
 -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c11ae794c L9861REPLACE_NESTED_COND_WITH_GUARD_CLAUSESContextCode1739523640.921359
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8d75ea3bb L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTZeroShotCode1739526774.9290591
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int execute() {
        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class CalculateHashCodeCommand {

        private final int parentHashCode;

        private final int returnStateHashCode;

        public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 6cdf047c6 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTInstrucCode1739526774.9290592
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
        return new CalculateHashCodeCommand(parentHashCode, returnStateHashCode).execute();
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class CalculateHashCodeCommand {

        private final int parentHashCode;

        private final int returnStateHashCode;

        public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 8bcbb8b1a L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTInstrucCode1739526774.9290593
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
        return new HashCodeCalculator(parentHashCode, returnStateHashCode).execute();
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        private int parentHashCode;

        private int returnStateHashCode;

        private int result;

        public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
            return result;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 977cda704 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTFewShotCode1739526774.9290594
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    public int execute() {
        result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        return result;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        private int parentHashCode;

        private int returnStateHashCode;

        private int result;

        public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {
            this.parentHashCode = parentHashCode;
            this.returnStateHashCode = returnStateHashCode;
        }

        public int execute() {
            result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
            return result;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at a9a3981d0 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTFewShotCode1739526774.9290595
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at c7f2e7470 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTContextCode1739526774.9290596
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
        return HashCodeCalculator.calculate(parentHashCode, returnStateHashCode);
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        public static int calculate(int parentHashCode, int returnStateHashCode) {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 94261e157 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTRulesCode1739526774.9290597
----------------- Refactoring process has started .... -----------------
----------------- calculateHashCode is refactoring ---------------------------------- Inner class added to public abstract class PredictionContext implements Iterable<SingletonPredictionContext>, // to sort node lists by id
Comparable<PredictionContext> {

    /**
     * Represents {@code $} in local context prediction, which means wildcard.
     * {@code *+x = *}.
     */
    public static final EmptyPredictionContext EMPTY = new EmptyPredictionContext();

    /**
     * Represents {@code $} in an array in full context mode, when {@code $}
     * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
     * {@code $} = {@link #EMPTY_RETURN_STATE}.
     */
    public static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;

    public static int globalNodeCount = 0;

    public final int id = globalNodeCount++;

    public final int cachedHashCode;

    protected PredictionContext(int cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }

    /**
     * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
     *  Return {@link #EMPTY} if {@code outerContext} is empty or null.
     */
    public static PredictionContext fromRuleContext(@NotNull ATN atn, RuleContext outerContext) {
        if (outerContext == null)
            outerContext = RuleContext.EMPTY;
        // if we are in RuleContext of start rule, s, then PredictionContext
        // is EMPTY. Nobody called us. (if we are empty, return empty)
        if (outerContext.parent == null || outerContext == RuleContext.EMPTY) {
            return PredictionContext.EMPTY;
        }
        // If we have a parent, convert it to a PredictionContext graph
        PredictionContext parent = EMPTY;
        if (outerContext.parent != null) {
            parent = PredictionContext.fromRuleContext(atn, outerContext.parent);
        }
        ATNState state = atn.states.get(outerContext.invokingState);
        RuleTransition transition = (RuleTransition) state.transition(0);
        return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
    }

    @Override
    public abstract Iterator<SingletonPredictionContext> iterator();

    public abstract int size();

    public abstract PredictionContext getParent(int index);

    public abstract int getReturnState(int index);

    /**
     * This means only the {@link #EMPTY} context is in set.
     */
    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasEmptyPath() {
        return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
    }

    @Override
    public int compareTo(PredictionContext o) {
        // used for toDotString to print nodes in order
        return id - o.id;
    }

    @Override
    public int hashCode() {
        return cachedHashCode;
    }

    static int calculate(int parentHashCode, int returnStateHashCode) {
        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
    }

    // dispatch
    public static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        // share same graph if both same
        if ((a == null && b == null) || a == b || (a != null && a.equals(b)))
            return a;
        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);
        }
        // At least one of a or b is array
        // If one is $ and rootIsWildcard, return $ as * wildcard
        if (rootIsWildcard) {
            if (a instanceof EmptyPredictionContext)
                return a;
            if (b instanceof EmptyPredictionContext)
                return b;
        }
        // convert singleton so both are arrays to normalize
        if (a instanceof SingletonPredictionContext) {
            a = new ArrayPredictionContext((SingletonPredictionContext) a);
        }
        if (b instanceof SingletonPredictionContext) {
            b = new ArrayPredictionContext((SingletonPredictionContext) b);
        }
        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);
    }

    /**
     * Merge two {@link SingletonPredictionContext} instances.
     *
     * <p/>
     *
     * Stack tops equal, parents merge is same; return left graph.<br/>
     * <embed src="images/SingletonMerge_SameRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Same stack top, parents differ; merge parents giving array node, then
     * remainders of those graphs. A new root node is created to point to the
     * merged parents.<br/>
     * <embed src="images/SingletonMerge_SameRootDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to same parent. Make array node for the
     * root where both element in the root point to the same (original)
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Different stack tops pointing to different parents. Make array node for
     * the root where each element points to the corresponding original
     * parent.<br/>
     * <embed src="images/SingletonMerge_DiffRootDiffPar.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     * @param mergeCache
     * @return
     */
    public static PredictionContext mergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        PredictionContext rootMerge = mergeRoot(a, b, rootIsWildcard);
        if (rootMerge != null) {
            if (mergeCache != null)
                mergeCache.put(a, b, rootMerge);
            return rootMerge;
        }
        if (a.returnState == b.returnState) {
            // a == b
            PredictionContext parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
            // if parent is same as existing a or b parent or reduced to a parent, return it
            // ax + bx = ax, if a=b
            if (parent == a.parent)
                return a;
            // ax + bx = bx, if a=b
            if (parent == b.parent)
                return b;
            // else: ax + ay = a'[x,y]
            // merge parents x and y, giving array node with x,y then remainders
            // of those graphs.  dup a, a' points at merged array
            // new joined parent so create new singleton pointing to it, a'
            PredictionContext a_ = SingletonPredictionContext.create(parent, a.returnState);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        } else {
            // a != b payloads differ
            // see if we can collapse parents due to $+x parents if local ctx
            PredictionContext singleParent = null;
            if (a == b || (a.parent != null && a.parent.equals(b.parent))) {
                // ax + bx = [a,b]x
                singleParent = a.parent;
            }
            if (singleParent != null) {
                // parents are same
                // sort payloads and use same parent
                int[] payloads = { a.returnState, b.returnState };
                if (a.returnState > b.returnState) {
                    payloads[0] = b.returnState;
                    payloads[1] = a.returnState;
                }
                PredictionContext[] parents = { singleParent, singleParent };
                PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            // parents differ and can't merge them. Just pack together
            // into array; can't merge.
            // ax + by = [ax,by]
            int[] payloads = { a.returnState, b.returnState };
            PredictionContext[] parents = { a.parent, b.parent };
            if (a.returnState > b.returnState) {
                // sort by payload
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
                parents = new PredictionContext[] { b.parent, a.parent };
            }
            PredictionContext a_ = new ArrayPredictionContext(parents, payloads);
            if (mergeCache != null)
                mergeCache.put(a, b, a_);
            return a_;
        }
    }

    /**
     * Handle case where at least one of {@code a} or {@code b} is
     * {@link #EMPTY}. In the following diagrams, the symbol {@code $} is used
     * to represent {@link #EMPTY}.
     *
     * <h2>Local-Context Merges</h2>
     *
     * These local-context merge operations are used when {@code rootIsWildcard}
     * is true.
     *
     * <p/>
     *
     * {@link #EMPTY} is superset of any graph; return {@link #EMPTY}.<br/>
     * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * {@link #EMPTY} and anything is {@code #EMPTY}, so merged parent is
     * {@code #EMPTY}; return left graph.<br/>
     * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Special case of last merge if local context.<br/>
     * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/>
     *
     * <h2>Full-Context Merges</h2>
     *
     * These full-context merge operations are used when {@code rootIsWildcard}
     * is false.
     *
     * <p/>
     *
     * <embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Must keep all contexts; {@link #EMPTY} in array is a special value (and
     * null parent).<br/>
     * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * <embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/>
     *
     * @param a the first {@link SingletonPredictionContext}
     * @param b the second {@link SingletonPredictionContext}
     * @param rootIsWildcard {@code true} if this is a local-context merge,
     * otherwise false to indicate a full-context merge
     */
    public static PredictionContext mergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, boolean rootIsWildcard) {
        if (rootIsWildcard) {
            // * + b = *
            if (a == EMPTY)
                return EMPTY;
            // a + * = *
            if (b == EMPTY)
                return EMPTY;
        } else {
            // $ + $ = $
            if (a == EMPTY && b == EMPTY)
                return EMPTY;
            if (a == EMPTY) {
                // $ + x = [$,x]
                int[] payloads = { b.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { b.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
            if (b == EMPTY) {
                // x + $ = [$,x] ($ is always first if present)
                int[] payloads = { a.returnState, EMPTY_RETURN_STATE };
                PredictionContext[] parents = { a.parent, null };
                PredictionContext joined = new ArrayPredictionContext(parents, payloads);
                return joined;
            }
        }
        return null;
    }

    /**
     * Merge two {@link ArrayPredictionContext} instances.
     *
     * <p/>
     *
     * Different tops, different parents.<br/>
     * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, same parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, different parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Shared top, all shared parents.<br/>
     * <embed src="images/ArrayMerge_ShareTopSharePar.svg" type="image/svg+xml"/>
     *
     * <p/>
     *
     * Equal tops, merge parents and reduce top to
     * {@link SingletonPredictionContext}.<br/>
     * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/>
     */
    public static PredictionContext mergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {
        if (mergeCache != null) {
            PredictionContext previous = mergeCache.get(a, b);
            if (previous != null)
                return previous;
            previous = mergeCache.get(b, a);
            if (previous != null)
                return previous;
        }
        // merge sorted payloads a + b => M
        // walks a
        int i = 0;
        // walks b
        int j = 0;
        // walks target M array
        int k = 0;
        int[] mergedReturnStates = new int[a.returnStates.length + b.returnStates.length];
        PredictionContext[] mergedParents = new PredictionContext[a.returnStates.length + b.returnStates.length];
        // walk and merge to yield mergedParents, mergedReturnStates
        while (i < a.returnStates.length && j < b.returnStates.length) {
            PredictionContext a_parent = a.parents[i];
            PredictionContext b_parent = b.parents[j];
            if (a.returnStates[i] == b.returnStates[j]) {
                // same payload (stack tops are equal), must yield merged singleton
                int payload = a.returnStates[i];
                // $+$ = $
                boolean both$ = payload == EMPTY_RETURN_STATE && a_parent == null && b_parent == null;
                boolean ax_ax = (a_parent != null && b_parent != null) && // ax+ax -> ax
                a_parent.equals(b_parent);
                if (both$ || ax_ax) {
                    // choose left
                    mergedParents[k] = a_parent;
                    mergedReturnStates[k] = payload;
                } else {
                    // ax+ay -> a'[x,y]
                    PredictionContext mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                    mergedParents[k] = mergedParent;
                    mergedReturnStates[k] = payload;
                }
                // hop over left one as usual
                i++;
                // but also skip one in right side since we merge
                j++;
            } else if (a.returnStates[i] < b.returnStates[j]) {
                // copy a[i] to M
                mergedParents[k] = a_parent;
                mergedReturnStates[k] = a.returnStates[i];
                i++;
            } else {
                // b > a, copy b[j] to M
                mergedParents[k] = b_parent;
                mergedReturnStates[k] = b.returnStates[j];
                j++;
            }
            k++;
        }
        // copy over any payloads remaining in either array
        if (i < a.returnStates.length) {
            for (int p = i; p < a.returnStates.length; p++) {
                mergedParents[k] = a.parents[p];
                mergedReturnStates[k] = a.returnStates[p];
                k++;
            }
        } else {
            for (int p = j; p < b.returnStates.length; p++) {
                mergedParents[k] = b.parents[p];
                mergedReturnStates[k] = b.returnStates[p];
                k++;
            }
        }
        // trim merged if we combined a few that had same stack tops
        if (k < mergedParents.length) {
            // write index < last position; trim
            if (k == 1) {
                // for just one merged element, return singleton top
                PredictionContext a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
                if (mergeCache != null)
                    mergeCache.put(a, b, a_);
                return a_;
            }
            mergedParents = Arrays.copyOf(mergedParents, k);
            mergedReturnStates = Arrays.copyOf(mergedReturnStates, k);
        }
        PredictionContext M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
        // if we created same array as a or b, return that instead
        // TODO: track whether this is possible above during merge sort for speed
        if (M.equals(a)) {
            if (mergeCache != null)
                mergeCache.put(a, b, a);
            return a;
        }
        if (M.equals(b)) {
            if (mergeCache != null)
                mergeCache.put(a, b, b);
            return b;
        }
        combineCommonParents(mergedParents);
        if (mergeCache != null)
            mergeCache.put(a, b, M);
        return M;
    }

    /**
     * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
     * ones.
     */
    protected static void combineCommonParents(PredictionContext[] parents) {
        Map<PredictionContext, PredictionContext> uniqueParents = new HashMap<PredictionContext, PredictionContext>();
        for (int p = 0; p < parents.length; p++) {
            PredictionContext parent = parents[p];
            if (!uniqueParents.containsKey(parent)) {
                // don't replace
                uniqueParents.put(parent, parent);
            }
        }
        for (int p = 0; p < parents.length; p++) {
            parents[p] = uniqueParents.get(parents[p]);
        }
    }

    public static String toDOTString(PredictionContext context) {
        if (context == null)
            return "";
        StringBuilder buf = new StringBuilder();
        buf.append("digraph G {\n");
        buf.append("rankdir=LR;\n");
        List<PredictionContext> nodes = getAllContextNodes(context);
        Collections.sort(nodes);
        for (PredictionContext current : nodes) {
            if (current instanceof SingletonPredictionContext) {
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                String returnState = String.valueOf(current.getReturnState(0));
                if (current instanceof EmptyPredictionContext)
                    returnState = "$";
                buf.append(" [label=\"").append(returnState).append("\"];\n");
                continue;
            }
            ArrayPredictionContext arr = (ArrayPredictionContext) current;
            buf.append("  s").append(arr.id);
            buf.append(" [shape=box, label=\"");
            buf.append("[");
            boolean first = true;
            for (int inv : arr.returnStates) {
                if (!first)
                    buf.append(", ");
                if (inv == EMPTY_RETURN_STATE)
                    buf.append("$");
                else
                    buf.append(inv);
                first = false;
            }
            buf.append("]");
            buf.append("\"];\n");
        }
        for (PredictionContext current : nodes) {
            if (current == EMPTY)
                continue;
            for (int i = 0; i < current.size(); i++) {
                if (current.getParent(i) == null)
                    continue;
                String s = String.valueOf(current.id);
                buf.append("  s").append(s);
                buf.append("->");
                buf.append("s");
                buf.append(current.getParent(i).id);
                if (current.size() > 1)
                    buf.append(" [label=\"parent[" + i + "]\"];\n");
                else
                    buf.append(";\n");
            }
        }
        buf.append("}\n");
        return buf.toString();
    }

    // From Sam
    public static PredictionContext getCachedContext(@NotNull PredictionContext context, @NotNull PredictionContextCache contextCache, @NotNull IdentityHashMap<PredictionContext, PredictionContext> visited) {
        if (context.isEmpty()) {
            return context;
        }
        PredictionContext existing = visited.get(context);
        if (existing != null) {
            return existing;
        }
        synchronized (contextCache) {
            existing = contextCache.get(context);
            if (existing != null) {
                visited.put(context, existing);
                return existing;
            }
        }
        boolean changed = false;
        PredictionContext[] parents = new PredictionContext[context.size()];
        for (int i = 0; i < parents.length; i++) {
            PredictionContext parent = getCachedContext(context.getParent(i), contextCache, visited);
            if (changed || parent != context.getParent(i)) {
                if (!changed) {
                    parents = new PredictionContext[context.size()];
                    for (int j = 0; j < context.size(); j++) {
                        parents[j] = context.getParent(j);
                    }
                    changed = true;
                }
                parents[i] = parent;
            }
        }
        if (!changed) {
            synchronized (contextCache) {
                contextCache.add(context);
            }
            visited.put(context, context);
            return context;
        }
        PredictionContext updated;
        if (parents.length == 0) {
            updated = EMPTY;
        } else if (parents.length == 1) {
            updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
        } else {
            ArrayPredictionContext arrayPredictionContext = (ArrayPredictionContext) context;
            updated = new ArrayPredictionContext(parents, arrayPredictionContext.returnStates);
        }
        synchronized (contextCache) {
            contextCache.add(updated);
        }
        visited.put(updated, updated);
        visited.put(context, updated);
        return updated;
    }

    // // extra structures, but cut/paste/morphed works, so leave it.
    // // seems to do a breadth-first walk
    // public static List<PredictionContext> getAllNodes(PredictionContext context) {
    // Map<PredictionContext, PredictionContext> visited =
    // new IdentityHashMap<PredictionContext, PredictionContext>();
    // Deque<PredictionContext> workList = new ArrayDeque<PredictionContext>();
    // workList.add(context);
    // visited.put(context, context);
    // List<PredictionContext> nodes = new ArrayList<PredictionContext>();
    // while (!workList.isEmpty()) {
    // PredictionContext current = workList.pop();
    // nodes.add(current);
    // for (int i = 0; i < current.size(); i++) {
    // PredictionContext parent = current.getParent(i);
    // if ( parent!=null && visited.put(parent, parent) == null) {
    // workList.push(parent);
    // }
    // }
    // }
    // return nodes;
    // }
    // ter's recursive version of Sam's getAllNodes()
    public static List<PredictionContext> getAllContextNodes(PredictionContext context) {
        List<PredictionContext> nodes = new ArrayList<PredictionContext>();
        Map<PredictionContext, PredictionContext> visited = new IdentityHashMap<PredictionContext, PredictionContext>();
        getAllContextNodes_(context, nodes, visited);
        return nodes;
    }

    public static void getAllContextNodes_(PredictionContext context, List<PredictionContext> nodes, Map<PredictionContext, PredictionContext> visited) {
        if (context == null || visited.containsKey(context))
            return;
        visited.put(context, context);
        nodes.add(context);
        for (int i = 0; i < context.size(); i++) {
            getAllContextNodes_(context.getParent(i), nodes, visited);
        }
    }

    public String toString(@Nullable Recognizer<?, ?> recog) {
        return toString();
    // return toString(recog, ParserRuleContext.EMPTY);
    }

    // recog null unless ParserRuleContext, in which case we use subclass toString(...)
    public String toString(@Nullable Recognizer<?, ?> recog, RuleContext stop) {
        StringBuilder buf = new StringBuilder();
        PredictionContext p = this;
        buf.append("[");
        // while ( p != null && p != stop ) {
        // if ( !p.isEmpty() ) buf.append(p.returnState);
        // if ( p.parent != null && !p.parent.isEmpty() ) buf.append(" ");
        // p = p.parent;
        // }
        buf.append("]");
        return buf.toString();
    }

    public String[] toStrings(Recognizer<?, ?> recognizer, int currentState) {
        return toStrings(recognizer, EMPTY, currentState);
    }

    // FROM SAM
    public String[] toStrings(Recognizer<?, ?> recognizer, PredictionContext stop, int currentState) {
        List<String> result = new ArrayList<String>();
        outer: for (int perm = 0; ; perm++) {
            int offset = 0;
            boolean last = true;
            PredictionContext p = this;
            int stateNumber = currentState;
            StringBuilder localBuffer = new StringBuilder();
            localBuffer.append("[");
            while (!p.isEmpty() && p != stop) {
                int index = 0;
                if (p.size() > 0) {
                    int bits = 1;
                    while ((1 << bits) < p.size()) {
                        bits++;
                    }
                    int mask = (1 << bits) - 1;
                    index = (perm >> offset) & mask;
                    last &= index >= p.size() - 1;
                    if (index >= p.size()) {
                        continue outer;
                    }
                    offset += bits;
                }
                if (recognizer != null) {
                    if (localBuffer.length() > 1) {
                        // first char is '[', if more than that this isn't the first rule
                        localBuffer.append(' ');
                    }
                    ATN atn = recognizer.getATN();
                    ATNState s = atn.states.get(stateNumber);
                    String ruleName = recognizer.getRuleNames()[s.ruleIndex];
                    localBuffer.append(ruleName);
                } else if (p.getReturnState(index) != EMPTY_RETURN_STATE) {
                    if (!p.isEmpty()) {
                        if (localBuffer.length() > 1) {
                            // first char is '[', if more than that this isn't the first rule
                            localBuffer.append(' ');
                        }
                        localBuffer.append(p.getReturnState(index));
                    }
                }
                stateNumber = p.getReturnState(index);
                p = p.getParent(index);
            }
            localBuffer.append("]");
            result.add(localBuffer.toString());
            if (last) {
                break;
            }
        }
        return result.toArray(new String[result.size()]);
    }

    class HashCodeCalculator {

        public static int calculate(int parentHashCode, int returnStateHashCode) {
            return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
        }
    }
} ----------------- -------------------------- Refactoring process terminated .... ---------------------------
=================== is_refactored ===================  0
HEAD is now at 75b2e7733 L2588REPLACE_MAGIC_NUMBER_WITH_CONSTANTRulesCode1739526774.9290598

Process finished with exit code 0
