ID,Parent,commitID_before,commitID_after,Project,Type,Fowler_type,path_before,path_after,name,LongName,b_StartLine,b_StartColumn,b_EndLine,b_EndColumn,a_StartLine,a_StartColumn,a_EndLine,a_EndColumn,BeforeRefact,AfterRefact,Extra
L10937,L8817,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,tool\src\org\antlr\v4\codegen\ParserFactory.java,tool\src\org\antlr\v4\codegen\ParserFactory.java,"List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert)",org.antlr.v4.codegen.ParserFactory.set(Lorg/antlr/v4/tool/ast/GrammarAST;Lorg/antlr/v4/tool/ast/GrammarAST;Z)Ljava/util/List;,,,,,178,2,199,3,"
	public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
		MatchSet matchOp;
		if ( invert ) matchOp = new MatchNotSet(this, setAST);
		else matchOp = new MatchSet(this, setAST);
		if ( labelAST!=null ) {
			String label = labelAST.getText();
			Decl d = getTokenLabelDecl(label);
			matchOp.labels.add(d);
			getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {
				TokenListDecl l = getTokenListLabelDecl(label);
				getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);
			}
		}
		if ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);
		AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);
		return list(matchOp, listLabelOp);
	}","public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
		MatchSet matchOp;
		if ( invert ) matchOp = new MatchNotSet(this, setAST);
		else matchOp = new MatchSet(this, setAST);
		if ( labelAST!=null ) {
			String label = labelAST.getText();
			RuleFunction rf = getCurrentRuleFunction();
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {
				defineImplicitLabel(setAST, matchOp);
				TokenListDecl l = getTokenListLabelDecl(label);
				rf.addContextDecl(setAST.getAltLabel(), l);
			}
			else {
				Decl d = getTokenLabelDecl(label);
				matchOp.labels.add(d);
				rf.addContextDecl(setAST.getAltLabel(), d);
			}
		}
		if ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);
		AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);
		return list(matchOp, listLabelOp);
	}",
L5343,L543,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\Parser.java,runtime\Java\src\org\antlr\v4\runtime\Parser.java,List<ParseTreeListener> getParseListeners(),org.antlr.v4.runtime.Parser.getParseListeners()Ljava/util/List;,,,,,298,2,305,3,"public List<ParseTreeListener> getParseListeners() {
        return _parseListeners;
    }","public List<ParseTreeListener> getParseListeners() {
		List<ParseTreeListener> listeners = _parseListeners;
		if (listeners == null) {
			return Collections.emptyList();
		}

		return listeners;
	}",
L3671,L3660,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,"void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)",org.antlr.v4.runtime.DiagnosticErrorListener.reportAmbiguity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,,,,,89,2,107,3," public void reportAmbiguity(@NotNull Parser recognizer,
								DFA dfa, int startIndex, int stopIndex,
								@NotNull BitSet ambigAlts,
								@NotNull ATNConfigSet configs)
    {
        recognizer.notifyErrorListeners(""reportAmbiguity d="" + dfa.decision +
			"": ambigAlts="" + ambigAlts + "", input='"" +
			recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + ""'"");
    }","public void reportAmbiguity(@NotNull Parser recognizer,
								DFA dfa,
								int startIndex,
								int stopIndex,
								boolean exact,
								@Nullable BitSet ambigAlts,
								@NotNull ATNConfigSet configs)
	{
		if (exactOnly && !exact) {
			return;
		}

		String format = ""reportAmbiguity d=%s: ambigAlts=%s, input='%s'"";
		String decision = getDecisionDescription(recognizer, dfa);
		BitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);
		String text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));
		String message = String.format(format, decision, conflictingAlts, text);
		recognizer.notifyErrorListeners(message);
	}",
L3692,L3660,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_EXPLAINING_VARIABLE,Extract Variable,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\DiagnosticErrorListener.java,"void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs)",org.antlr.v4.runtime.DiagnosticErrorListener.reportContextSensitivity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIILorg/antlr/v4/runtime/atn/ATNConfigSet;)V,,,,,125,2,137,3,"public void reportContextSensitivity(@NotNull Parser recognizer,
										 @NotNull DFA dfa,
                                         int startIndex, int stopIndex,
										 @NotNull ATNConfigSet configs)
    {
        recognizer.notifyErrorListeners(""reportContextSensitivity d="" +
			dfa.decision + "", input='"" +
			recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + ""'"");
    }
}","public void reportContextSensitivity(@NotNull Parser recognizer,
										 @NotNull DFA dfa,
										 int startIndex,
										 int stopIndex,
										 int prediction,
										 @NotNull ATNConfigSet configs)
	{
		String format = ""reportContextSensitivity d=%s, input='%s'"";
		String decision = getDecisionDescription(recognizer, dfa);
		String text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));
		String message = String.format(format, decision, text);
		recognizer.notifyErrorListeners(message);
	}",
L7413,L7392,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,void processParser(),org.antlr.v4.analysis.AnalysisPipeline.processParser()V,,,,,82,2,101,3,"protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}","protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}

			assert s.decision + 1 >= g.decisionLOOK.size();
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}",
L10037,L10036,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\codegen\model\LL1StarBlockSingleAlt.java,tool\src\org\antlr\v4\codegen\model\LL1StarBlockSingleAlt.java,"LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts)",org.antlr.v4.codegen.model.LL1StarBlockSingleAlt.<init>(Lorg/antlr/v4/codegen/OutputModelFactory;Lorg/antlr/v4/tool/ast/GrammarAST;Ljava/util/List;)V,,,,,42,2,53,3,"public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
		super(factory, starRoot, alts);

		StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;
		loopBackStateNumber = star.loopBackState.stateNumber;
		this.decision = star.decision;
		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
		IntervalSet enterLook = altLookSets[1];
		IntervalSet exitLook = altLookSets[2];
		loopExpr = addCodeForLoopLookaheadTempVar(enterLook);
	}","public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
		super(factory, starRoot, alts);

		StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;
		loopBackStateNumber = star.loopBackState.stateNumber;
		this.decision = star.decision;
		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
		assert altLookSets.length == 2;
		IntervalSet enterLook = altLookSets[0];
		IntervalSet exitLook = altLookSets[1];
		loopExpr = addCodeForLoopLookaheadTempVar(enterLook);
	}",
L1927,L1833,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"int execATN(@NotNull CharStream input, @NotNull DFAState ds0)",org.antlr.v4.runtime.atn.LexerATNSimulator. execATN(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;,197,,282,,187,2,302,3,"protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {
		//System.out.println(""enter exec index ""+input.index()+"" from ""+ds0.configs);
		if ( debug ) {
			System.out.format(""start state closure=%s\n"", ds0.configs);
		}

		int t = input.LA(1);
		@NotNull
		DFAState s = ds0; // s is current/from DFA state

		while ( true ) { // while more work
			if ( debug ) {
				System.out.format(""execATN loop starting closure: %s\n"", s.configs);
			}

			// As we move src->trg, src->trg, we keep track of the previous trg to
			// avoid looking up the DFA state again, which is expensive.
			// If the previous target was already part of the DFA, we might
			// be able to avoid doing a reach operation upon t. If s!=null,
			// it means that semantic predicates didn't prevent us from
			// creating a DFA state. Once we know s!=null, we check to see if
			// the DFA state has an edge already for t. If so, we can just reuse
			// it's configuration set; there's no point in re-computing it.
			// This is kind of like doing DFA simulation within the ATN
			// simulation because DFA simulation is really just a way to avoid
			// computing reach/closure sets. Technically, once we know that
			// we have a previously added DFA state, we could jump over to
			// the DFA simulator. But, that would mean popping back and forth
			// a lot and making things more complicated algorithmically.
			// This optimization makes a lot of sense for loops within DFA.
			// A character will take us back to an existing DFA state
			// that already has lots of edges out of it. e.g., .* in comments.
			ATNConfigSet closure = s.configs;
			DFAState target = null;
			if ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {
				target = s.edges[t - MIN_DFA_EDGE];
				if (target == ERROR) {
					break;
				}

				if (debug && target != null) {
					System.out.println(""reuse state ""+s.stateNumber+
									   "" edge to ""+target.stateNumber);
				}
			}

			if (target == null) {
				ATNConfigSet reach = new OrderedATNConfigSet();

				// if we don't find an existing DFA state
				// Fill reach starting from closure, following t transitions
				getReachableConfigSet(input, closure, reach, t);

				if ( reach.isEmpty() ) { // we got nowhere on t from s
					// we reached state associated with closure for sure, so
					// make sure it's defined. worst case, we define s0 from
					// start state configs.
					@NotNull
					DFAState from = s != null ? s : addDFAState(closure);
					// we got nowhere on t, don't throw out this knowledge; it'd
					// cause a failover from DFA later.
					addDFAEdge(from, t, ERROR);
					break; // stop when we can't match any more char
				}

				// Add an edge from s to target DFA found/created for reach
				target = addDFAEdge(s, t, reach);
			}

			if (target.isAcceptState) {
				captureSimState(prevAccept, input, target);
				if (t == IntStream.EOF) {
					break;
				}
			}

			if (t != IntStream.EOF) {
				consume(input);
				t = input.LA(1);
			}

			s = target; // flip; current DFA target becomes new src/from state
		}

		return failOrAccept(prevAccept, input, s.configs, t);
	}","protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {
		//System.out.println(""enter exec index ""+input.index()+"" from ""+ds0.configs);
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""start state closure=%s\n"", ds0.configs);
		}

		int t = input.LA(1);
		@NotNull
		DFAState s = ds0; // s is current/from DFA state

		while ( true ) { // while more work
			if ( debug ) {
				System.out.format(Locale.getDefault(), ""execATN loop starting closure: %s\n"", s.configs);
			}

			// As we move src->trg, src->trg, we keep track of the previous trg to
			// avoid looking up the DFA state again, which is expensive.
			// If the previous target was already part of the DFA, we might
			// be able to avoid doing a reach operation upon t. If s!=null,
			// it means that semantic predicates didn't prevent us from
			// creating a DFA state. Once we know s!=null, we check to see if
			// the DFA state has an edge already for t. If so, we can just reuse
			// it's configuration set; there's no point in re-computing it.
			// This is kind of like doing DFA simulation within the ATN
			// simulation because DFA simulation is really just a way to avoid
			// computing reach/closure sets. Technically, once we know that
			// we have a previously added DFA state, we could jump over to
			// the DFA simulator. But, that would mean popping back and forth
			// a lot and making things more complicated algorithmically.
			// This optimization makes a lot of sense for loops within DFA.
			// A character will take us back to an existing DFA state
			// that already has lots of edges out of it. e.g., .* in comments.
			DFAState target = getExistingTargetState(s, t);
			if (target == null) {
				target = computeTargetState(input, s, t);
			}

			if (target == ERROR) {
				break;
			}

			if (target.isAcceptState) {
				captureSimState(prevAccept, input, target);
				if (t == IntStream.EOF) {
					break;
				}
			}

			if (t != IntStream.EOF) {
				consume(input);
				t = input.LA(1);
			}

			s = target; // flip; current DFA target becomes new src/from state
		}

		return failOrAccept(prevAccept, input, s.configs, t);
	}

	/**
	 * Get an existing target state for an edge in the DFA. If the target state
	 * for the edge has not yet been computed or is otherwise not available,
	 * this method returns {@code null}.
	 *
	 * @param s The current DFA state
	 * @param t The next input symbol
	 * @return The existing target DFA state for the given input symbol
	 * {@code t}, or {@code null} if the target state for this edge is not
	 * already cached
	 */
	@Nullable
	protected DFAState getExistingTargetState(@NotNull DFAState s, int t) {
		if (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {
			return null;
		}
		
		DFAState target = s.edges[t - MIN_DFA_EDGE];
		if (debug && target != null) {
			System.out.println(""reuse state ""+s.stateNumber+
							   "" edge to ""+target.stateNumber);
		}

		return target;
	}

	/**
	 * Compute a target state for an edge in the DFA, and attempt to add the
	 * computed state and corresponding edge to the DFA.
	 *
	 * @param input The input stream
	 * @param s The current DFA state
	 * @param t The next input symbol
	 *
	 * @return The computed target DFA state for the given input symbol
	 * {@code t}. If {@code t} does not lead to a valid DFA state, this method
	 * returns {@link #ERROR}.
	 */
	@NotNull
	protected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {
		ATNConfigSet reach = new OrderedATNConfigSet();

		// if we don't find an existing DFA state
		// Fill reach starting from closure, following t transitions
		getReachableConfigSet(input, s.configs, reach, t);

		if ( reach.isEmpty() ) { // we got nowhere on t from s
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			addDFAEdge(s, t, ERROR);
			// stop when we can't match any more char
			return ERROR;
		}

		// Add an edge from s to target DFA found/created for reach
		return addDFAEdge(s, t, reach);
	}",
L540,L515,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,ADD_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,"void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)",org.antlr.v4.runtime.ANTLRErrorListener.reportAmbiguity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,92,,95,,112,2,118,39,"void reportAmbiguity(@NotNull Parser recognizer,
						 DFA dfa, int startIndex, int stopIndex,
						 @NotNull BitSet ambigAlts,
						 @NotNull ATNConfigSet configs);","void reportAmbiguity(@NotNull Parser recognizer,
						 @NotNull DFA dfa,
						 int startIndex,
						 int stopIndex,
						 boolean exact,
						 @NotNull BitSet ambigAlts,
						 @NotNull ATNConfigSet configs);",
L561,L515,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,ADD_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\ANTLRErrorListener.java,"void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs)",org.antlr.v4.runtime.ANTLRErrorListener.reportAttemptingFullContext(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IILjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V,97,,100,,141,2,146,42,"void reportAttemptingFullContext(@NotNull Parser recognizer,
									 @NotNull DFA dfa,
									 int startIndex, int stopIndex,
									 @NotNull ATNConfigSet configs);","void reportAttemptingFullContext(@NotNull Parser recognizer,
									 @NotNull DFA dfa,
									 int startIndex,
									 int stopIndex,
									 @Nullable BitSet conflictingAlts,
									 @NotNull ATNConfigSet configs);",
L5431,L543,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\Parser.java,runtime\Java\src\org\antlr\v4\runtime\Parser.java,void unrollRecursionContexts(ParserRuleContext _parentctx),org.antlr.v4.runtime.Parser.unrollRecursionContexts(Lorg/antlr/v4/runtime/ParserRuleContext;)V,481,2,498,3,593,2,615,3,"public void unrollRecursionContexts(ParserRuleContext _parentctx) {
		_ctx.stop = _input.LT(-1);
		ParserRuleContext retctx = _ctx; // save current ctx (return value)

		// unroll so _ctx is as it was before call to recursive method
		if ( _parseListeners != null ) {
			while ( _ctx != _parentctx ) {
				triggerExitRuleEvent();
				_ctx = (ParserRuleContext)_ctx.parent;
			}
		}
		else {
			_ctx = _parentctx;
		}
		// hook into tree
		retctx.parent = _parentctx;
		if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree
	}","public void unrollRecursionContexts(ParserRuleContext _parentctx) {
		_ctx.stop = _input.LT(-1);
		ParserRuleContext retctx = _ctx; // save current ctx (return value)

		// unroll so _ctx is as it was before call to recursive method
		if ( _parseListeners != null ) {
			while ( _ctx != _parentctx ) {
				triggerExitRuleEvent();
				_ctx = (ParserRuleContext)_ctx.parent;
			}
		}
		else {
			_ctx = _parentctx;
		}

		// hook into tree
		retctx.parent = _parentctx;

		if (_buildParseTrees && _parentctx != null) {
			// add return ctx into invoking rule's tree
			_parentctx.addChild(retctx);
		}
	}",
L3844,L3806,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,https://github.com/antlr/antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\BufferedTokenStream.java,runtime\Java\src\org\antlr\v4\runtime\BufferedTokenStream.java,void consume(),org.antlr.v4.runtime.BufferedTokenStream.consume()V,132,2,157,3,132,5,157,6,"public void consume() {
		boolean skipEofCheck;
		if (p >= 0) {
			if (fetchedEOF) {
				// the last token in tokens is EOF. skip check if p indexes any
				// fetched token except the last.
				skipEofCheck = p < tokens.size() - 1;
			}
			else {
				// no EOF token in tokens. skip check if p indexes a fetched token.
				skipEofCheck = p < tokens.size();
			}
		}
		else {
			// not yet initialized
			skipEofCheck = false;
		}

		if (!skipEofCheck && LA(1) == EOF) {
			throw new IllegalStateException(""cannot consume EOF"");
		}

		if (sync(p + 1)) {
			p = adjustSeekIndex(p + 1);
		}
    }"," public void consume() {
		boolean skipEofCheck;
		if (p >= 0) {
			if (fetchedEOF) {
				// the last token in tokens is EOF. skip check if p indexes any
				// fetched token except the last.
				skipEofCheck = p < tokens.size() - 1;
			}
			else {
				// no EOF token in tokens. skip check if p indexes a fetched token.
				skipEofCheck = p < tokens.size();
			}
		}
		else {
			// not yet initialized
			skipEofCheck = false;
		}

		if (!skipEofCheck && LA(1) == EOF) {
			throw new IllegalStateException(""cannot consume EOF"");
		}

		if (sync(p + 1)) {
			p = adjustSeekIndex(p + 1);
		}
    }",
L3168,L3038,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,https://github.com/antlr/antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,"ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx)",org.antlr.v4.runtime.atn.ParserATNSimulator.computeReachSet(Lorg/antlr/v4/runtime/atn/ATNConfigSet;IZ)Lorg/antlr/v4/runtime/atn/ATNConfigSet;,785,2,912,3,798,2,926,3,"protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
										   boolean fullCtx)
	{
		if ( debug ) System.out.println(""in computeReachSet, starting closure: "" + closure);

		if (mergeCache == null) {
			mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();
		}

		ATNConfigSet intermediate = new ATNConfigSet(fullCtx);

		/* Configurations already in a rule stop state indicate reaching the end
		 * of the decision rule (local context) or end of the start rule (full
		 * context). Once reached, these configurations are never updated by a
		 * closure operation, so they are handled separately for the performance
		 * advantage of having a smaller intermediate set when calling closure.
		 *
		 * For full-context reach operations, separate handling is required to
		 * ensure that the alternative matching the longest overall sequence is
		 * chosen when multiple such configurations can match the input.
		 */
		List<ATNConfig> skippedStopStates = null;

		// First figure out where we can reach on input t
		for (ATNConfig c : closure) {
			if ( debug ) System.out.println(""testing ""+getTokenName(t)+"" at ""+c.toString());

			if (c.state instanceof RuleStopState) {
				assert c.context.isEmpty();
				if (fullCtx || t == IntStream.EOF) {
					if (skippedStopStates == null) {
						skippedStopStates = new ArrayList<ATNConfig>();
					}

					skippedStopStates.add(c);
				}

				continue;
			}

			int n = c.state.getNumberOfTransitions();
			for (int ti=0; ti<n; ti++) {               // for each transition
				Transition trans = c.state.transition(ti);
				ATNState target = getReachableTarget(trans, t);
				if ( target!=null ) {
					intermediate.add(new ATNConfig(c, target), mergeCache);
				}
			}
		}

		// Now figure out where the reach operation can take us...

		ATNConfigSet reach = null;

		/* This block optimizes the reach operation for intermediate sets which
		 * trivially indicate a termination state for the overall
		 * adaptivePredict operation.
		 *
		 * The conditions assume that intermediate
		 * contains all configurations relevant to the reach set, but this
		 * condition is not true when one or more configurations have been
		 * withheld in skippedStopStates.
		 */
		if (skippedStopStates == null) {
			if ( intermediate.size()==1 ) {
				// Don't pursue the closure if there is just one state.
				// It can only have one alternative; just add to result
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
			else if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
		}

		/* If the reach set could not be trivially determined, perform a closure
		 * operation on the intermediate set to compute its initial value.
		 */
		if (reach == null) {
			reach = new ATNConfigSet(fullCtx);
			Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();
			for (ATNConfig c : intermediate) {
				closure(c, reach, closureBusy, false, fullCtx);
			}
		}

		if (t == IntStream.EOF) {
			/* After consuming EOF no additional input is possible, so we are
			 * only interested in configurations which reached the end of the
			 * decision rule (local context) or end of the start rule (full
			 * context). Update reach to contain only these configurations. This
			 * handles both explicit EOF transitions in the grammar and implicit
			 * EOF transitions following the end of the decision or start rule.
			 *
			 * When reach==intermediate, no closure operation was performed. In
			 * this case, removeAllConfigsNotInRuleStopState needs to check for
			 * reachable rule stop states as well as configurations already in
			 * a rule stop state.
			 *
			 * This is handled before the configurations in skippedStopStates,
			 * because any configurations potentially added from that list are
			 * already guaranteed to meet this condition whether or not it's
			 * required.
			 */
			reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);
		}

		/* If skippedStopStates is not null, then it contains at least one
		 * configuration. For full-context reach operations, these
		 * configurations reached the end of the start rule, in which case we
		 * only add them back to reach if no configuration during the current
		 * closure operation reached such a state. This ensures adaptivePredict
		 * chooses an alternative matching the longest overall sequence when
		 * multiple alternatives are viable.
		 */
		if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
			assert !skippedStopStates.isEmpty();
			for (ATNConfig c : skippedStopStates) {
				reach.add(c, mergeCache);
			}
		}

		if ( reach.isEmpty() ) return null;
		return reach;
	}","protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
										   boolean fullCtx)
	{
		if ( debug ) System.out.println(""in computeReachSet, starting closure: "" + closure);

		if (mergeCache == null) {
			mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();
		}

		ATNConfigSet intermediate = new ATNConfigSet(fullCtx);

		/* Configurations already in a rule stop state indicate reaching the end
		 * of the decision rule (local context) or end of the start rule (full
		 * context). Once reached, these configurations are never updated by a
		 * closure operation, so they are handled separately for the performance
		 * advantage of having a smaller intermediate set when calling closure.
		 *
		 * For full-context reach operations, separate handling is required to
		 * ensure that the alternative matching the longest overall sequence is
		 * chosen when multiple such configurations can match the input.
		 */
		List<ATNConfig> skippedStopStates = null;

		// First figure out where we can reach on input t
		for (ATNConfig c : closure) {
			if ( debug ) System.out.println(""testing ""+getTokenName(t)+"" at ""+c.toString());

			if (c.state instanceof RuleStopState) {
				assert c.context.isEmpty();
				if (fullCtx || t == IntStream.EOF) {
					if (skippedStopStates == null) {
						skippedStopStates = new ArrayList<ATNConfig>();
					}

					skippedStopStates.add(c);
				}

				continue;
			}

			int n = c.state.getNumberOfTransitions();
			for (int ti=0; ti<n; ti++) {               // for each transition
				Transition trans = c.state.transition(ti);
				ATNState target = getReachableTarget(trans, t);
				if ( target!=null ) {
					intermediate.add(new ATNConfig(c, target), mergeCache);
				}
			}
		}

		// Now figure out where the reach operation can take us...

		ATNConfigSet reach = null;

		/* This block optimizes the reach operation for intermediate sets which
		 * trivially indicate a termination state for the overall
		 * adaptivePredict operation.
		 *
		 * The conditions assume that intermediate
		 * contains all configurations relevant to the reach set, but this
		 * condition is not true when one or more configurations have been
		 * withheld in skippedStopStates, or when the current symbol is EOF.
		 */
		if (skippedStopStates == null && t != Token.EOF) {
			if ( intermediate.size()==1 ) {
				// Don't pursue the closure if there is just one state.
				// It can only have one alternative; just add to result
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
			else if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {
				// Also don't pursue the closure if there is unique alternative
				// among the configurations.
				reach = intermediate;
			}
		}

		/* If the reach set could not be trivially determined, perform a closure
		 * operation on the intermediate set to compute its initial value.
		 */
		if (reach == null) {
			reach = new ATNConfigSet(fullCtx);
			Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();
			boolean treatEofAsEpsilon = t == Token.EOF;
			for (ATNConfig c : intermediate) {
				closure(c, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
			}
		}

		if (t == IntStream.EOF) {
			/* After consuming EOF no additional input is possible, so we are
			 * only interested in configurations which reached the end of the
			 * decision rule (local context) or end of the start rule (full
			 * context). Update reach to contain only these configurations. This
			 * handles both explicit EOF transitions in the grammar and implicit
			 * EOF transitions following the end of the decision or start rule.
			 *
			 * When reach==intermediate, no closure operation was performed. In
			 * this case, removeAllConfigsNotInRuleStopState needs to check for
			 * reachable rule stop states as well as configurations already in
			 * a rule stop state.
			 *
			 * This is handled before the configurations in skippedStopStates,
			 * because any configurations potentially added from that list are
			 * already guaranteed to meet this condition whether or not it's
			 * required.
			 */
			reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);
		}

		/* If skippedStopStates is not null, then it contains at least one
		 * configuration. For full-context reach operations, these
		 * configurations reached the end of the start rule, in which case we
		 * only add them back to reach if no configuration during the current
		 * closure operation reached such a state. This ensures adaptivePredict
		 * chooses an alternative matching the longest overall sequence when
		 * multiple alternatives are viable.
		 */
		if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
			assert !skippedStopStates.isEmpty();
			for (ATNConfig c : skippedStopStates) {
				reach.add(c, mergeCache);
			}
		}

		if ( reach.isEmpty() ) return null;
		return reach;
	}",
L10263,L10252,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\automata\ATNPrinter.java,tool\src\org\antlr\v4\automata\ATNPrinter.java,String asString(),org.antlr.v4.automata.ATNPrinter.asString()Ljava/lang/String;,69,2,123,3,69,2,123,3,"public String asString() {
		if ( start==null ) return null;
		marked = new HashSet<ATNState>();

		work = new ArrayList<ATNState>();
		work.add(start);

		StringBuilder buf = new StringBuilder();
		ATNState s;

		while ( !work.isEmpty() ) {
			s = work.remove(0);
			if ( marked.contains(s) ) continue;
			int n = s.getNumberOfTransitions();
//			System.out.println(""visit ""+s+""; edges=""+n);
			marked.add(s);
			for (int i=0; i<n; i++) {
				Transition t = s.transition(i);
				if ( !(s instanceof RuleStopState) ) { // don't add follow states to work
					if ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);
					else work.add( t.target );
				}
				buf.append(getStateString(s));
				if ( t instanceof EpsilonTransition ) {
					buf.append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof RuleTransition ) {
					buf.append(""-"").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof ActionTransition ) {
					ActionTransition a = (ActionTransition)t;
					buf.append(""-"").append(a.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof SetTransition ) {
					SetTransition st = (SetTransition)t;
					boolean not = st instanceof NotSetTransition;
					if ( g.isLexer() ) {
						buf.append(""-"").append(not?""~"":"""").append(st.toString()).append(""->"").append(getStateString(t.target)).append('\n');
					}
					else {
						buf.append(""-"").append(not?""~"":"""").append(st.label().toString(g.getTokenNames())).append(""->"").append(getStateString(t.target)).append('\n');
					}
				}
				else if ( t instanceof AtomTransition ) {
					AtomTransition a = (AtomTransition)t;
					String label = g.getTokenDisplayName(a.label);
					buf.append(""-"").append(label).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else {
					buf.append(""-"").append(t.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
			}
		}
		return buf.toString();
	}","public String asString() {
		if ( start==null ) return null;
		marked = new HashSet<ATNState>();

		work = new ArrayList<ATNState>();
		work.add(start);

		StringBuilder buf = new StringBuilder();
		ATNState s;

		while ( !work.isEmpty() ) {
			s = work.remove(0);
			if ( marked.contains(s) ) continue;
			int n = s.getNumberOfTransitions();
//			System.out.println(""visit ""+s+""; edges=""+n);
			marked.add(s);
			for (int i=0; i<n; i++) {
				Transition t = s.transition(i);
				if ( !(s instanceof RuleStopState) ) { // don't add follow states to work
					if ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);
					else work.add( t.target );
				}
				buf.append(getStateString(s));
				if ( t instanceof EpsilonTransition ) {
					buf.append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof RuleTransition ) {
					buf.append(""-"").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof ActionTransition ) {
					ActionTransition a = (ActionTransition)t;
					buf.append(""-"").append(a.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else if ( t instanceof SetTransition ) {
					SetTransition st = (SetTransition)t;
					boolean not = st instanceof NotSetTransition;
					if ( g.isLexer() ) {
						buf.append(""-"").append(not?""~"":"""").append(st.toString()).append(""->"").append(getStateString(t.target)).append('\n');
					}
					else {
						buf.append(""-"").append(not?""~"":"""").append(st.label().toString(g.getTokenDisplayNames())).append(""->"").append(getStateString(t.target)).append('\n');
					}
				}
				else if ( t instanceof AtomTransition ) {
					AtomTransition a = (AtomTransition)t;
					String label = g.getTokenDisplayName(a.label);
					buf.append(""-"").append(label).append(""->"").append(getStateString(t.target)).append('\n');
				}
				else {
					buf.append(""-"").append(t.toString()).append(""->"").append(getStateString(t.target)).append('\n');
				}
			}
		}
		return buf.toString();
	}",
L102630,L10252,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\automata\ATNPrinter.java,tool\src\org\antlr\v4\automata\ATNPrinter.java,String getStateString(ATNState s),org.antlr.v4.automata.ATNPrinter.getStateString()Ljava/lang/String;,125,2,138,3,125,2,138,3,"String getStateString(ATNState s) {
		int n = s.stateNumber;
		String stateStr = ""s""+n;
		if ( s instanceof StarBlockStartState ) stateStr = ""StarBlockStart_""+n;
		else if ( s instanceof PlusBlockStartState ) stateStr = ""PlusBlockStart_""+n;
		else if ( s instanceof BlockStartState) stateStr = ""BlockStart_""+n;
		else if ( s instanceof BlockEndState ) stateStr = ""BlockEnd_""+n;
		else if ( s instanceof RuleStartState) stateStr = ""RuleStart_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof RuleStopState ) stateStr = ""RuleStop_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof PlusLoopbackState) stateStr = ""PlusLoopBack_""+n;
		else if ( s instanceof StarLoopbackState) stateStr = ""StarLoopBack_""+n;
		else if ( s instanceof StarLoopEntryState) stateStr = ""StarLoopEntry_""+n;
		return stateStr;
	}","String getStateString(ATNState s) {
		int n = s.stateNumber;
		String stateStr = ""s""+n;
		if ( s instanceof StarBlockStartState ) stateStr = ""StarBlockStart_""+n;
		else if ( s instanceof PlusBlockStartState ) stateStr = ""PlusBlockStart_""+n;
		else if ( s instanceof BlockStartState) stateStr = ""BlockStart_""+n;
		else if ( s instanceof BlockEndState ) stateStr = ""BlockEnd_""+n;
		else if ( s instanceof RuleStartState) stateStr = ""RuleStart_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof RuleStopState ) stateStr = ""RuleStop_""+g.getRule(s.ruleIndex).name+""_""+n;
		else if ( s instanceof PlusLoopbackState) stateStr = ""PlusLoopBack_""+n;
		else if ( s instanceof StarLoopbackState) stateStr = ""StarLoopBack_""+n;
		else if ( s instanceof StarLoopEntryState) stateStr = ""StarLoopEntry_""+n;
		return stateStr;
	}",
L15668,L14958,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\tool\DOTGenerator.java,tool\src\org\antlr\v4\tool\DOTGenerator.java,"String getDOT(DFA dfa, boolean isLexer)",org.antlr.v4.tool.DOTGenerator.getDOT(Lorg/antlr/v4/runtime/dfa/DFA;Z)Ljava/lang/String;,83,2,132,3,83,2,132,3,"public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}","public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}",
L156680,L14958,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,https://github.com/antlr/antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,tool\src\org\antlr\v4\tool\DOTGenerator.java,tool\src\org\antlr\v4\tool\DOTGenerator.java,"String getDOT(DFA dfa, boolean isLexer)",org.antlr.v4.tool.DOTGenerator.getDOT(Lorg/antlr/v4/runtime/dfa/DFA;Z)Ljava/lang/String;,83,2,132,3,83,2,132,3,"public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}","public String getDOT(DFA dfa, boolean isLexer) {
		if ( dfa.s0==null )	return null;

		ST dot = stlib.getInstanceOf(""dfa"");
		dot.add(""name"", ""DFA""+dfa.decision);
		dot.add(""startState"", dfa.s0.stateNumber);
//		dot.add(""useBox"", Tool.internalOption_ShowATNConfigsInDFA);
		dot.add(""rankdir"", rankdir);

		// define stop states first; seems to be a bug in DOT where doublecircle
		for (DFAState d : dfa.states.keySet()) {
			if ( !d.isAcceptState ) continue;
			ST st = stlib.getInstanceOf(""stopstate"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.isAcceptState ) continue;
			if ( d.stateNumber == Integer.MAX_VALUE ) continue;
			ST st = stlib.getInstanceOf(""state"");
			st.add(""name"", ""s""+d.stateNumber);
			st.add(""label"", getStateLabel(d));
			dot.add(""states"", st);
		}

		for (DFAState d : dfa.states.keySet()) {
			if ( d.edges!=null ) {
				for (int i = 0; i < d.edges.length; i++) {
					DFAState target = d.edges[i];
					if ( target==null) continue;
					if ( target.stateNumber == Integer.MAX_VALUE ) continue;
					int ttype = i-1; // we shift up for EOF as -1 for parser
					String label = String.valueOf(ttype);
					if ( isLexer ) label = ""'""+getEdgeLabel(String.valueOf((char) i))+""'"";
					else if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);
					ST st = stlib.getInstanceOf(""edge"");
					st.add(""label"", label);
					st.add(""src"", ""s""+d.stateNumber);
					st.add(""target"", ""s""+target.stateNumber);
					st.add(""arrowhead"", arrowhead);
					dot.add(""edges"", st);
				}
			}
		}

		String output = dot.render();
		return Utils.sortLinesInString(output);
	}",
L3347,L3055,90a5aa469a09a9296fe3b9a25b37ed8ebd3d627f,e1e12f0b419461c4fc63461a2776024ad9f4fd54,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,"void closure_(ATNConfig config, ATNConfigSet configs, Set<ATNConfig> closureBusy, boolean collectPredicates, boolean fullCtx, int depth, boolean treatEofAsEpsilon)",org.antlr.v4.runtime.atn.ParserATNSimulator.closure_(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/Set;ZZIZ)V,1436,2,1496,3,1550,2,1617,3,"protected void closure_(@NotNull ATNConfig config,
							@NotNull ATNConfigSet configs,
							@NotNull Set<ATNConfig> closureBusy,
							boolean collectPredicates,
							boolean fullCtx,
							int depth,
							boolean treatEofAsEpsilon)
	{
		ATNState p = config.state;
		// optimization
		if ( !p.onlyHasEpsilonTransitions() ) {
            configs.add(config, mergeCache);
			// make sure to not return here, because EOF transitions can act as
			// both epsilon transitions and non-epsilon transitions.
//            if ( debug ) System.out.println(""added config ""+configs);
        }

		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			boolean continueCollecting =
				!(t instanceof ActionTransition) && collectPredicates;
			ATNConfig c = getEpsilonTarget(config, t, continueCollecting,
										   depth == 0, fullCtx, treatEofAsEpsilon);
			if ( c!=null ) {
				if (!t.isEpsilon() && !closureBusy.add(c)) {
					// avoid infinite recursion for EOF* and EOF+
					continue;
				}

				int newDepth = depth;
				if ( config.state instanceof RuleStopState) {
					assert !fullCtx;
					// target fell off end of rule; mark resulting c as having dipped into outer context
					// We can't get here if incoming config was rule stop and we had context
					// track how far we dip into outer context.  Might
					// come in handy and we avoid evaluating context dependent
					// preds if this is > 0.

					if (!closureBusy.add(c)) {
						// avoid infinite recursion for right-recursive rules
						continue;
					}

					c.reachesIntoOuterContext++;
					configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
					assert newDepth > Integer.MIN_VALUE;
					newDepth--;
					if ( debug ) System.out.println(""dips into outer ctx: ""+c);
				}
				else if (t instanceof RuleTransition) {
					// latch when newDepth goes negative - once we step out of the entry context we can't return
					if (newDepth >= 0) {
						newDepth++;
					}
				}

				closureCheckingStopState(c, configs, closureBusy, continueCollecting,
										 fullCtx, newDepth, treatEofAsEpsilon);
			}
		}
	}","protected void closure_(ATNConfig config,
							ATNConfigSet configs,
							Set<ATNConfig> closureBusy,
							boolean collectPredicates,
							boolean fullCtx,
							int depth,
							boolean treatEofAsEpsilon)
	{
		ATNState p = config.state;
		// optimization
		if ( !p.onlyHasEpsilonTransitions() ) {
            configs.add(config, mergeCache);
			// make sure to not return here, because EOF transitions can act as
			// both epsilon transitions and non-epsilon transitions.
//            if ( debug ) System.out.println(""added config ""+configs);
        }

		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			boolean continueCollecting =
				!(t instanceof ActionTransition) && collectPredicates;
			ATNConfig c = getEpsilonTarget(config, t, continueCollecting,
										   depth == 0, fullCtx, treatEofAsEpsilon);
			if ( c!=null ) {
				if (!t.isEpsilon() && !closureBusy.add(c)) {
					// avoid infinite recursion for EOF* and EOF+
					continue;
				}

				int newDepth = depth;
				if ( config.state instanceof RuleStopState) {
					assert !fullCtx;
					// target fell off end of rule; mark resulting c as having dipped into outer context
					// We can't get here if incoming config was rule stop and we had context
					// track how far we dip into outer context.  Might
					// come in handy and we avoid evaluating context dependent
					// preds if this is > 0.

					if (!closureBusy.add(c)) {
						// avoid infinite recursion for right-recursive rules
						continue;
					}

					if (_dfa != null && _dfa.isPrecedenceDfa()) {
						int outermostPrecedenceReturn = ((EpsilonTransition)t).outermostPrecedenceReturn();
						if (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {
							c.setPrecedenceFilterSuppressed(true);
						}
					}

					c.reachesIntoOuterContext++;
					configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
					assert newDepth > Integer.MIN_VALUE;
					newDepth--;
					if ( debug ) System.out.println(""dips into outer ctx: ""+c);
				}
				else if (t instanceof RuleTransition) {
					// latch when newDepth goes negative - once we step out of the entry context we can't return
					if (newDepth >= 0) {
						newDepth++;
					}
				}

				closureCheckingStopState(c, configs, closureBusy, continueCollecting,
										 fullCtx, newDepth, treatEofAsEpsilon);
			}
		}
	}",
L2755,L1039,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,"void _LOOK(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, Set<ATNConfig> lookBusy, BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF)",org.antlr.v4.runtime.atn.LL1Analyzer._LOOK(Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/misc/IntervalSet;Ljava/util/Set;Ljava/util/BitSet;ZZ)V,166,5,262,3,166,5,262,3," protected void _LOOK(@NotNull ATNState s,
						 @Nullable ATNState stopState,
						 @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 @NotNull BitSet calledRuleStack,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

		if (s == stopState) {
			if (ctx == null) {
				look.add(Token.EPSILON);
				return;
			} else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}
		}

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (int i = 0; i < ctx.size(); i++) {
					ATNState returnState = atn.states.get(ctx.getReturnState(i));
//					System.out.println(""popping back to ""+retState);

					boolean removed = calledRuleStack.get(returnState.ruleIndex);
					try {
						calledRuleStack.clear(returnState.ruleIndex);
						_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
					}
					finally {
						if (removed) {
							calledRuleStack.set(returnState.ruleIndex);
						}
					}
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				if (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {
					continue;
				}

				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);

				try {
					calledRuleStack.set(((RuleTransition)t).target.ruleIndex);
					_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				finally {
					calledRuleStack.clear(((RuleTransition)t).target.ruleIndex);
				}
			}
			else if ( t instanceof PredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}"," protected void _LOOK(@NotNull ATNState s,
						 @Nullable ATNState stopState,
						 @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 @NotNull BitSet calledRuleStack,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

		if (s == stopState) {
			if (ctx == null) {
				look.add(Token.EPSILON);
				return;
			} else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}
		}

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (int i = 0; i < ctx.size(); i++) {
					ATNState returnState = atn.states.get(ctx.getReturnState(i));
//					System.out.println(""popping back to ""+retState);

					boolean removed = calledRuleStack.get(returnState.ruleIndex);
					try {
						calledRuleStack.clear(returnState.ruleIndex);
						_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
					}
					finally {
						if (removed) {
							calledRuleStack.set(returnState.ruleIndex);
						}
					}
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				if (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {
					continue;
				}

				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);

				try {
					calledRuleStack.set(((RuleTransition)t).target.ruleIndex);
					_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				finally {
					calledRuleStack.clear(((RuleTransition)t).target.ruleIndex);
				}
			}
			else if ( t instanceof AbstractPredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}",
L13228,L13220,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\parse\TokenVocabParser.java,tool\src\org\antlr\v4\parse\TokenVocabParser.java,"Map<String, Integer> load()",org.antlr.v4.parse.TokenVocabParser.load()Ljava/util/Map;,58,2,106,3,59,2,123,3,"public Map<String,Integer> load() {
		Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();
		int maxTokenType = -1;
		File fullFile = getImportedVocabFile();
		try {
			Pattern tokenDefPattern = Pattern.compile(""([^\n]+?)[ \\t]*?=[ \\t]*?([0-9]+)"");
			FileReader fr = new FileReader(fullFile);
			BufferedReader br = new BufferedReader(fr);
			String tokenDef = br.readLine();
			int lineNum = 1;
			while ( tokenDef!=null ) {
				Matcher matcher = tokenDefPattern.matcher(tokenDef);
				if ( matcher.find() ) {
					String tokenID = matcher.group(1);
					String tokenTypeS = matcher.group(2);
					int tokenType = Integer.valueOf(tokenTypeS);
					tool.log(""grammar"", ""import ""+tokenID+""=""+tokenType);
					tokens.put(tokenID, tokenType);
					maxTokenType = Math.max(maxTokenType,tokenType);
					lineNum++;
				}
				else {
					if ( tokenDef.length()>0 ) { // ignore blank lines
						tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,
											  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
											  "" bad token def: ""+tokenDef,
											  lineNum);
					}
				}
				tokenDef = br.readLine();
			}
			br.close();
		}
		catch (FileNotFoundException fnfe) {
			tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,
								  fullFile);
		}
		catch (IOException ioe) {
			tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
								  fullFile,
								  ioe);
		}
		catch (Exception e) {
			tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
								  fullFile,
								  e);
		}
		return tokens;
	}","public Map<String,Integer> load() {
		Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();
		int maxTokenType = -1;
		File fullFile = getImportedVocabFile();
		FileReader fr = null;
		BufferedReader br = null;
		try {
			Pattern tokenDefPattern = Pattern.compile(""([^\n]+?)[ \\t]*?=[ \\t]*?([0-9]+)"");
			fr = new FileReader(fullFile);
			br = new BufferedReader(fr);
			String tokenDef = br.readLine();
			int lineNum = 1;
			while ( tokenDef!=null ) {
				Matcher matcher = tokenDefPattern.matcher(tokenDef);
				if ( matcher.find() ) {
					String tokenID = matcher.group(1);
					String tokenTypeS = matcher.group(2);
					int tokenType;
					try {
						tokenType = Integer.valueOf(tokenTypeS);
					}
					catch (NumberFormatException nfe) {
						tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,
											  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
											  "" bad token type: ""+tokenTypeS,
											  lineNum);
						tokenType = Token.INVALID_TOKEN_TYPE;
					}
					tool.log(""grammar"", ""import ""+tokenID+""=""+tokenType);
					tokens.put(tokenID, tokenType);
					maxTokenType = Math.max(maxTokenType,tokenType);
					lineNum++;
				}
				else {
					if ( tokenDef.length()>0 ) { // ignore blank lines
						tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,
											  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
											  "" bad token def: ""+tokenDef,
											  lineNum);
					}
				}
				tokenDef = br.readLine();
			}
		}
		catch (FileNotFoundException fnfe) {
			tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,
								  fullFile);
		}
		catch (Exception e) {
			tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
								  fullFile,
								  e);
		}
		finally {
			try {
				if ( br!=null ) br.close();
			}
			catch (IOException ioe) {
				tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,
									  fullFile,
									  ioe);
			}
		}
		return tokens;
	}",
L8024,L7991,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\automata\ATNSerializer.java,tool\src\org\antlr\v4\automata\ATNSerializer.java,String decode(char[] data),org.antlr.v4.automata.ATNSerializer.decode([C)Ljava/lang/String;,273,2,361,3,334,2,444,3,"public String decode(char[] data) {
		data = data.clone();
		// don't adjust the first value since that's the version number
		for (int i = 1; i < data.length; i++) {
			data[i] = (char)(data[i] - 2);
		}

		StringBuilder buf = new StringBuilder();
		int p = 0;
		int version = ATNSimulator.toInt(data[p++]);
		if (version != ATNSimulator.SERIALIZED_VERSION) {
			String reason = String.format(""Could not deserialize ATN with version %d (expected %d)."", version, ATNSimulator.SERIALIZED_VERSION);
			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
		}

		int grammarType = ATNSimulator.toInt(data[p++]);
		int maxType = ATNSimulator.toInt(data[p++]);
		buf.append(""max type "").append(maxType).append(""\n"");
		int nstates = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=nstates; i++) {
			int stype = ATNSimulator.toInt(data[p++]);
            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states
			int ruleIndex = ATNSimulator.toInt(data[p++]);
			String arg = """";
			if ( stype == ATNState.LOOP_END ) {
				int loopBackStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+loopBackStateNumber;
			}
			else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {
				int endStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+endStateNumber;
			}
			buf.append(i - 1).append("":"")
				.append(ATNState.serializationNames.get(stype)).append("" "")
				.append(ruleIndex).append(arg).append(""\n"");
		}
		int numNonGreedyStates = ATNSimulator.toInt(data[p++]);
		for (int i = 0; i < numNonGreedyStates; i++) {
			int stateNumber = ATNSimulator.toInt(data[p++]);
		}
		int nrules = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nrules; i++) {
			int s = ATNSimulator.toInt(data[p++]);
            if ( g.isLexer() ) {
                int arg1 = ATNSimulator.toInt(data[p++]);
                int arg2 = ATNSimulator.toInt(data[p++]);
                buf.append(""rule "").append(i).append("":"").append(s).append("" "").append(arg1).append("","").append(arg2).append('\n');
            }
            else {
                buf.append(""rule "").append(i).append("":"").append(s).append('\n');
            }
		}
		int nmodes = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nmodes; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(""mode "").append(i).append("":"").append(s).append('\n');
		}
		int nsets = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=nsets; i++) {
			int nintervals = ATNSimulator.toInt(data[p++]);
			buf.append(i-1).append("":"");
			for (int j=1; j<=nintervals; j++) {
				if ( j>1 ) buf.append("", "");
				buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append("".."").append(getTokenName(ATNSimulator.toInt(data[p + 1])));
				p += 2;
			}
			buf.append(""\n"");
		}
		int nedges = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=nedges; i++) {
			int src = ATNSimulator.toInt(data[p]);
			int trg = ATNSimulator.toInt(data[p + 1]);
			int ttype = ATNSimulator.toInt(data[p + 2]);
			int arg1 = ATNSimulator.toInt(data[p + 3]);
			int arg2 = ATNSimulator.toInt(data[p + 4]);
			int arg3 = ATNSimulator.toInt(data[p + 5]);
			buf.append(src).append(""->"").append(trg)
				.append("" "").append(Transition.serializationNames.get(ttype))
				.append("" "").append(arg1).append("","").append(arg2).append("","").append(arg3)
				.append(""\n"");
			p += 6;
		}
		int ndecisions = ATNSimulator.toInt(data[p++]);
		for (int i=1; i<=ndecisions; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(i-1).append("":"").append(s).append(""\n"");
		}
		return buf.toString();
	}","public String decode(char[] data) {
		data = data.clone();
		// don't adjust the first value since that's the version number
		for (int i = 1; i < data.length; i++) {
			data[i] = (char)(data[i] - 2);
		}

		StringBuilder buf = new StringBuilder();
		int p = 0;
		int version = ATNSimulator.toInt(data[p++]);
		if (version != ATNSimulator.SERIALIZED_VERSION) {
			String reason = String.format(""Could not deserialize ATN with version %d (expected %d)."", version, ATNSimulator.SERIALIZED_VERSION);
			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
		}

		UUID uuid = ATNSimulator.toUUID(data, p);
		p += 8;
		if (!uuid.equals(ATNSimulator.SERIALIZED_UUID)) {
			String reason = String.format(Locale.getDefault(), ""Could not deserialize ATN with UUID %s (expected %s)."", uuid, ATNSimulator.SERIALIZED_UUID);
			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
		}

		int grammarType = ATNSimulator.toInt(data[p++]);
		int maxType = ATNSimulator.toInt(data[p++]);
		buf.append(""max type "").append(maxType).append(""\n"");
		int nstates = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nstates; i++) {
			int stype = ATNSimulator.toInt(data[p++]);
            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states
			int ruleIndex = ATNSimulator.toInt(data[p++]);
			if (ruleIndex == Character.MAX_VALUE) {
				ruleIndex = -1;
			}

			String arg = """";
			if ( stype == ATNState.LOOP_END ) {
				int loopBackStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+loopBackStateNumber;
			}
			else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {
				int endStateNumber = ATNSimulator.toInt(data[p++]);
				arg = "" ""+endStateNumber;
			}
			buf.append(i).append("":"")
				.append(ATNState.serializationNames.get(stype)).append("" "")
				.append(ruleIndex).append(arg).append(""\n"");
		}
		int numNonGreedyStates = ATNSimulator.toInt(data[p++]);
		for (int i = 0; i < numNonGreedyStates; i++) {
			int stateNumber = ATNSimulator.toInt(data[p++]);
		}
		int nrules = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nrules; i++) {
			int s = ATNSimulator.toInt(data[p++]);
            if ( g.isLexer() ) {
                int arg1 = ATNSimulator.toInt(data[p++]);
                int arg2 = ATNSimulator.toInt(data[p++]);
				if (arg2 == Character.MAX_VALUE) {
					arg2 = -1;
				}
                buf.append(""rule "").append(i).append("":"").append(s).append("" "").append(arg1).append("","").append(arg2).append('\n');
            }
            else {
                buf.append(""rule "").append(i).append("":"").append(s).append('\n');
            }
		}
		int nmodes = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nmodes; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(""mode "").append(i).append("":"").append(s).append('\n');
		}
		int nsets = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nsets; i++) {
			int nintervals = ATNSimulator.toInt(data[p++]);
			buf.append(i).append("":"");
			boolean containsEof = data[p++] != 0;
			if (containsEof) {
				buf.append(getTokenName(Token.EOF));
			}

			for (int j=0; j<nintervals; j++) {
				if ( containsEof || j>0 ) {
					buf.append("", "");
				}

				buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append("".."").append(getTokenName(ATNSimulator.toInt(data[p + 1])));
				p += 2;
			}
			buf.append(""\n"");
		}
		int nedges = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<nedges; i++) {
			int src = ATNSimulator.toInt(data[p]);
			int trg = ATNSimulator.toInt(data[p + 1]);
			int ttype = ATNSimulator.toInt(data[p + 2]);
			int arg1 = ATNSimulator.toInt(data[p + 3]);
			int arg2 = ATNSimulator.toInt(data[p + 4]);
			int arg3 = ATNSimulator.toInt(data[p + 5]);
			buf.append(src).append(""->"").append(trg)
				.append("" "").append(Transition.serializationNames.get(ttype))
				.append("" "").append(arg1).append("","").append(arg2).append("","").append(arg3)
				.append(""\n"");
			p += 6;
		}
		int ndecisions = ATNSimulator.toInt(data[p++]);
		for (int i=0; i<ndecisions; i++) {
			int s = ATNSimulator.toInt(data[p++]);
			buf.append(i).append("":"").append(s).append(""\n"");
		}
		return buf.toString();
	}",
L9806,L8817,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\codegen\ParserFactory.java,tool\src\org\antlr\v4\codegen\ParserFactory.java,"void defineImplicitLabel(GrammarAST ast, LabeledOp op)",org.antlr.v4.codegen.ParserFactory.defineImplicitLabel(Lorg/antlr/v4/tool/ast/GrammarAST;Lorg/antlr/v4/codegen/model/LabeledOp;)V,330,2,354,3,334,2,358,3,"public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {
		Decl d;
		if ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {
			String implLabel =
				gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		else if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?
			Rule r = g.getRule(ast.getText());
			String implLabel = gen.target.getImplicitRuleLabel(ast.getText());
			String ctxName =
				gen.target.getRuleFunctionContextStructName(r);
			d = new RuleContextDecl(this, implLabel, ctxName);
			((RuleContextDecl)d).isImplicit = true;
		}
		else {
			String implLabel = gen.target.getImplicitTokenLabel(ast.getText());
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		op.getLabels().add(d);
		// all labels must be in scope struct in case we exec action out of context
		getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);
	}","public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {
		Decl d;
		if ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {
			String implLabel =
				gen.getTarget().getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		else if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?
			Rule r = g.getRule(ast.getText());
			String implLabel = gen.getTarget().getImplicitRuleLabel(ast.getText());
			String ctxName =
				gen.getTarget().getRuleFunctionContextStructName(r);
			d = new RuleContextDecl(this, implLabel, ctxName);
			((RuleContextDecl)d).isImplicit = true;
		}
		else {
			String implLabel = gen.getTarget().getImplicitTokenLabel(ast.getText());
			d = getTokenLabelDecl(implLabel);
			((TokenDecl)d).isImplicit = true;
		}
		op.getLabels().add(d);
		// all labels must be in scope struct in case we exec action out of context
		getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);
	}",
L1506,L807,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,CONSOLIDATE_COND_EXPRESSION,Consolidate Conditional Expression,runtime\Java\src\org\antlr\v4\runtime\atn\ATNState.java,runtime\Java\src\org\antlr\v4\runtime\atn\ATNState.java,void addTransition(Transition e),org.antlr.v4.runtime.atn.ATNState.addTransition(Lorg/antlr/v4/runtime/atn/Transition;)V,180,2,190,3,181,2,183,3,"public void addTransition(Transition e) {
		if (transitions.isEmpty()) {
			epsilonOnlyTransitions = e.isEpsilon();
		}
		else if (epsilonOnlyTransitions != e.isEpsilon()) {
			System.err.format(""ATN state %d has both epsilon and non-epsilon transitions.\n"", stateNumber);
			epsilonOnlyTransitions = false;
		}

		transitions.add(e);
	}","public void addTransition(Transition e) {
		addTransition(transitions.size(), e);
	}

	public void addTransition(int index, Transition e) {
		if (transitions.isEmpty()) {
			epsilonOnlyTransitions = e.isEpsilon();
		}
		else if (epsilonOnlyTransitions != e.isEpsilon()) {
			System.err.format(Locale.getDefault(), ""ATN state %d has both epsilon and non-epsilon transitions.\n"", stateNumber);
			epsilonOnlyTransitions = false;
		}

		transitions.add(index, e);
	}",
L1991,L1833,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_NESTED_COND_WITH_GUARD_CLAUSES,Replace Nested Conditional with Guard Clauses,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"boolean closure(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative)",org.antlr.v4.runtime.atn.LexerATNSimulator.closure(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;ZZ)Z,389,2,456,3,409,2,466,3,"protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {
		if ( debug ) {
			System.out.println(""closure(""+config.toString(recog, true)+"")"");
		}

		if ( config.state instanceof RuleStopState ) {
			if ( debug ) {
				if ( recog!=null ) {
					System.out.format(""closure at %s rule stop %s\n"", recog.getRuleNames()[config.state.ruleIndex], config);
				}
				else {
					System.out.format(""closure at rule stop %s\n"", config);
				}
			}

			if ( config.context == null || config.context.hasEmptyPath() ) {
				if (config.context == null || config.context.isEmpty()) {
					configs.add(config);
					return true;
				}
				else {
					configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));
					currentAltReachedAcceptState = true;
				}
			}

			if ( config.context!=null && !config.context.isEmpty() ) {
				for (SingletonPredictionContext ctx : config.context) {
					if ( !ctx.isEmpty() ) {
						PredictionContext newContext = ctx.parent; // ""pop"" return state
						if ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {
							// we have no context info. Don't pursue but
							// record a config that indicates how we hit end
							LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);
							if ( debug ) System.out.println(""FALLING off token ""+
														    recog.getRuleNames()[config.state.ruleIndex]+
														    "" record ""+c);
							configs.add(c);
							continue;
						}
						ATNState returnState = atn.states.get(ctx.returnState);
						LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);
						currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
					}
				}
			}

			return currentAltReachedAcceptState;
		}

		// optimization
		if ( !config.state.onlyHasEpsilonTransitions() ) {
			if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {
				configs.add(config);
			}
		}

		ATNState p = config.state;
		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);
			if ( c!=null ) {
				currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
			}
		}

		return currentAltReachedAcceptState;
	}","protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {
		if ( debug ) {
			System.out.println(""closure(""+config.toString(recog, true)+"")"");
		}

		if ( config.state instanceof RuleStopState ) {
			if ( debug ) {
				if ( recog!=null ) {
					System.out.format(Locale.getDefault(), ""closure at %s rule stop %s\n"", recog.getRuleNames()[config.state.ruleIndex], config);
				}
				else {
					System.out.format(Locale.getDefault(), ""closure at rule stop %s\n"", config);
				}
			}

			if ( config.context == null || config.context.hasEmptyPath() ) {
				if (config.context == null || config.context.isEmpty()) {
					configs.add(config);
					return true;
				}
				else {
					configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));
					currentAltReachedAcceptState = true;
				}
			}

			if ( config.context!=null && !config.context.isEmpty() ) {
				for (int i = 0; i < config.context.size(); i++) {
					if (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {
						PredictionContext newContext = config.context.getParent(i); // ""pop"" return state
						ATNState returnState = atn.states.get(config.context.getReturnState(i));
						LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);
						currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
					}
				}
			}

			return currentAltReachedAcceptState;
		}

		// optimization
		if ( !config.state.onlyHasEpsilonTransitions() ) {
			if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {
				configs.add(config);
			}
		}

		ATNState p = config.state;
		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);
			if ( c!=null ) {
				currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
			}
		}

		return currentAltReachedAcceptState;
	}",
L19910,L1833,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_NULL_OBJECT,Introduce Special Case,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"boolean closure(CharStream input, LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative)",org.antlr.v4.runtime.atn.LexerATNSimulator.closure(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;ZZ)Z,389,2,456,3,409,2,466,3,"protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {
		if ( debug ) {
			System.out.println(""closure(""+config.toString(recog, true)+"")"");
		}

		if ( config.state instanceof RuleStopState ) {
			if ( debug ) {
				if ( recog!=null ) {
					System.out.format(""closure at %s rule stop %s\n"", recog.getRuleNames()[config.state.ruleIndex], config);
				}
				else {
					System.out.format(""closure at rule stop %s\n"", config);
				}
			}

			if ( config.context == null || config.context.hasEmptyPath() ) {
				if (config.context == null || config.context.isEmpty()) {
					configs.add(config);
					return true;
				}
				else {
					configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));
					currentAltReachedAcceptState = true;
				}
			}

			if ( config.context!=null && !config.context.isEmpty() ) {
				for (SingletonPredictionContext ctx : config.context) {
					if ( !ctx.isEmpty() ) {
						PredictionContext newContext = ctx.parent; // ""pop"" return state
						if ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {
							// we have no context info. Don't pursue but
							// record a config that indicates how we hit end
							LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);
							if ( debug ) System.out.println(""FALLING off token ""+
														    recog.getRuleNames()[config.state.ruleIndex]+
														    "" record ""+c);
							configs.add(c);
							continue;
						}
						ATNState returnState = atn.states.get(ctx.returnState);
						LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);
						currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
					}
				}
			}

			return currentAltReachedAcceptState;
		}

		// optimization
		if ( !config.state.onlyHasEpsilonTransitions() ) {
			if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {
				configs.add(config);
			}
		}

		ATNState p = config.state;
		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);
			if ( c!=null ) {
				currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
			}
		}

		return currentAltReachedAcceptState;
	}","protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {
		if ( debug ) {
			System.out.println(""closure(""+config.toString(recog, true)+"")"");
		}

		if ( config.state instanceof RuleStopState ) {
			if ( debug ) {
				if ( recog!=null ) {
					System.out.format(Locale.getDefault(), ""closure at %s rule stop %s\n"", recog.getRuleNames()[config.state.ruleIndex], config);
				}
				else {
					System.out.format(Locale.getDefault(), ""closure at rule stop %s\n"", config);
				}
			}

			if ( config.context == null || config.context.hasEmptyPath() ) {
				if (config.context == null || config.context.isEmpty()) {
					configs.add(config);
					return true;
				}
				else {
					configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));
					currentAltReachedAcceptState = true;
				}
			}

			if ( config.context!=null && !config.context.isEmpty() ) {
				for (int i = 0; i < config.context.size(); i++) {
					if (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {
						PredictionContext newContext = config.context.getParent(i); // ""pop"" return state
						ATNState returnState = atn.states.get(config.context.getReturnState(i));
						LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);
						currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
					}
				}
			}

			return currentAltReachedAcceptState;
		}

		// optimization
		if ( !config.state.onlyHasEpsilonTransitions() ) {
			if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {
				configs.add(config);
			}
		}

		ATNState p = config.state;
		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);
			if ( c!=null ) {
				currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
			}
		}

		return currentAltReachedAcceptState;
	}",
L2113,L981,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_NESTED_COND_WITH_GUARD_CLAUSES,Replace Nested Conditional with Guard Clauses,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,"void _LOOK(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, Set<ATNConfig> lookBusy, BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF)",org.antlr.v4.runtime.atn.LL1Analyzer._LOOK(Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/misc/IntervalSet;Ljava/util/Set;Ljava/util/BitSet;ZZ)V,104,2,167,3,166,5,262,3,"protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (SingletonPredictionContext p : ctx) {
					ATNState returnState = atn.states.get(p.returnState);
//					System.out.println(""popping back to ""+retState);
					_LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);
				_LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);
			}
			else if ( t instanceof PredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}
}","protected void _LOOK(@NotNull ATNState s,
						 @Nullable ATNState stopState,
						 @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 @NotNull BitSet calledRuleStack,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

		if (s == stopState) {
			if (ctx == null) {
				look.add(Token.EPSILON);
				return;
			} else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}
		}

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (int i = 0; i < ctx.size(); i++) {
					ATNState returnState = atn.states.get(ctx.getReturnState(i));
//					System.out.println(""popping back to ""+retState);

					boolean removed = calledRuleStack.get(returnState.ruleIndex);
					try {
						calledRuleStack.clear(returnState.ruleIndex);
						_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
					}
					finally {
						if (removed) {
							calledRuleStack.set(returnState.ruleIndex);
						}
					}
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				if (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {
					continue;
				}

				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);

				try {
					calledRuleStack.set(((RuleTransition)t).target.ruleIndex);
					_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				finally {
					calledRuleStack.clear(((RuleTransition)t).target.ruleIndex);
				}
			}
			else if ( t instanceof PredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}
}",
L2427,L2178,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_NESTED_COND_WITH_GUARD_CLAUSES,Replace Nested Conditional with Guard Clauses,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,"void closure_(ATNConfig config, ATNConfigSet configs, Set<ATNConfig> closureBusy, boolean collectPredicates, boolean fullCtx, int depth)",org.antlr.v4.runtime.atn.ParserATNSimulator.closure_(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/Set;ZZI)V,1283,2,1329,3,1116,2,1168,3,"protected void closure_(@NotNull ATNConfig config,
							@NotNull ATNConfigSet configs,
							@NotNull Set<ATNConfig> closureBusy,
							boolean collectPredicates,
							boolean fullCtx,
							int depth)
	{
		ATNState p = config.state;
		// optimization
		if ( !p.onlyHasEpsilonTransitions() ) {
            configs.add(config, mergeCache);
//            if ( debug ) System.out.println(""added config ""+configs);
        }

		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			boolean continueCollecting =
				!(t instanceof ActionTransition) && collectPredicates;
			ATNConfig c = getEpsilonTarget(config, t, continueCollecting,
										   depth == 0, fullCtx);
			if ( c!=null ) {
				int newDepth = depth;
				if ( config.state instanceof RuleStopState) {
					assert !fullCtx;
					// target fell off end of rule; mark resulting c as having dipped into outer context
					// We can't get here if incoming config was rule stop and we had context
					// track how far we dip into outer context.  Might
					// come in handy and we avoid evaluating context dependent
					// preds if this is > 0.
					c.reachesIntoOuterContext++;
					configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
					assert newDepth > Integer.MIN_VALUE;
					newDepth--;
					if ( debug ) System.out.println(""dips into outer ctx: ""+c);
				}
				else if (t instanceof RuleTransition) {
					// latch when newDepth goes negative - once we step out of the entry context we can't return
					if (newDepth >= 0) {
						newDepth++;
					}
				}

				closureCheckingStopState(c, configs, closureBusy, continueCollecting,
										 fullCtx, newDepth);
			}
		}
	}","protected void closure_(@NotNull ATNConfig config,
							@NotNull ATNConfigSet configs,
							@NotNull Set<ATNConfig> closureBusy,
							boolean collectPredicates,
							boolean fullCtx,
							int depth)
	{
		ATNState p = config.state;
		// optimization
		if ( !p.onlyHasEpsilonTransitions() ) {
            configs.add(config, mergeCache);
//            if ( debug ) System.out.println(""added config ""+configs);
        }

		for (int i=0; i<p.getNumberOfTransitions(); i++) {
			Transition t = p.transition(i);
			boolean continueCollecting =
				!(t instanceof ActionTransition) && collectPredicates;
			ATNConfig c = getEpsilonTarget(config, t, continueCollecting,
										   depth == 0, fullCtx);
			if ( c!=null ) {
				int newDepth = depth;
				if ( config.state instanceof RuleStopState) {
					assert !fullCtx;
					// target fell off end of rule; mark resulting c as having dipped into outer context
					// We can't get here if incoming config was rule stop and we had context
					// track how far we dip into outer context.  Might
					// come in handy and we avoid evaluating context dependent
					// preds if this is > 0.

					if (!closureBusy.add(c)) {
						// avoid infinite recursion for right-recursive rules
						continue;
					}

					c.reachesIntoOuterContext++;
					configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
					assert newDepth > Integer.MIN_VALUE;
					newDepth--;
					if ( debug ) System.out.println(""dips into outer ctx: ""+c);
				}
				else if (t instanceof RuleTransition) {
					// latch when newDepth goes negative - once we step out of the entry context we can't return
					if (newDepth >= 0) {
						newDepth++;
					}
				}

				closureCheckingStopState(c, configs, closureBusy, continueCollecting,
										 fullCtx, newDepth);
			}
		}
	}",
L9795,L9790,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,CONSOLIDATE_DUPLICATE_COND_FRAGMENTS,Slide Statements,tool\src\org\antlr\v4\codegen\model\InvokeRule.java,tool\src\org\antlr\v4\codegen\model\InvokeRule.java,"InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST)",org.antlr.v4.codegen.model.InvokeRule.<init>(Lorg/antlr/v4/codegen/ParserFactory;Lorg/antlr/v4/tool/ast/GrammarAST;Lorg/antlr/v4/tool/ast/GrammarAST;)V,57,2,98,3,57,2,98,3,"public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {
		super(factory, ast);
		if ( ast.atnState!=null ) {
			RuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);
			stateNumber = ast.atnState.stateNumber;
		}

		this.name = ast.getText();
		CodeGenerator gen = factory.getGenerator();
		Rule r = factory.getGrammar().getRule(name);
		ctxName = gen.target.getRuleFunctionContextStructName(r);

		// TODO: move to factory
		RuleFunction rf = factory.getCurrentRuleFunction();
		if ( labelAST!=null ) {
			// for x=r, define <rule-context-type> x and list_x
			String label = labelAST.getText();
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {
				factory.defineImplicitLabel(ast, this);
				String listLabel = gen.target.getListLabel(label);
				RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);
				rf.addContextDecl(ast.getAltLabel(), l);
			}
			else {
				RuleContextDecl d = new RuleContextDecl(factory,label,ctxName);
				labels.add(d);
				rf.addContextDecl(ast.getAltLabel(), d);
			}
		}
		if ( ast.getChildCount()>0 ) {
			ActionAST arg = (ActionAST)ast.getChild(0);
			argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);
		}

		// If action refs rule as rulename not label, we need to define implicit label
		if ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {
			String label = gen.target.getImplicitRuleLabel(ast.getText());
			RuleContextDecl d = new RuleContextDecl(factory,label,ctxName);
			labels.add(d);
			rf.addContextDecl(ast.getAltLabel(), d);
		}
	}","public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {
		super(factory, ast);
		if ( ast.atnState!=null ) {
			RuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);
			stateNumber = ast.atnState.stateNumber;
		}

		this.name = ast.getText();
		CodeGenerator gen = factory.getGenerator();
		Rule r = factory.getGrammar().getRule(name);
		ctxName = gen.getTarget().getRuleFunctionContextStructName(r);

		// TODO: move to factory
		RuleFunction rf = factory.getCurrentRuleFunction();
		if ( labelAST!=null ) {
			// for x=r, define <rule-context-type> x and list_x
			String label = labelAST.getText();
			if ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {
				factory.defineImplicitLabel(ast, this);
				String listLabel = gen.getTarget().getListLabel(label);
				RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);
				rf.addContextDecl(ast.getAltLabel(), l);
			}
			else {
				RuleContextDecl d = new RuleContextDecl(factory,label,ctxName);
				labels.add(d);
				rf.addContextDecl(ast.getAltLabel(), d);
			}
		}
		if ( ast.getChildCount()>0 ) {
			ActionAST arg = (ActionAST)ast.getChild(0);
			argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);
		}

		// If action refs rule as rulename not label, we need to define implicit label
		if ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {
			String label = gen.getTarget().getImplicitRuleLabel(ast.getText());
			RuleContextDecl d = new RuleContextDecl(factory,label,ctxName);
			labels.add(d);
			rf.addContextDecl(ast.getAltLabel(), d);
		}
	}",
L9861,L8698,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_NESTED_COND_WITH_GUARD_CLAUSES,Slide Statements,tool\src\org\antlr\v4\codegen\model\Lexer.java,tool\src\org\antlr\v4\codegen\model\Lexer.java,"Lexer(OutputModelFactory factory, LexerFile file)",org.antlr.v4.codegen.model.Lexer.<init>(Lorg/antlr/v4/codegen/OutputModelFactory;Lorg/antlr/v4/codegen/model/LexerFile;)V,64,2,104,3,64,2,104,3,"public Lexer(OutputModelFactory factory, LexerFile file) {
		this.factory = factory;
		this.file = file; // who contains us?
		Grammar g = factory.getGrammar();
		grammarFileName = new File(g.fileName).getName();
		name = g.getRecognizerName();
		tokens = new LinkedHashMap<String,Integer>();
		LexerGrammar lg = (LexerGrammar)g;
		atn = new SerializedATN(factory, lg.atn);
		modes = lg.modes.keySet();

		for (String t : g.tokenNameToTypeMap.keySet()) {
			Integer ttype = g.tokenNameToTypeMap.get(t);
			if ( ttype>0 ) tokens.put(t, ttype);
		}

		tokenNames = g.getTokenDisplayNames();
        for (int i = 0; i < tokenNames.length; i++) {
            if ( tokenNames[i]==null ) continue;
            CodeGenerator gen = factory.getGenerator();
            if ( tokenNames[i].charAt(0)=='\'' ) {
				boolean addQuotes = false;
				tokenNames[i] =
					gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen,
																			tokenNames[i],
																			addQuotes);
				tokenNames[i] = ""\""'""+tokenNames[i]+""'\"""";
            }
            else {
                tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);
            }
        }
		ruleNames = g.rules.keySet();

		if (g.getOptionString(""superClass"") != null) {
			superClass = new ActionText(null, g.getOptionString(""superClass""));
		}
		else {
			superClass = new DefaultLexerSuperClass();
		}
	}

}","public Lexer(OutputModelFactory factory, LexerFile file) {
		this.factory = factory;
		this.file = file; // who contains us?
		Grammar g = factory.getGrammar();
		grammarFileName = new File(g.fileName).getName();
		name = g.getRecognizerName();
		tokens = new LinkedHashMap<String,Integer>();
		LexerGrammar lg = (LexerGrammar)g;
		atn = new SerializedATN(factory, lg.atn);
		modes = lg.modes.keySet();

		for (String t : g.tokenNameToTypeMap.keySet()) {
			Integer ttype = g.tokenNameToTypeMap.get(t);
			if ( ttype>0 ) tokens.put(t, ttype);
		}

		tokenNames = g.getTokenDisplayNames();
        for (int i = 0; i < tokenNames.length; i++) {
            if ( tokenNames[i]==null ) continue;
            CodeGenerator gen = factory.getGenerator();
            if ( tokenNames[i].charAt(0)=='\'' ) {
				boolean addQuotes = false;
				tokenNames[i] =
					gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,
																			tokenNames[i],
																			addQuotes);
				tokenNames[i] = ""\""'""+tokenNames[i]+""'\"""";
            }
            else {
                tokenNames[i] = gen.getTarget().getTargetStringLiteralFromString(tokenNames[i], true);
            }
        }
		ruleNames = g.rules.keySet();

		if (g.getOptionString(""superClass"") != null) {
			superClass = new ActionText(null, g.getOptionString(""superClass""));
		}
		else {
			superClass = new DefaultLexerSuperClass();
		}
	}

}",
L7413,L7392,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,INTRODUCE_ASSERTION,Introduce Assertion,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,tool\src\org\antlr\v4\analysis\AnalysisPipeline.java,void processParser(),org.antlr.v4.analysis.AnalysisPipeline.processParser()V,82,2,99,3,82,2,101,3,"protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}","protected void processParser() {
		g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);
		for (DecisionState s : g.atn.decisionToState) {
            g.tool.log(""LL1"", ""\nDECISION ""+s.decision+"" in rule ""+g.getRule(s.ruleIndex).name);
			IntervalSet[] look;
			if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)
				look = new IntervalSet[s.getNumberOfTransitions()+1];
			}
			else {
				LL1Analyzer anal = new LL1Analyzer(g.atn);
				look = anal.getDecisionLookahead(s);
				g.tool.log(""LL1"", ""look="" + Arrays.toString(look));
			}

			assert s.decision + 1 >= g.decisionLOOK.size();
			Utils.setSize(g.decisionLOOK, s.decision+1);
			g.decisionLOOK.set(s.decision, look);
			g.tool.log(""LL1"", ""LL(1)? "" + disjoint(look));
		}
	}",
L25880,L832,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_MAGIC_NUMBER_WITH_CONSTANT,Replace Magic Literal,runtime\Java\src\org\antlr\v4\runtime\atn\PredictionContext.java,runtime\Java\src\org\antlr\v4\runtime\atn\PredictionContext.java,"int calculateHashCode(PredictionContext parent, int returnState)",org.antlr.v4.runtime.atn.PredictionContext.calculateHashCode(Lorg/antlr/v4/runtime/atn/PredictionContext;I)I,124,2,126,3,147,2,153,3,"protected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
		return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
	}","protected static int calculateHashCode(PredictionContext parent, int returnState) {
		int hash = MurmurHash.initialize(INITIAL_HASH);
		hash = MurmurHash.update(hash, parent);
		hash = MurmurHash.update(hash, returnState);
		hash = MurmurHash.finish(hash, 2);
		return hash;
	}",
L3650,L1370,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_MAGIC_NUMBER_WITH_CONSTANT,Replace Magic Literal,runtime\Java\src\org\antlr\v4\runtime\dfa\DFAState.java,runtime\Java\src\org\antlr\v4\runtime\dfa\DFAState.java,int hashCode(),org.antlr.v4.runtime.dfa.DFAState.hashCode()I,152,2,161,3,152,2,158,3,"public int hashCode() {
		int h = 7;
		if ( configs!=null ) {
			for (ATNConfig c : configs) {
				h = h * 31 ^ c.alt;
				h = h * 31 ^ c.state.stateNumber;
			}
		}
		return h;
	}","public int hashCode() {
		int hash = MurmurHash.initialize(7);
		hash = MurmurHash.update(hash, configs.hashCode());
		hash = MurmurHash.finish(hash, 1);
		return hash;
	}",
L2093,L1307,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,"ATNState stateFactory(int type, int ruleIndex)",org.antlr.v4.runtime.atn.ATNSimulator.stateFactory(II)Lorg/antlr/v4/runtime/atn/ATNState;,478,2,501,3,191,2,194,3,"public static ATNState stateFactory(int type, int ruleIndex) {
		ATNState s;
		switch (type) {
			case ATNState.INVALID_TYPE: return null;
			case ATNState.BASIC : s = new BasicState(); break;
			case ATNState.RULE_START : s = new RuleStartState(); break;
			case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;
			case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;
			case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;
			case ATNState.TOKEN_START : s = new TokensStartState(); break;
			case ATNState.RULE_STOP : s = new RuleStopState(); break;
			case ATNState.BLOCK_END : s = new BlockEndState(); break;
			case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;
			case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;
			case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;
			case ATNState.LOOP_END : s = new LoopEndState(); break;
            default :
				String message = String.format(Locale.getDefault(), ""The specified state type %d is not valid."", type);
				throw new IllegalArgumentException(message);
		}

		s.ruleIndex = ruleIndex;
		return s;
	}","public static ATNState stateFactory(int type, int ruleIndex) {
		return new ATNDeserializer().stateFactory(type, ruleIndex);
	}","public class ATNDeserializer {
protected ATNState stateFactory(int type, int ruleIndex) {
		ATNState s;
		switch (type) {
			case ATNState.INVALID_TYPE: return null;
			case ATNState.BASIC : s = new BasicState(); break;
			case ATNState.RULE_START : s = new RuleStartState(); break;
			case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;
			case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;
			case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;
			case ATNState.TOKEN_START : s = new TokensStartState(); break;
			case ATNState.RULE_STOP : s = new RuleStopState(); break;
			case ATNState.BLOCK_END : s = new BlockEndState(); break;
			case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;
			case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;
			case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;
			case ATNState.LOOP_END : s = new LoopEndState(); break;
			default :
				String message = String.format(Locale.getDefault(), ""The specified state type %d is not valid."", type);
				throw new IllegalArgumentException(message);
		}

		s.ruleIndex = ruleIndex;
		return s;
	}
}"
L2083,L1307,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,"Transition edgeFactory(ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets)",org.antlr.v4.runtime.atn.ATNSimulator.edgeFactory(Lorg/antlr/v4/runtime/atn/ATN;IIIIIILjava/util/List;)Lorg/antlr/v4/runtime/atn/Transition;,439,2,476,3,180,2,186,3,"public static Transition edgeFactory(@NotNull ATN atn,
										 int type, int src, int trg,
										 int arg1, int arg2, int arg3,
										 List<IntervalSet> sets)
	{
		ATNState target = atn.states.get(trg);
		switch (type) {
			case Transition.EPSILON : return new EpsilonTransition(target);
			case Transition.RANGE :
				if (arg3 != 0) {
					return new RangeTransition(target, Token.EOF, arg2);
				}
				else {
					return new RangeTransition(target, arg1, arg2);
				}
			case Transition.RULE :
				RuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);
				return rt;
			case Transition.PREDICATE :
				PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);
				return pt;
			case Transition.ATOM :
				if (arg3 != 0) {
					return new AtomTransition(target, Token.EOF);
				}
				else {
					return new AtomTransition(target, arg1);
				}
			case Transition.ACTION :
				ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);
				return a;
			case Transition.SET : return new SetTransition(target, sets.get(arg1));
			case Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));
			case Transition.WILDCARD : return new WildcardTransition(target);
		}

		throw new IllegalArgumentException(""The specified transition type is not valid."");
	}","public static Transition edgeFactory(@NotNull ATN atn,
										 int type, int src, int trg,
										 int arg1, int arg2, int arg3,
										 List<IntervalSet> sets)
	{
		return new ATNDeserializer().edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets);
	}","public class ATNDeserializer {
protected Transition edgeFactory(@NotNull ATN atn,
										 int type, int src, int trg,
										 int arg1, int arg2, int arg3,
										 List<IntervalSet> sets)
	{
		ATNState target = atn.states.get(trg);
		switch (type) {
			case Transition.EPSILON : return new EpsilonTransition(target);
			case Transition.RANGE :
				if (arg3 != 0) {
					return new RangeTransition(target, Token.EOF, arg2);
				}
				else {
					return new RangeTransition(target, arg1, arg2);
				}
			case Transition.RULE :
				RuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, arg3, target);
				return rt;
			case Transition.PREDICATE :
				PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);
				return pt;
			case Transition.PRECEDENCE:
				return new PrecedencePredicateTransition(target, arg1);
			case Transition.ATOM :
				if (arg3 != 0) {
					return new AtomTransition(target, Token.EOF);
				}
				else {
					return new AtomTransition(target, arg1);
				}
			case Transition.ACTION :
				ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);
				return a;
			case Transition.SET : return new SetTransition(target, sets.get(arg1));
			case Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));
			case Transition.WILDCARD : return new WildcardTransition(target);
		}

		throw new IllegalArgumentException(""The specified transition type is not valid."");
	}
}"
L2079,L1307,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,"UUID toUUID(char[] data, int offset)",org.antlr.v4.runtime.atn.ATNSimulator.toUUID([CI)Ljava/util/UUID;,432,2,436,3,171,2,173,3,"public static UUID toUUID(char[] data, int offset) {
		long leastSigBits = toLong(data, offset);
		long mostSigBits = toLong(data, offset + 4);
		return new UUID(mostSigBits, leastSigBits);
	}","public static UUID toUUID(char[] data, int offset) {
		return ATNDeserializer.toUUID(data, offset);
	}","protected static UUID toUUID(char[] data, int offset) {
		long leastSigBits = toLong(data, offset);
		long mostSigBits = toLong(data, offset + 4);
		return new UUID(mostSigBits, leastSigBits);
	}"
L2075,L1307,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ATNSimulator.java,"long toLong(char[] data, int offset)",org.antlr.v4.runtime.atn.ATNSimulator.toLong([CI)J,427,2,430,3,163,2,165,3,"public static long toLong(char[] data, int offset) {
		long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;
		return lowOrder | ((long)toInt32(data, offset + 2) << 32);
	}","public static long toLong(char[] data, int offset) {
		return ATNDeserializer.toLong(data, offset);
	}","public class ATNDeserializer {
protected static long toLong(char[] data, int offset) {
		long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;
		return lowOrder | ((long)toInt32(data, offset + 2) << 32);
	}
}"
L1276,L886,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,INTRODUCE_ASSERTION,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\PredictionContext.java,runtime\Java\src\org\antlr\v4\runtime\atn\PredictionContext.java,"PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache)",org.antlr.v4.runtime.atn.PredictionContext.merge(Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/atn/PredictionContext;ZLorg/antlr/v4/runtime/misc/DoubleKeyMap;)Lorg/antlr/v4/runtime/atn/PredictionContext;,171,2,201,3,169,2,201,3,"public static PredictionContext merge(
		PredictionContext a, PredictionContext b,
		boolean rootIsWildcard,
		DoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)
	{
		// share same graph if both same
		if ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;

		if ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
			return mergeSingletons((SingletonPredictionContext)a,
								   (SingletonPredictionContext)b,
								   rootIsWildcard, mergeCache);
		}

		// At least one of a or b is array
		// If one is $ and rootIsWildcard, return $ as * wildcard
		if ( rootIsWildcard ) {
			if ( a instanceof EmptyPredictionContext ) return a;
			if ( b instanceof EmptyPredictionContext ) return b;
		}

		// convert singleton so both are arrays to normalize
		if ( a instanceof SingletonPredictionContext ) {
			a = new ArrayPredictionContext((SingletonPredictionContext)a);
		}
		if ( b instanceof SingletonPredictionContext) {
			b = new ArrayPredictionContext((SingletonPredictionContext)b);
		}
		return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,
						   rootIsWildcard, mergeCache);
	}","public static PredictionContext merge(
		PredictionContext a, PredictionContext b,
		boolean rootIsWildcard,
		DoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)
	{
		assert a!=null && b!=null; // must be empty context, never null

		// share same graph if both same
		if ( a==b || a.equals(b) ) return a;

		if ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
			return mergeSingletons((SingletonPredictionContext)a,
								   (SingletonPredictionContext)b,
								   rootIsWildcard, mergeCache);
		}

		// At least one of a or b is array
		// If one is $ and rootIsWildcard, return $ as * wildcard
		if ( rootIsWildcard ) {
			if ( a instanceof EmptyPredictionContext ) return a;
			if ( b instanceof EmptyPredictionContext ) return b;
		}

		// convert singleton so both are arrays to normalize
		if ( a instanceof SingletonPredictionContext ) {
			a = new ArrayPredictionContext((SingletonPredictionContext)a);
		}
		if ( b instanceof SingletonPredictionContext) {
			b = new ArrayPredictionContext((SingletonPredictionContext)b);
		}
		return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,
						   rootIsWildcard, mergeCache);
	}",
L7856,L7014,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\tree\gui\TreeViewer.java,runtime\Java\src\org\antlr\v4\runtime\tree\gui\TreeViewer.java,void setRuleNames(List<String> ruleNames),org.antlr.v4.runtime.tree.gui.TreeViewer.setRuleNames(Ljava/util/List;)V,161,2,172,3,702,2,704,3,"public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {
		setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));
        boolean useIdentity = true; // compare node identity
		this.treeLayout =
			new TreeLayout<Tree>(new TreeLayoutAdaptor(tree),
								 new TreeViewer.VariableExtentProvide(this),
								 new DefaultConfiguration<Tree>(gapBetweenLevels,
																gapBetweenNodes),
                                 useIdentity);
		updatePreferredSize();
		setFont(font);
	}","public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {
		setRuleNames(ruleNames);
		if ( tree!=null ) {
			setTree(tree);
		}
		setFont(font);
	}

public void setTree(Tree root) {
		if ( root!=null ) {
			boolean useIdentity = true; // compare node identity
			this.treeLayout =
				new TreeLayout<Tree>(new TreeLayoutAdaptor(root),
									 new TreeViewer.VariableExtentProvide(this),
									 new DefaultConfiguration<Tree>(gapBetweenLevels,
																	gapBetweenNodes),
									 useIdentity);
			// Let the UI display this new AST.
			updatePreferredSize();
		}
		else {
			this.treeLayout = null;
			repaint();
		}
	}
public void setRuleNames(List<String> ruleNames) {
		setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));
	}",
L3524,L1094,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REMOVE_ASSIGNMENT_TO_PARAMETERS,Split Variable,runtime\Java\src\org\antlr\v4\runtime\atn\RuleTransition.java,runtime\Java\src\org\antlr\v4\runtime\atn\RuleTransition.java,"RuleTransition(RuleStartState ruleStart, int ruleIndex, ATNState followState)",org.antlr.v4.runtime.atn.RuleTransition.<init>(Lorg/antlr/v4/runtime/atn/RuleStartState;ILorg/antlr/v4/runtime/atn/ATNState;)V,44,2,51,3,50,2,56,3,"
public RuleTransition(@NotNull RuleStartState ruleStart,

						  int ruleIndex,

						  @NotNull ATNState followState)

	{

		super(ruleStart);

		this.ruleIndex = ruleIndex;

		this.followState = followState;

	}","public RuleTransition(@NotNull RuleStartState ruleStart,

						  int ruleIndex,

						  @NotNull ATNState followState)

	{

		this(ruleStart, ruleIndex, 0, followState);

	}",
L2447,L2315,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,ADD_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"void accept(CharStream input, LexerActionExecutor lexerActionExecutor, int startIndex, int index, int line, int charPos)",org.antlr.v4.runtime.atn.LexerATNSimulator.accept(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerActionExecutor;IIII)V,358,2,374,3,365,2,383,3,"protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,
						  int index, int line, int charPos)
	{
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""ACTION %s:%d\n"", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);
		}

		if ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);

		// seek to after last char in token
		input.seek(index);
		this.line = line;
		this.charPositionInLine = charPos;
		if (input.LA(1) != IntStream.EOF) {
			consume(input);
		}
	}","protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,
						  int startIndex, int index, int line, int charPos)
	{
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""ACTION %s\n"", lexerActionExecutor);
		}

		// seek to after last char in token
		input.seek(index);
		this.line = line;
		this.charPositionInLine = charPos;
		if (input.LA(1) != IntStream.EOF) {
			consume(input);
		}

		if (lexerActionExecutor != null && recog != null) {
			lexerActionExecutor.execute(recog, input, startIndex);
		}
	}",
L24470,L2315,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REMOVE_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\LexerATNSimulator.java,"void accept(CharStream input, LexerActionExecutor lexerActionExecutor, int startIndex, int index, int line, int charPos)",org.antlr.v4.runtime.atn.LexerATNSimulator.accept(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerActionExecutor;IIII)V,358,2,374,3,365,2,383,3,"protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,
						  int index, int line, int charPos)
	{
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""ACTION %s:%d\n"", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);
		}

		if ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);

		// seek to after last char in token
		input.seek(index);
		this.line = line;
		this.charPositionInLine = charPos;
		if (input.LA(1) != IntStream.EOF) {
			consume(input);
		}
	}","protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,
						  int startIndex, int index, int line, int charPos)
	{
		if ( debug ) {
			System.out.format(Locale.getDefault(), ""ACTION %s\n"", lexerActionExecutor);
		}

		// seek to after last char in token
		input.seek(index);
		this.line = line;
		this.charPositionInLine = charPos;
		if (input.LA(1) != IntStream.EOF) {
			consume(input);
		}

		if (lexerActionExecutor != null && recog != null) {
			lexerActionExecutor.execute(recog, input, startIndex);
		}
	}",
L2288,L2178,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REMOVE_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,"int execATNWithFullContext(DFA dfa, DFAState D, ATNConfigSet s0, TokenStream input, int startIndex, ParserRuleContext outerContext)",runtime\Java\src\org\antlr\v4\runtime\atn\ParserATNSimulator.java,776,2,907,3,596,2,715,3,"public int execATNWithFullContext(DFA dfa,
									  DFAState D, // how far we got before failing over
									  @NotNull ATNConfigSet s0,
									  @NotNull TokenStream input, int startIndex,
									  ParserRuleContext outerContext,
									  int SLL_min_alt) // todo: is this in D as min ambig alts?
	{
		// caller must have write lock on dfa
		retry_with_context++;
		reportAttemptingFullContext(dfa, s0, startIndex, input.index());

		if ( debug || debug_list_atn_decisions ) {
			System.out.println(""execATNWithFullContext ""+s0);
		}
		boolean fullCtx = true;
		boolean foundExactAmbig = false;
		ATNConfigSet reach = null;
		ATNConfigSet previous = s0;
		input.seek(startIndex);
		int t = input.LA(1);
		int predictedAlt;
		while (true) { // while more work
//			System.out.println(""LL REACH ""+getLookaheadName(input)+
//							   "" from configs.size=""+previous.size()+
//							   "" line ""+input.LT(1).getLine()+"":""+input.LT(1).getCharPositionInLine());
			reach = computeReachSet(previous, t, fullCtx);
			if ( reach==null ) {
				// if any configs in previous dipped into outer context, that
				// means that input up to t actually finished entry rule
				// at least for LL decision. Full LL doesn't dip into outer
				// so don't need special case.
				// We will get an error no matter what so delay until after
				// decision; better error message. Also, no reachable target
				// ATN states in SLL implies LL will also get nowhere.
				// If conflict in states that dip out, choose min since we
				// will get error no matter what.
				int alt = getAltThatFinishedDecisionEntryRule(previous);
				if ( alt!=ATN.INVALID_ALT_NUMBER ) {
					return alt;
				}
				throw noViableAlt(input, outerContext, previous, startIndex);
			}

			Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);
			if ( debug ) {
				System.out.println(""LL altSubSets=""+altSubSets+
								   "", predict=""+PredictionMode.getUniqueAlt(altSubSets)+
								   "", resolvesToJustOneViableAlt=""+
									   PredictionMode.resolvesToJustOneViableAlt(altSubSets));
			}

//			System.out.println(""altSubSets: ""+altSubSets);
			reach.uniqueAlt = getUniqueAlt(reach);
			// unique prediction?
			if ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {
				predictedAlt = reach.uniqueAlt;
				break;
			}
			if ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {
				predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
				if ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {
					break;
				}
			}
			else {
				// In exact ambiguity mode, we never try to terminate early.
				// Just keeps scarfing until we know what the conflict is
				if ( PredictionMode.allSubsetsConflict(altSubSets) &&
					 PredictionMode.allSubsetsEqual(altSubSets) )
				{
					foundExactAmbig = true;
					predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
					break;
				}
				// else there are multiple non-conflicting subsets or
				// we're not sure what the ambiguity is yet.
				// So, keep going.
			}

			previous = reach;
			if (t != IntStream.EOF) {
				input.consume();
				t = input.LA(1);
			}
		}

		// If the configuration set uniquely predicts an alternative,
		// without conflict, then we know that it's a full LL decision
		// not SLL.
		if ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {
			retry_with_context_indicates_no_conflict++;
			reportContextSensitivity(dfa, reach, startIndex, input.index());
			if ( predictedAlt == SLL_min_alt ) {
				retry_with_context_predicts_same_alt++;
			}
			return predictedAlt;
		}

		// We do not check predicates here because we have checked them
		// on-the-fly when doing full context prediction.

		/*
		In non-exact ambiguity detection mode, we might	actually be able to
		detect an exact ambiguity, but I'm not going to spend the cycles
		needed to check. We only emit ambiguity warnings in exact ambiguity
		mode.

		For example, we might know that we have conflicting configurations.
		But, that does not mean that there is no way forward without a
		conflict. It's possible to have nonconflicting alt subsets as in:

		   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

		from

		   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
			(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]

		In this case, (17,1,[5 $]) indicates there is some next sequence that
		would resolve this without conflict to alternative 1. Any other viable
		next sequence, however, is associated with a conflict.  We stop
		looking for input because no amount of further lookahead will alter
		the fact that we should predict alternative 1.  We just can't say for
		sure that there is an ambiguity without looking further.
		*/
		if ( foundExactAmbig ) {
			reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);
		}

		return predictedAlt;
	}","protected int execATNWithFullContext(DFA dfa,
										 DFAState D, // how far we got before failing over
										 @NotNull ATNConfigSet s0,
										 @NotNull TokenStream input, int startIndex,
										 ParserRuleContext outerContext)
	{
		if ( debug || debug_list_atn_decisions ) {
			System.out.println(""execATNWithFullContext ""+s0);
		}
		boolean fullCtx = true;
		boolean foundExactAmbig = false;
		ATNConfigSet reach = null;
		ATNConfigSet previous = s0;
		input.seek(startIndex);
		int t = input.LA(1);
		int predictedAlt;
		while (true) { // while more work
//			System.out.println(""LL REACH ""+getLookaheadName(input)+
//							   "" from configs.size=""+previous.size()+
//							   "" line ""+input.LT(1).getLine()+"":""+input.LT(1).getCharPositionInLine());
			reach = computeReachSet(previous, t, fullCtx);
			if ( reach==null ) {
				// if any configs in previous dipped into outer context, that
				// means that input up to t actually finished entry rule
				// at least for LL decision. Full LL doesn't dip into outer
				// so don't need special case.
				// We will get an error no matter what so delay until after
				// decision; better error message. Also, no reachable target
				// ATN states in SLL implies LL will also get nowhere.
				// If conflict in states that dip out, choose min since we
				// will get error no matter what.
				int alt = getAltThatFinishedDecisionEntryRule(previous);
				if ( alt!=ATN.INVALID_ALT_NUMBER ) {
					return alt;
				}
				throw noViableAlt(input, outerContext, previous, startIndex);
			}

			Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);
			if ( debug ) {
				System.out.println(""LL altSubSets=""+altSubSets+
								   "", predict=""+PredictionMode.getUniqueAlt(altSubSets)+
								   "", resolvesToJustOneViableAlt=""+
									   PredictionMode.resolvesToJustOneViableAlt(altSubSets));
			}

//			System.out.println(""altSubSets: ""+altSubSets);
			reach.uniqueAlt = getUniqueAlt(reach);
			// unique prediction?
			if ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {
				predictedAlt = reach.uniqueAlt;
				break;
			}
			if ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {
				predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
				if ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {
					break;
				}
			}
			else {
				// In exact ambiguity mode, we never try to terminate early.
				// Just keeps scarfing until we know what the conflict is
				if ( PredictionMode.allSubsetsConflict(altSubSets) &&
					 PredictionMode.allSubsetsEqual(altSubSets) )
				{
					foundExactAmbig = true;
					predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
					break;
				}
				// else there are multiple non-conflicting subsets or
				// we're not sure what the ambiguity is yet.
				// So, keep going.
			}

			previous = reach;
			if (t != IntStream.EOF) {
				input.consume();
				t = input.LA(1);
			}
		}

		// If the configuration set uniquely predicts an alternative,
		// without conflict, then we know that it's a full LL decision
		// not SLL.
		if ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {
			reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index());
			return predictedAlt;
		}

		// We do not check predicates here because we have checked them
		// on-the-fly when doing full context prediction.

		/*
		In non-exact ambiguity detection mode, we might	actually be able to
		detect an exact ambiguity, but I'm not going to spend the cycles
		needed to check. We only emit ambiguity warnings in exact ambiguity
		mode.

		For example, we might know that we have conflicting configurations.
		But, that does not mean that there is no way forward without a
		conflict. It's possible to have nonconflicting alt subsets as in:

		   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

		from

		   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
			(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]

		In this case, (17,1,[5 $]) indicates there is some next sequence that
		would resolve this without conflict to alternative 1. Any other viable
		next sequence, however, is associated with a conflict.  We stop
		looking for input because no amount of further lookahead will alter
		the fact that we should predict alternative 1.  We just can't say for
		sure that there is an ambiguity without looking further.
		*/
		reportAmbiguity(dfa, D, startIndex, input.index(), foundExactAmbig, null, reach);

		return predictedAlt;
	}",
L2588,L832,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,REPLACE_METHOD_WITH_METHOD_OBJECT,Replace Function with Command,runtime\Java\src\org\antlr\v4\runtime\atn\PredictionContext.java,runtime\Java\src\org\antlr\v4\runtime\atn\PredictionContext.java,"int calculateHashCode(PredictionContext parent, int returnState)",org.antlr.v4.runtime.atn.PredictionContext.calculateHashCode(Lorg/antlr/v4/runtime/atn/PredictionContext;I)I,124,,126,,147,2,153,3,"protected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {
		return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;
	}","protected static int calculateHashCode(PredictionContext parent, int returnState) {
		int hash = MurmurHash.initialize(INITIAL_HASH);
		hash = MurmurHash.update(hash, parent);
		hash = MurmurHash.update(hash, returnState);
		hash = MurmurHash.finish(hash, 2);
		return hash;
	}","public final class MurmurHash {

	private static final int DEFAULT_SEED = 0;

	/**
	 * Initialize the hash using the default seed value.
	 *
	 * @return the intermediate hash value
	 */
	public static int initialize() {
		return initialize(DEFAULT_SEED);
	}

	/**
	 * Initialize the hash using the specified {@code seed}.
	 *
	 * @param seed the seed
	 * @return the intermediate hash value
	 */
	public static int initialize(int seed) {
		return seed;
	}

	/**
	 * Update the intermediate hash value for the next input {@code value}.
	 *
	 * @param hash the intermediate hash value
	 * @param value the value to add to the current hash
	 * @return the updated intermediate hash value
	 */
	public static int update(int hash, int value) {
		final int c1 = 0xCC9E2D51;
		final int c2 = 0x1B873593;
		final int r1 = 15;
		final int r2 = 13;
		final int m = 5;
		final int n = 0xE6546B64;

		int k = value;
		k = k * c1;
		k = (k << r1) | (k >>> (32 - r1));
		k = k * c2;

		hash = hash ^ k;
		hash = (hash << r2) | (hash >>> (32 - r2));
		hash = hash * m + n;

		return hash;
	}

	/**
	 * Update the intermediate hash value for the next input {@code value}.
	 *
	 * @param hash the intermediate hash value
	 * @param value the value to add to the current hash
	 * @return the updated intermediate hash value
	 */
	public static int update(int hash, Object value) {
		return update(hash, value != null ? value.hashCode() : 0);
	}

	/**
	 * Apply the final computation steps to the intermediate value {@code hash}
	 * to form the final result of the MurmurHash 3 hash function.
	 *
	 * @param hash the intermediate hash value
	 * @param numberOfWords the number of integer values added to the hash
	 * @return the final hash result
	 */
	public static int finish(int hash, int numberOfWords) {
		hash = hash ^ (numberOfWords * 4);
		hash = hash ^ (hash >>> 16);
		hash = hash * 0x85EBCA6B;
		hash = hash ^ (hash >>> 13);
		hash = hash * 0xC2B2AE35;
		hash = hash ^ (hash >>> 16);
		return hash;
	}

	/**
	 * Utility function to compute the hash code of an array using the
	 * MurmurHash algorithm.
	 *
	 * @param <T> the array element type
	 * @param data the array data
	 * @param seed the seed for the MurmurHash algorithm
	 * @return the hash code of the data
	 */
	public static <T> int hashCode(T[] data, int seed) {
		int hash = initialize(seed);
		for (T value : data) {
			hash = update(hash, value);
		}

		hash = finish(hash, data.length);
		return hash;
	}

	private MurmurHash() {
	}
}"
L3072,L3045,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,ADD_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\BaseErrorListener.java,runtime\Java\src\org\antlr\v4\runtime\BaseErrorListener.java,"void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs)",org.antlr.v4.runtime.BaseErrorListener.reportContextSensitivity(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/dfa/DFA;IIILorg/antlr/v4/runtime/atn/ATNConfigSet;)V,71,2,77,3,72,2,80,3,"public void reportContextSensitivity(Parser recognizer,
										 DFA dfa,
										 int startIndex,
										 int stopIndex,
										 ATNConfigSet configs)
	{
	}","public void reportContextSensitivity(Parser recognizer,
										 DFA dfa,
										 int startIndex,
										 int stopIndex,
										 int prediction,
										 ATNConfigSet configs)
	{
	}",
L2113,L981,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,ADD_PARAMETER,Change Function Declaration,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,runtime\Java\src\org\antlr\v4\runtime\atn\LL1Analyzer.java,"void _LOOK(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, Set<ATNConfig> lookBusy, BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF)",org.antlr.v4.runtime.atn.LL1Analyzer._LOOK(Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/misc/IntervalSet;Ljava/util/Set;Ljava/util/BitSet;ZZ)V,104,2,166,3,166,5,262,3,"protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (SingletonPredictionContext p : ctx) {
					ATNState returnState = atn.states.get(p.returnState);
//					System.out.println(""popping back to ""+retState);
					_LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);
				_LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);
			}
			else if ( t instanceof PredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}","protected void _LOOK(@NotNull ATNState s,
						 @Nullable ATNState stopState,
						 @Nullable PredictionContext ctx,
						 @NotNull IntervalSet look,
                         @NotNull Set<ATNConfig> lookBusy,
						 @NotNull BitSet calledRuleStack,
						 boolean seeThruPreds, boolean addEOF)
	{
//		System.out.println(""_LOOK(""+s.stateNumber+"", ctx=""+ctx);
        ATNConfig c = new ATNConfig(s, 0, ctx);
        if ( !lookBusy.add(c) ) return;

		if (s == stopState) {
			if (ctx == null) {
				look.add(Token.EPSILON);
				return;
			} else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}
		}

        if ( s instanceof RuleStopState ) {
            if ( ctx==null ) {
                look.add(Token.EPSILON);
                return;
            } else if (ctx.isEmpty() && addEOF) {
				look.add(Token.EOF);
				return;
			}

			if ( ctx != PredictionContext.EMPTY ) {
				// run thru all possible stack tops in ctx
				for (int i = 0; i < ctx.size(); i++) {
					ATNState returnState = atn.states.get(ctx.getReturnState(i));
//					System.out.println(""popping back to ""+retState);

					boolean removed = calledRuleStack.get(returnState.ruleIndex);
					try {
						calledRuleStack.clear(returnState.ruleIndex);
						_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
					}
					finally {
						if (removed) {
							calledRuleStack.set(returnState.ruleIndex);
						}
					}
				}
				return;
			}
        }

        int n = s.getNumberOfTransitions();
        for (int i=0; i<n; i++) {
			Transition t = s.transition(i);
			if ( t.getClass() == RuleTransition.class ) {
				if (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {
					continue;
				}

				PredictionContext newContext =
					SingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);

				try {
					calledRuleStack.set(((RuleTransition)t).target.ruleIndex);
					_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				finally {
					calledRuleStack.clear(((RuleTransition)t).target.ruleIndex);
				}
			}
			else if ( t instanceof PredicateTransition ) {
				if ( seeThruPreds ) {
					_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
				}
				else {
					look.add(HIT_PRED);
				}
			}
			else if ( t.isEpsilon() ) {
				_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
			}
			else if ( t.getClass() == WildcardTransition.class ) {
				look.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );
			}
			else {
//				System.out.println(""adding ""+ t);
				IntervalSet set = t.label();
				if (set != null) {
					if (t instanceof NotSetTransition) {
						set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
					}
					look.addAll(set);
				}
			}
		}
	}",
L5418,L543,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,5e05b71e8b1cd52cf0e77559786cc4c18dc85c37,https://github.com/antlr/antlr4,REMOVE_ASSIGNMENT_TO_PARAMETERS,Split Variable,runtime\Java\src\org\antlr\v4\runtime\Parser.java,runtime\Java\src\org\antlr\v4\runtime\Parser.java,"void enterOuterAlt(ParserRuleContext localctx, int altNum)",org.antlr.v4.runtime.Parser.enterOuterAlt(Lorg/antlr/v4/runtime/ParserRuleContext;I)V,,,,,,,,,"public void enterOuterAlt(ParserRuleContext localctx, int altNum) {
		// if we have new localctx, make sure we replace existing ctx
		// that is previous child of parse tree
		if ( _buildParseTrees && _ctx != localctx ) {
			ParserRuleContext parent = (ParserRuleContext)_ctx.parent;
			if ( parent!=null )	{
				parent.removeLastChild();
				parent.addChild(localctx);
			}
		}
		_ctx = localctx;
		_ctx.altNum = altNum;
	}","public void enterOuterAlt(ParserRuleContext localctx, int altNum) {
		// if we have new localctx, make sure we replace existing ctx
		// that is previous child of parse tree
		if ( _buildParseTrees && _ctx != localctx ) {
			ParserRuleContext parent = (ParserRuleContext)_ctx.parent;
			if ( parent!=null )	{
				parent.removeLastChild();
				parent.addChild(localctx);
			}
		}
		_ctx = localctx;
	}",
L3446,L3013,ad9bac95199736c270940c4037b7ee7174bacca6,3468a5fbd868ce63c4cb61782e9baddac2ed24ae,https://github.com/antlr/antlr4,EXTRACT_METHOD,Extract Function,runtime\Java\src\org\antlr\v4\runtime\DefaultErrorStrategy.java,,void reportMatch(Parser recognizer),org.antlr.v4.runtime.DefaultErrorStrategy.reportMatch(Lorg/antlr/v4/runtime/Parser;)V,340,2,358,3,109,2,112,3,"public Token singleTokenDeletion(Parser recognizer) {
		int nextTokenType = recognizer.getInputStream().LA(2);
		IntervalSet expecting = getExpectedTokens(recognizer);
		if ( expecting.contains(nextTokenType) ) {
			reportUnwantedToken(recognizer);
			/*
			System.err.println(""recoverFromMismatchedToken deleting ""+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   "" since ""+((TokenStream)recognizer.getInputStream()).LT(2)+
							   "" is what we want"");
			*/
			recognizer.consume(); // simply delete extra token
			// we want to return the token we're actually matching
			Token matchedSymbol = recognizer.getCurrentToken();
			endErrorCondition(recognizer);  // we know current token is correct
			return matchedSymbol;
		}
		return null;
	}","protected Token singleTokenDeletion(@NotNull Parser recognizer) {
		int nextTokenType = recognizer.getInputStream().LA(2);
		IntervalSet expecting = getExpectedTokens(recognizer);
		if ( expecting.contains(nextTokenType) ) {
			reportUnwantedToken(recognizer);
			/*
			System.err.println(""recoverFromMismatchedToken deleting ""+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   "" since ""+((TokenStream)recognizer.getInputStream()).LT(2)+
							   "" is what we want"");
			*/
			recognizer.consume(); // simply delete extra token
			// we want to return the token we're actually matching
			Token matchedSymbol = recognizer.getCurrentToken();
			reportMatch(recognizer);  // we know current token is correct
			return matchedSymbol;
		}
		return null;
	}
public void reportMatch(Parser recognizer) {
		endErrorCondition(recognizer);
	}",
L3949,L103,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,ADD_PARAMETER,Change Function Declaration,src\main\java\org\junit\experimental\theories\Theories.java,src\main\java\org\junit\experimental\theories\Theories.java,"TheoryAnchor(FrameworkMethod method, TestClass testClass)",org.junit.experimental.theories.Theories$TheoryAnchor.<init>(Lorg/junit/runners/model/FrameworkMethod;Lorg/junit/runners/model/TestClass;)V,76,2,78,3,78,3,81,4,"public TheoryAnchor(FrameworkMethod method) {
			fTestMethod= method;
		}","public TheoryAnchor(FrameworkMethod method, TestClass testClass) {
			fTestMethod= method;
            fTestClass= testClass;
		}",
L8052,L103,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,ADD_PARAMETER,Change Function Declaration,src\test\java\org\junit\tests\experimental\theories\extendingwithstubs\StubbedTheories.java,src\test\java\org\junit\tests\experimental\theories\extendingwithstubs\StubbedTheories.java,"StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass)",org.junit.tests.experimental.theories.extendingwithstubs.StubbedTheories$StubbedTheoryAnchor.<init>(Lorg/junit/runners/model/FrameworkMethod;Lorg/junit/runners/model/TestClass;)V,26,,28,,27,3,29,4,"public StubbedTheoryAnchor(FrameworkMethod method) {
			super(method);
		}","public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {
			super(method, testClass);
		}",
L4884,L4876,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,INLINE_TEMP,Inline Variable,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,void addFailure(Throwable targetException),org.junit.internal.runners.model.EachTestNotifier.addFailure(Ljava/lang/Throwable;)V,,,,,21,2,28,3,"public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			MultipleFailureException mfe= (MultipleFailureException) targetException;
			for (Throwable each : mfe.getFailures())
				addFailure(each);
			return;
		}
		fNotifier.fireTestFailure(new Failure(fDescription, targetException));
	}","public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			addMultipleFailureException((MultipleFailureException) targetException);
		} else {
			fNotifier
					.fireTestFailure(new Failure(fDescription, targetException));
		}
	}",
L5882,L103,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,EXTRACT_METHOD,Extract Function,src\main\java\org\junit\runners\BlockJUnit4ClassRunner.java,src\main\java\org\junit\runners\BlockJUnit4ClassRunner.java,"void runNotIgnored(FrameworkMethod method, EachTestNotifier eachNotifier)",org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(Lorg/junit/runners/model/FrameworkMethod;Lorg/junit/internal/runners/model/EachTestNotifier;)V,67,,84,,75,2,87,3,"protected void runChild(FrameworkMethod method, RunNotifier notifier) {
		EachTestNotifier eachNotifier= makeNotifier(method, notifier);
		if (method.getAnnotation(Ignore.class) != null) {
			eachNotifier.fireTestIgnored();
			return;
		}

		eachNotifier.fireTestStarted();
		try {
			methodBlock(method).evaluate();
		} catch (AssumptionViolatedException e) {
			eachNotifier.addFailedAssumption(e);
		} catch (Throwable e) {
			eachNotifier.addFailure(e);
		} finally {
			eachNotifier.fireTestFinished();
		}
	}","protected void runChild(FrameworkMethod method, RunNotifier notifier) {
		EachTestNotifier eachNotifier= makeNotifier(method, notifier);
		if (method.getAnnotation(Ignore.class) != null) {
			runIgnored(eachNotifier);
		} else {
			runNotIgnored(method, eachNotifier);
		}
	}

	private void runNotIgnored(FrameworkMethod method,
			EachTestNotifier eachNotifier) {
		eachNotifier.fireTestStarted();
		try {
			methodBlock(method).evaluate();
		} catch (AssumptionViolatedException e) {
			eachNotifier.addFailedAssumption(e);
		} catch (Throwable e) {
			eachNotifier.addFailure(e);
		} finally {
			eachNotifier.fireTestFinished();
		}
	}",
L5880,L103,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,EXTRACT_METHOD,Extract Function,src\main\java\org\junit\runners\BlockJUnit4ClassRunner.java,src\main\java\org\junit\runners\BlockJUnit4ClassRunner.java,void runIgnored(EachTestNotifier eachNotifier),org.junit.runners.BlockJUnit4ClassRunner.runIgnored(Lorg/junit/internal/runners/model/EachTestNotifier;)V,67,,84,,89,2,91,3,"protected void runChild(FrameworkMethod method, RunNotifier notifier) {
		EachTestNotifier eachNotifier= makeNotifier(method, notifier);
		if (method.getAnnotation(Ignore.class) != null) {
			eachNotifier.fireTestIgnored();
			return;
		}

		eachNotifier.fireTestStarted();
		try {
			methodBlock(method).evaluate();
		} catch (AssumptionViolatedException e) {
			eachNotifier.addFailedAssumption(e);
		} catch (Throwable e) {
			eachNotifier.addFailure(e);
		} finally {
			eachNotifier.fireTestFinished();
		}
	}","protected void runChild(FrameworkMethod method, RunNotifier notifier) {
		EachTestNotifier eachNotifier= makeNotifier(method, notifier);
		if (method.getAnnotation(Ignore.class) != null) {
			runIgnored(eachNotifier);
		} else {
			runNotIgnored(method, eachNotifier);
		}
	}

	private void runNotIgnored(FrameworkMethod method,
			EachTestNotifier eachNotifier) {
		eachNotifier.fireTestStarted();
		try {
			methodBlock(method).evaluate();
		} catch (AssumptionViolatedException e) {
			eachNotifier.addFailedAssumption(e);
		} catch (Throwable e) {
			eachNotifier.addFailure(e);
		} finally {
			eachNotifier.fireTestFinished();
		}
	}

	private void runIgnored(EachTestNotifier eachNotifier) {
		eachNotifier.fireTestIgnored();
	}",
L4889,L103,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,EXTRACT_METHOD,Extract Function,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,src\main\java\org\junit\internal\runners\model\EachTestNotifier.java,void addMultipleFailureException(MultipleFailureException mfe),org.junit.internal.runners.model.EachTestNotifier.addMultipleFailureException(Lorg/junit/internal/runners/model/MultipleFailureException;)V,,,,,30,2,33,3,"public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			MultipleFailureException mfe= (MultipleFailureException) targetException;
			for (Throwable each : mfe.getFailures())
				addFailure(each);
			return;
		}
		fNotifier.fireTestFailure(new Failure(fDescription, targetException));
	}","public void addFailure(Throwable targetException) {
		if (targetException instanceof MultipleFailureException) {
			addMultipleFailureException((MultipleFailureException) targetException);
		} else {
			fNotifier
					.fireTestFailure(new Failure(fDescription, targetException));
		}
	}

	private void addMultipleFailureException(MultipleFailureException mfe) {
		for (Throwable each : mfe.getFailures())
			addFailure(each);
	}",
L7126,L6751,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,INTRODUCE_ASSERTION,Introduce Assertion,src\test\java\org\junit\tests\experimental\categories\CategoryTest.java,src\test\java\org\junit\tests\experimental\categories\CategoryTest.java,void testCountWithExplicitFilter(),org.junit.tests.experimental.categories.CategoryTest.testCountWithExplicitFilter()V,128,,133,,129,,135,,"public void testCountWithExplicitFilter() throws Throwable {
		CategoryFilter include= CategoryFilter.include(SlowTests.class);
		Request baseRequest= Request.aClass(TestSuiteWithNoCategories.class);
		Result result= new JUnitCore().run(baseRequest.filterWith(include));
		assertTrue(result.wasSuccessful());
	}","public void testCountWithExplicitFilter() throws Throwable {
		CategoryFilter include= CategoryFilter.include(SlowTests.class);
		Request baseRequest= Request.aClass(TestSuiteWithNoCategories.class);
		Result result= new JUnitCore().run(baseRequest.filterWith(include));
		assertTrue(result.wasSuccessful());
		assertEquals(2, result.getRunCount());
	}",
L126,L118,5a3a326096cf65a58272ee89a5ef1c164cfd9d33,a30e87b6ac67f14a42b97d427bb1c8c6ba18cd87,https://github.com/junit-team/junit4,EXTRACT_METHOD,Extract Function,src\main\java\junit\framework\TestSuite.java,src\main\java\junit\framework\TestSuite.java,public TestSuite(final Class<? extends TestCase> theClass),junit.framework.TestSuite.<init>()V,128,,151,,128,,155,,"public TestSuite(final Class<? extends TestCase> theClass) {
		fName= theClass.getName();
		try {
			getTestConstructor(theClass); // Avoid generating multiple error messages
		} catch (NoSuchMethodException e) {
			addTest(warning(""Class ""+theClass.getName()+"" has no public constructor TestCase(String name) or TestCase()""));
			return;
		}

		if (!Modifier.isPublic(theClass.getModifiers())) {
			addTest(warning(""Class ""+theClass.getName()+"" is not public""));
			return;
		}

		Class<?> superClass= theClass;
		List<String> names= new ArrayList<String>();
		while (Test.class.isAssignableFrom(superClass)) {
			for (Method each : superClass.getDeclaredMethods())
				addTestMethod(each, names, theClass);
			superClass= superClass.getSuperclass();
		}
		if (fTests.size() == 0)
			addTest(warning(""No tests found in ""+theClass.getName()));
	}","public TestSuite(final Class<?> theClass) {
		addTestsFromTestCase(theClass);
	}

	private void addTestsFromTestCase(final Class<?> theClass) {
		fName= theClass.getName();
		try {
			getTestConstructor(theClass); // Avoid generating multiple error messages
		} catch (NoSuchMethodException e) {
			addTest(warning(""Class ""+theClass.getName()+"" has no public constructor TestCase(String name) or TestCase()""));
			return;
		}

		if (!Modifier.isPublic(theClass.getModifiers())) {
			addTest(warning(""Class ""+theClass.getName()+"" is not public""));
			return;
		}

		Class<?> superClass= theClass;
		List<String> names= new ArrayList<String>();
		while (Test.class.isAssignableFrom(superClass)) {
			for (Method each : superClass.getDeclaredMethods())
				addTestMethod(each, names, theClass);
			superClass= superClass.getSuperclass();
		}
		if (fTests.size() == 0)
			addTest(warning(""No tests found in ""+theClass.getName()));
	}
	",
