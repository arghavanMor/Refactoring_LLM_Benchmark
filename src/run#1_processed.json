{
    "L10937": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "\n\tpublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "AfterRefact": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tRuleFunction rf = getCurrentRuleFunction();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tdefineImplicitLabel(setAST, matchOp);\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\t\tmatchOp.labels.add(d);\n\t\t\t\trf.addContextDecl(setAST.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = createMatchSet(setAST, invert);\n    if (labelAST != null) {\n        handleLabelAST(labelAST, matchOp, setAST);\n    }\n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp;\n    if (invert) matchOp = new MatchNotSet(this, setAST);\n    else matchOp = new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        boolean isPlusAssign = labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN;\n        if (isPlusAssign) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) defineImplicitLabel(setAST, matchOp);\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp = invert ? new MatchNotSet(this, setAST) : new MatchSet(this, setAST);\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl decl = getTokenLabelDecl(label);\n        matchOp.labels.add(decl);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), decl);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl listDecl = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), listDecl);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n    MatchSet matchOp;\n    if (invert) {\n        matchOp = new MatchNotSet(this, setAST);\n    } else {\n        matchOp = new MatchSet(this, setAST);\n    }\n    \n    if (labelAST != null) {\n        String label = labelAST.getText();\n        Decl d = getTokenLabelDecl(label);\n        matchOp.labels.add(d);\n        getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            TokenListDecl l = getTokenListLabelDecl(label);\n            getCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n        }\n    }\n    \n    if (controller.needsImplicitLabel(setAST, matchOp)) {\n        defineImplicitLabel(setAST, matchOp);\n    }\n    \n    AddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n    return list(matchOp, listLabelOp);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5343": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public List<ParseTreeListener> getParseListeners() {\n        return _parseListeners;\n    }",
        "AfterRefact": "public List<ParseTreeListener> getParseListeners() {\n\t\tList<ParseTreeListener> listeners = _parseListeners;\n\t\tif (listeners == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn listeners;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprivate List<ParseTreeListener> parseListeners;\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    return new ArrayList<>(_parseListeners);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public List<ParseTreeListener> getParseListeners() {\n    List<ParseTreeListener> parseListeners = _parseListeners;\n    return parseListeners;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3671": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": " public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t@NotNull BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportAmbiguity d=\" + dfa.decision +\n\t\t\t\": ambigAlts=\" + ambigAlts + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }",
        "AfterRefact": "public void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\tDFA dfa,\n\t\t\t\t\t\t\t\tint startIndex,\n\t\t\t\t\t\t\t\tint stopIndex,\n\t\t\t\t\t\t\t\tboolean exact,\n\t\t\t\t\t\t\t\t@Nullable BitSet ambigAlts,\n\t\t\t\t\t\t\t\t@NotNull ATNConfigSet configs)\n\t{\n\t\tif (exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\n\t\tString format = \"reportAmbiguity d=%s: ambigAlts=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tBitSet conflictingAlts = getConflictingAlts(ambigAlts, configs);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, conflictingAlts, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String message = createReportMessage(recognizer, dfa, startIndex, stopIndex, ambigAlts);\n    recognizer.notifyErrorListeners(message);\n}",
                "private String createReportMessage(@NotNull Parser recognizer, DFA dfa, int startIndex, int stopIndex, @NotNull BitSet ambigAlts) {\n    return \"reportAmbiguity d=\" + dfa.decision +\n           \": ambigAlts=\" + ambigAlts + \", input=\\'\" +\n           recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                             DFA dfa, int startIndex, int stopIndex,\n                             @NotNull BitSet ambigAlts,\n                             @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = \"reportAmbiguity d=\" + dfa.decision +\n                     \": ambigAlts=\" + ambigAlts + \", input=\\'\" + inputText + \"\\'\";\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs)\n{\n    String decisionInfo = \"reportAmbiguity d=\" + dfa.decision +\n                          \": ambigAlts=\" + ambigAlts +\n                          \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(decisionInfo);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, \n                            int startIndex, \n                            int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String message = String.format(\"reportAmbiguity d=%d: ambigAlts=%s, input=\\'%s\\'\",\n                                    dfa.decision, ambigAlts, inputText);\n    recognizer.notifyErrorListeners(message);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportAmbiguity(@NotNull Parser recognizer,\n                            DFA dfa, int startIndex, int stopIndex,\n                            @NotNull BitSet ambigAlts,\n                            @NotNull ATNConfigSet configs) {\n    String errorMessage = \"reportAmbiguity d=\" + dfa.decision +\n        \": ambigAlts=\" + ambigAlts + \", input=\\'\" +\n        recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3692": {
        "RefactMethod": "EXTRACT VARIABLE",
        "BeforeRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n                                         int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n    {\n        recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n\t\t\tdfa.decision + \", input='\" +\n\t\t\trecognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"'\");\n    }\n}",
        "AfterRefact": "public void reportContextSensitivity(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs)\n\t{\n\t\tString format = \"reportContextSensitivity d=%s, input='%s'\";\n\t\tString decision = getDecisionDescription(recognizer, dfa);\n\t\tString text = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n\t\tString message = String.format(format, decision, text);\n\t\trecognizer.notifyErrorListeners(message);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String errorMessage = createErrorMessage(recognizer, dfa, startIndex, stopIndex);\n    recognizer.notifyErrorListeners(errorMessage);\n}",
                "private String createErrorMessage(@NotNull Parser recognizer, \n                                   @NotNull DFA dfa, \n                                   int startIndex, \n                                   int stopIndex) {\n    return \"reportContextSensitivity d=\" + dfa.decision + \n           \", input=\\'\" + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                     @NotNull DFA dfa,\n                                     int startIndex, int stopIndex,\n                                     @NotNull ATNConfigSet configs)\n{\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    recognizer.notifyErrorListeners(\"reportContextSensitivity d=\" +\n            dfa.decision + \", input=\\'\" + inputText + \"\\'\");\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) \n{\n    String decisionMessage = \"reportContextSensitivity d=\" + dfa.decision + \", input=\\'\"\n            + recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(decisionMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                     @NotNull DFA dfa,\n                                     int startIndex, \n                                     int stopIndex,\n                                     @NotNull ATNConfigSet configs) {\n    String inputText = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n    String errorMessage = String.format(\"reportContextSensitivity d=%d, input=\\'%s\\'\", dfa.decision, inputText);\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportContextSensitivity(@NotNull Parser recognizer,\n                                      @NotNull DFA dfa,\n                                      int startIndex, int stopIndex,\n                                      @NotNull ATNConfigSet configs) {\n    String errorMessage = \"reportContextSensitivity d=\" + dfa.decision + \", input=\\'\" +\n            recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex)) + \"\\'\";\n    recognizer.notifyErrorListeners(errorMessage);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L7413": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "AfterRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\n\t\t\tassert s.decision + 1 >= g.decisionLOOK.size();\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look = getLookahead(s);\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}",
                "private IntervalSet[] getLookahead(DecisionState s) {\n    if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n        return new IntervalSet[s.getNumberOfTransitions() + 1];\n    } else {\n        LL1Analyzer anal = new LL1Analyzer(g.atn);\n        IntervalSet[] look = anal.getDecisionLookahead(s);\n        g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        return look;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        assert s != null; // Ensure that the DecisionState is not null\n        IntervalSet[] look;\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n            assert look.length > 0; // Ensure that the look array has at least one element\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n            assert look != null; // Ensure that the look array is not null\n        }\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n\n        assert(s != null); // Assertion added to ensure DecisionState s is not null\n\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    \n    for (DecisionState state : g.atn.decisionToState) {\n        logDecisionInfo(state);\n        \n        IntervalSet[] lookahead;\n        if (state.nonGreedy) {\n            lookahead = new IntervalSet[state.getNumberOfTransitions() + 1];\n        } else {\n            lookahead = analyzeLookahead(state);\n        }\n        \n        updateDecisionLook(state, lookahead);\n    }\n}",
                "private void logDecisionInfo(DecisionState state) {\n    g.tool.log(\"LL1\", \"\\\nDECISION \" + state.decision + \" in rule \" + g.getRule(state.ruleIndex).name);\n}",
                "private IntervalSet[] analyzeLookahead(DecisionState state) {\n    LL1Analyzer analyzer = new LL1Analyzer(g.atn);\n    IntervalSet[] lookahead = analyzer.getDecisionLookahead(state);\n    g.tool.log(\"LL1\", \"look=\" + Arrays.toString(lookahead));\n    return lookahead;\n}",
                "private void updateDecisionLook(DecisionState state, IntervalSet[] lookahead) {\n    Utils.setSize(g.decisionLOOK, state.decision + 1);\n    g.decisionLOOK.set(state.decision, lookahead);\n    g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(lookahead));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions() + 1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\\nDECISION \" + s.decision + \" in rule \" + g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n\n        // Introduce an assertion to ensure expected conditions about the decision state\n        assert s != null : \"Decision state should not be null\";\n\n        if (s.nonGreedy) { // nongreedy decisions can\\'t be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions() + 1];\n        } else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n\n        Utils.setSize(g.decisionLOOK, s.decision + 1);\n        g.decisionLOOK.set(s.decision, look);\n\n        // Introduce an assertion to validate the lookahead compatibility\n        assert look != null : \"Lookahead should not be null\";\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L10037": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tIntervalSet enterLook = altLookSets[1];\n\t\tIntervalSet exitLook = altLookSets[2];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "AfterRefact": "public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n\t\tsuper(factory, starRoot, alts);\n\n\t\tStarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n\t\tloopBackStateNumber = star.loopBackState.stateNumber;\n\t\tthis.decision = star.decision;\n\t\tIntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n\t\tassert altLookSets.length == 2;\n\t\tIntervalSet enterLook = altLookSets[0];\n\t\tIntervalSet exitLook = altLookSets[1];\n\t\tloopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    \n    assert altLookSets.length > 2 : \"altLookSets should have at least 3 elements\";\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    assert star != null : \"StarLoopEntryState should not be null\";\n    \n    loopBackStateNumber = star.loopBackState.stateNumber;\n    assert loopBackStateNumber >= 0 : \"loopBackStateNumber should be non-negative\";\n    \n    this.decision = star.decision;\n    assert decision >= 0 : \"decision should be non-negative\";\n    \n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    assert altLookSets != null : \"altLookSets should not be null\";\n    \n    IntervalSet enterLook = altLookSets[1];\n    assert enterLook != null : \"enterLook should not be null\";\n    \n    IntervalSet exitLook = altLookSets[2];\n    assert exitLook != null : \"exitLook should not be null\";\n    \n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n\n    assert(enterLook != null);\n    assert(exitLook != null);\n\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState) starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    decision = star.decision;\n    \n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    loopExpr = addCodeForLoopLookaheadTempVar(altLookSets[1]);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {\n    super(factory, starRoot, alts);\n\n    StarLoopEntryState star = (StarLoopEntryState)starRoot.atnState;\n    loopBackStateNumber = star.loopBackState.stateNumber;\n    this.decision = star.decision;\n    IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);\n    IntervalSet enterLook = altLookSets[1];\n    IntervalSet exitLook = altLookSets[2];\n    loopExpr = addCodeForLoopLookaheadTempVar(enterLook);\n    \n    // Introducing assertion\n    assert loopBackStateNumber >= 0 : \"Loop back state number should be non-negative\";\n    assert decision >= 0 : \"Decision should be non-negative\";\n}\n```"
            ]
        }
    },
    "L1927": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(\"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(\"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tATNConfigSet closure = s.configs;\n\t\t\tDFAState target = null;\n\t\t\tif ( s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE ) {\n\t\t\t\ttarget = s.edges[t - MIN_DFA_EDGE];\n\t\t\t\tif (target == ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (debug && target != null) {\n\t\t\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (target == null) {\n\t\t\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t\t\t// if we don't find an existing DFA state\n\t\t\t\t// Fill reach starting from closure, following t transitions\n\t\t\t\tgetReachableConfigSet(input, closure, reach, t);\n\n\t\t\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t\t\t// we reached state associated with closure for sure, so\n\t\t\t\t\t// make sure it's defined. worst case, we define s0 from\n\t\t\t\t\t// start state configs.\n\t\t\t\t\t@NotNull\n\t\t\t\t\tDFAState from = s != null ? s : addDFAState(closure);\n\t\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t\t// cause a failover from DFA later.\n\t\t\t\t\taddDFAEdge(from, t, ERROR);\n\t\t\t\t\tbreak; // stop when we can't match any more char\n\t\t\t\t}\n\n\t\t\t\t// Add an edge from s to target DFA found/created for reach\n\t\t\t\ttarget = addDFAEdge(s, t, reach);\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}",
        "AfterRefact": "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n\t\t//System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"start state closure=%s\\n\", ds0.configs);\n\t\t}\n\n\t\tint t = input.LA(1);\n\t\t@NotNull\n\t\tDFAState s = ds0; // s is current/from DFA state\n\n\t\twhile ( true ) { // while more work\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.format(Locale.getDefault(), \"execATN loop starting closure: %s\\n\", s.configs);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tDFAState target = getExistingTargetState(s, t);\n\t\t\tif (target == null) {\n\t\t\t\ttarget = computeTargetState(input, s, t);\n\t\t\t}\n\n\t\t\tif (target == ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tcaptureSimState(prevAccept, input, target);\n\t\t\t\tif (t == IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tconsume(input);\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn failOrAccept(prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\t@Nullable\n\tprotected DFAState getExistingTargetState(@NotNull DFAState s, int t) {\n\t\tif (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tDFAState target = s.edges[t - MIN_DFA_EDGE];\n\t\tif (debug && target != null) {\n\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link #ERROR}.\n\t */\n\t@NotNull\n\tprotected DFAState computeTargetState(@NotNull CharStream input, @NotNull DFAState s, int t) {\n\t\tATNConfigSet reach = new OrderedATNConfigSet();\n\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tgetReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif ( reach.isEmpty() ) { // we got nowhere on t from s\n\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t// cause a failover from DFA later.\n\t\t\taddDFAEdge(s, t, ERROR);\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ERROR;\n\t\t}\n\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn addDFAEdge(s, t, reach);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = getTargetDFAState(s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull\n                DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetDFAState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        DFAState target = getTargetDFAState(s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, s.configs, reach, t);\n\n            if (reach.isEmpty()) { // we got nowhere on t from s\n                @NotNull DFAState from = s != null ? s : addDFAState(s.configs);\n                addDFAEdge(from, t, ERROR);\n                break; // stop when we can\\'t match any more char\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetDFAState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug && target != null) {\n                System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        DFAState target = getTargetState(input, t, s);\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, s.configs, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull DFAState from = s != null ? s : addDFAState(s.configs);\n                addDFAEdge(from, t, ERROR);\n                break; // stop when we can\\'t match any more char\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetState(@NotNull CharStream input, int t, @NotNull DFAState s) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull DFAState s = ds0;\n\n    while (true) {\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = getTargetState(s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) {\n                @NotNull DFAState from = (s != null) ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break;\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target;\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getTargetState(DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target != ERROR) {\n            if (debug) {\n                System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n            }\n            return target;\n        }\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected int execATN(@NotNull CharStream input, @NotNull DFAState ds0) {\n    //System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n    if (debug) {\n        System.out.format(\"start state closure=%s\\\n\", ds0.configs);\n    }\n\n    int t = input.LA(1);\n    @NotNull\n    DFAState s = ds0; // s is current/from DFA state\n\n    while (true) { // while more work\n        if (debug) {\n            System.out.format(\"execATN loop starting closure: %s\\\n\", s.configs);\n        }\n\n        ATNConfigSet closure = s.configs;\n        DFAState target = getDfaTarget(input, s, t);\n\n        if (target == null) {\n            ATNConfigSet reach = new OrderedATNConfigSet();\n            getReachableConfigSet(input, closure, reach, t);\n\n            if (reach.isEmpty()) { // we got nowhere on t from s\n                @NotNull\n                DFAState from = s != null ? s : addDFAState(closure);\n                addDFAEdge(from, t, ERROR);\n                break; // stop when we can\\'t match any more char\n            }\n\n            target = addDFAEdge(s, t, reach);\n        }\n\n        if (target.isAcceptState) {\n            captureSimState(prevAccept, input, target);\n            if (t == IntStream.EOF) {\n                break;\n            }\n        }\n\n        if (t != IntStream.EOF) {\n            consume(input);\n            t = input.LA(1);\n        }\n\n        s = target; // flip; current DFA target becomes new src/from state\n    }\n\n    return failOrAccept(prevAccept, input, s.configs, t);\n}",
                "private DFAState getDfaTarget(@NotNull CharStream input, DFAState s, int t) {\n    if (s.edges != null && t >= MIN_DFA_EDGE && t <= MAX_DFA_EDGE) {\n        DFAState target = s.edges[t - MIN_DFA_EDGE];\n        if (target == ERROR) {\n            return null;\n        }\n\n        if (debug && target != null) {\n            System.out.println(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L540": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t DFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t boolean exact,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, \n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts, \n                     @NotNull ATNConfigSet configs) {\n    // Method implementation goes here\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, DFA dfa, int startIndex, int stopIndex, @NotNull BitSet ambigAlts, @NotNull ATNConfigSet configs) {\n    // Method implementation goes here\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguityRecognition(@NotNull Parser recognizer,\n                                 DFA dfa, int startIndex, int stopIndex,\n                                 @NotNull BitSet ambigAlts,\n                                 @NotNull ATNConfigSet configs);\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer, \n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts, \n                     @NotNull ATNConfigSet configs) {\n    // Implementation goes here\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAmbiguity(@NotNull Parser recognizer,\n                     DFA dfa, \n                     int startIndex, \n                     int stopIndex, \n                     @NotNull BitSet ambigAlts) {\n    // Method implementation here\n}\n```"
            ]
        }
    },
    "L561": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex, int stopIndex,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "AfterRefact": "void reportAttemptingFullContext(@NotNull Parser recognizer,\n\t\t\t\t\t\t\t\t\t @NotNull DFA dfa,\n\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t @Nullable BitSet conflictingAlts,\n\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // method implementation\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex,\n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Method implementation here\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Method implementation here\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                  @NotNull DFA dfa,\n                                  int startIndex, \n                                  int stopIndex,\n                                  @NotNull ATNConfigSet configs) {\n    // Method implementation goes here\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nvoid reportAttemptingFullContext(@NotNull Parser recognizer,\n                                   @NotNull DFA dfa,\n                                   @NotNull ATNConfigSet configs);\n```"
            ]
        }
    },
    "L5431": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\t\tif (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n\t}",
        "AfterRefact": "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n\t\t_ctx.stop = _input.LT(-1);\n\t\tParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif ( _parseListeners != null ) {\n\t\t\twhile ( _ctx != _parentctx ) {\n\t\t\t\ttriggerExitRuleEvent();\n\t\t\t\t_ctx = (ParserRuleContext)_ctx.parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_ctx = _parentctx;\n\t\t}\n\n\t\t// hook into tree\n\t\tretctx.parent = _parentctx;\n\n\t\tif (_buildParseTrees && _parentctx != null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\t_parentctx.addChild(retctx);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    \n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) {\n        _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null || _ctx == _parentctx) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    \n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (shouldUnroll()) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}",
                "private boolean shouldUnroll() {\n    return _parseListeners != null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext parentCtx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext returnCtx = _ctx; // save current context\n\n    // Unroll context to match the state before recursive call\n    if (_parseListeners != null) {\n        while (_ctx != parentCtx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = parentCtx;\n    }\n\n    // Hook into the tree\n    returnCtx.parent = parentCtx;\n    if (_buildParseTrees) {\n        parentCtx.addChild(returnCtx); // add return context to invoking rule's tree\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void unrollRecursionContexts(ParserRuleContext _parentctx) {\n    _ctx.stop = _input.LT(-1);\n    ParserRuleContext retctx = _ctx; // save current ctx (return value)\n\n    // unroll so _ctx is as it was before call to recursive method\n    if (_parseListeners != null || _ctx == _parentctx) {\n        while (_ctx != _parentctx) {\n            triggerExitRuleEvent();\n            _ctx = (ParserRuleContext) _ctx.parent;\n        }\n    } else {\n        _ctx = _parentctx;\n    }\n    // hook into tree\n    retctx.parent = _parentctx;\n    if (_buildParseTrees) _parentctx.addChild(retctx); // add return ctx into invoking rule's tree\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3844": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "AfterRefact": " public void consume() {\n\t\tboolean skipEofCheck;\n\t\tif (p >= 0) {\n\t\t\tif (fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = p < tokens.size();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\n\t\tif (!skipEofCheck && LA(1) == EOF) {\n\t\t\tthrow new IllegalStateException(\"cannot consume EOF\");\n\t\t}\n\n\t\tif (sync(p + 1)) {\n\t\t\tp = adjustSeekIndex(p + 1);\n\t\t}\n    }",
        "ZeroShotCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p >= 0) ? (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size()) : false;\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = (p < 0) ? false :\n                           (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size());\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = p < 0 ? false : (fetchedEOF ? p < tokens.size() - 1 : p < tokens.size());\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck = shouldSkipEofCheck(p, fetchedEOF);\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}",
                "private boolean shouldSkipEofCheck(int index, boolean fetchedEOF) {\n    if (index < 0) {\n        return false; // not yet initialized\n    }\n    return fetchedEOF ? index < tokens.size() - 1 : index < tokens.size();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void consume() {\n    boolean skipEofCheck;\n    if (p >= 0) {\n        skipEofCheck = fetchedEOF ? (p < tokens.size() - 1) : (p < tokens.size());\n    } else {\n        skipEofCheck = false;\n    }\n\n    if (!skipEofCheck && LA(1) == EOF) {\n        throw new IllegalStateException(\"cannot consume EOF\");\n    }\n\n    if (sync(p + 1)) {\n        p = adjustSeekIndex(p + 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3168": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates.\n\t\t */\n\t\tif (skippedStopStates == null) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "AfterRefact": "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n\t\t\t\t\t\t\t\t\t\t   boolean fullCtx)\n\t{\n\t\tif ( debug ) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n\t\tif (mergeCache == null) {\n\t\t\tmergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n\t\t}\n\n\t\tATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n\n\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t * context). Once reached, these configurations are never updated by a\n\t\t * closure operation, so they are handled separately for the performance\n\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t *\n\t\t * For full-context reach operations, separate handling is required to\n\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t * chosen when multiple such configurations can match the input.\n\t\t */\n\t\tList<ATNConfig> skippedStopStates = null;\n\n\t\t// First figure out where we can reach on input t\n\t\tfor (ATNConfig c : closure) {\n\t\t\tif ( debug ) System.out.println(\"testing \"+getTokenName(t)+\" at \"+c.toString());\n\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tassert c.context.isEmpty();\n\t\t\t\tif (fullCtx || t == IntStream.EOF) {\n\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\tskippedStopStates = new ArrayList<ATNConfig>();\n\t\t\t\t\t}\n\n\t\t\t\t\tskippedStopStates.add(c);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint n = c.state.getNumberOfTransitions();\n\t\t\tfor (int ti=0; ti<n; ti++) {               // for each transition\n\t\t\t\tTransition trans = c.state.transition(ti);\n\t\t\t\tATNState target = getReachableTarget(trans, t);\n\t\t\t\tif ( target!=null ) {\n\t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now figure out where the reach operation can take us...\n\n\t\tATNConfigSet reach = null;\n\n\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t * trivially indicate a termination state for the overall\n\t\t * adaptivePredict operation.\n\t\t *\n\t\t * The conditions assume that intermediate\n\t\t * contains all configurations relevant to the reach set, but this\n\t\t * condition is not true when one or more configurations have been\n\t\t * withheld in skippedStopStates, or when the current symbol is EOF.\n\t\t */\n\t\tif (skippedStopStates == null && t != Token.EOF) {\n\t\t\tif ( intermediate.size()==1 ) {\n\t\t\t\t// Don't pursue the closure if there is just one state.\n\t\t\t\t// It can only have one alternative; just add to result\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t\telse if ( getUniqueAlt(intermediate)!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Also don't pursue the closure if there is unique alternative\n\t\t\t\t// among the configurations.\n\t\t\t\treach = intermediate;\n\t\t\t}\n\t\t}\n\n\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t * operation on the intermediate set to compute its initial value.\n\t\t */\n\t\tif (reach == null) {\n\t\t\treach = new ATNConfigSet(fullCtx);\n\t\t\tSet<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n\t\t\tboolean treatEofAsEpsilon = t == Token.EOF;\n\t\t\tfor (ATNConfig c : intermediate) {\n\t\t\t\tclosure(c, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\n\t\tif (t == IntStream.EOF) {\n\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t * only interested in configurations which reached the end of the\n\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t *\n\t\t\t * When reach==intermediate, no closure operation was performed. In\n\t\t\t * this case, removeAllConfigsNotInRuleStopState needs to check for\n\t\t\t * reachable rule stop states as well as configurations already in\n\t\t\t * a rule stop state.\n\t\t\t *\n\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t * because any configurations potentially added from that list are\n\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t * required.\n\t\t\t */\n\t\t\treach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n\t\t}\n\n\t\t/* If skippedStopStates is not null, then it contains at least one\n\t\t * configuration. For full-context reach operations, these\n\t\t * configurations reached the end of the start rule, in which case we\n\t\t * only add them back to reach if no configuration during the current\n\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t * chooses an alternative matching the longest overall sequence when\n\t\t * multiple alternatives are viable.\n\t\t */\n\t\tif (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\tassert !skippedStopStates.isEmpty();\n\t\t\tfor (ATNConfig c : skippedStopStates) {\n\t\t\t\treach.add(c, mergeCache);\n\t\t\t}\n\t\t}\n\n\t\tif ( reach.isEmpty() ) return null;\n\t\treturn reach;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n    \n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {               \n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null && (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER)) {\n        reach = intermediate;\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) {\n        System.out.println(\"in computeReachSet, starting closure: \" + closure);\n    }\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) {\n            System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n        }\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        for (int ti = 0; ti < c.state.getNumberOfTransitions(); ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = determineReach(intermediate, skippedStopStates, fullCtx);\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    return reach.isEmpty() ? null : reach;\n}",
                "private ATNConfigSet determineReach(ATNConfigSet intermediate, List<ATNConfig> skippedStopStates, boolean fullCtx) {\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n    if (debug) System.out.println(\"in computeReachSet, starting closure: \" + closure);\n\n    if (mergeCache == null) {\n        mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();\n    }\n\n    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);\n    List<ATNConfig> skippedStopStates = null;\n\n    for (ATNConfig c : closure) {\n        if (debug) System.out.println(\"testing \" + getTokenName(t) + \" at \" + c.toString());\n\n        if (c.state instanceof RuleStopState) {\n            assert c.context.isEmpty();\n            if (fullCtx || t == IntStream.EOF) {\n                if (skippedStopStates == null) {\n                    skippedStopStates = new ArrayList<ATNConfig>();\n                }\n                skippedStopStates.add(c);\n            }\n            continue;\n        }\n\n        int n = c.state.getNumberOfTransitions();\n        for (int ti = 0; ti < n; ti++) {\n            Transition trans = c.state.transition(ti);\n            ATNState target = getReachableTarget(trans, t);\n            if (target != null) {\n                intermediate.add(new ATNConfig(c, target), mergeCache);\n            }\n        }\n    }\n\n    ATNConfigSet reach = null;\n\n    if (skippedStopStates == null) {\n        if (intermediate.size() == 1 || getUniqueAlt(intermediate) != ATN.INVALID_ALT_NUMBER) {\n            reach = intermediate;\n        }\n    }\n\n    if (reach == null) {\n        reach = new ATNConfigSet(fullCtx);\n        Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();\n        for (ATNConfig c : intermediate) {\n            closure(c, reach, closureBusy, false, fullCtx);\n        }\n    }\n\n    if (t == IntStream.EOF) {\n        reach = removeAllConfigsNotInRuleStopState(reach, reach == intermediate);\n    }\n\n    if (skippedStopStates != null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n        assert !skippedStopStates.isEmpty();\n        for (ATNConfig c : skippedStopStates) {\n            reach.add(c, mergeCache);\n        }\n    }\n\n    if (reach.isEmpty()) return null;\n    return reach;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L10263": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String asString() {\n\t\tif ( start==null ) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile ( !work.isEmpty() ) {\n\t\t\ts = work.remove(0);\n\t\t\tif ( marked.contains(s) ) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n//\t\t\tSystem.out.println(\"visit \"+s+\"; edges=\"+n);\n\t\t\tmarked.add(s);\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif ( !(s instanceof RuleStopState) ) { // don't add follow states to work\n\t\t\t\t\tif ( t instanceof RuleTransition ) work.add(((RuleTransition)t).followState);\n\t\t\t\t\telse work.add( t.target );\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tif ( t instanceof EpsilonTransition ) {\n\t\t\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof RuleTransition ) {\n\t\t\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition)t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof ActionTransition ) {\n\t\t\t\t\tActionTransition a = (ActionTransition)t;\n\t\t\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof SetTransition ) {\n\t\t\t\t\tSetTransition st = (SetTransition)t;\n\t\t\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\t\t\tif ( g.isLexer() ) {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuf.append(\"-\").append(not?\"~\":\"\").append(st.label().toString(g.getTokenDisplayNames())).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( t instanceof AtomTransition ) {\n\t\t\t\t\tAtomTransition a = (AtomTransition)t;\n\t\t\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append('\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n\n    while (!work.isEmpty()) {\n        ATNState s = work.remove(0);\n        if (marked.contains(s)) continue;\n        marked.add(s);\n        processStateTransitions(s, buf, work);\n    }\n    return buf.toString();\n}",
                "private void processStateTransitions(ATNState s, StringBuilder buf, List<ATNState> work) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (!(s instanceof RuleStopState)) {\n            if (t instanceof RuleTransition) {\n                work.add(((RuleTransition) t).followState);\n            } else {\n                work.add(t.target);\n            }\n        }\n        appendTransitionDetails(buf, t, s);\n    }\n}",
                "private void appendTransitionDetails(StringBuilder buf, Transition t, ATNState s) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name)\n           .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        ActionTransition a = (ActionTransition) t;\n        buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        SetTransition st = (SetTransition) t;\n        boolean not = st instanceof NotSetTransition;\n        if (g.isLexer()) {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString())\n               .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        } else {\n            buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames()))\n               .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n        }\n    } else if (t instanceof AtomTransition) {\n        AtomTransition a = (AtomTransition) t;\n        String label = g.getTokenDisplayName(a.label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        int n = s.getNumberOfTransitions();\n        marked.add(s);\n        \n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n            buf.append(getStateString(s));\n\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof RuleTransition) {\n                buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof ActionTransition) {\n                ActionTransition a = (ActionTransition) t;\n                buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition) t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                } else {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                }\n            } else if (t instanceof AtomTransition) {\n                AtomTransition a = (AtomTransition) t;\n                String label = g.getTokenDisplayName(a.label);\n                buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else {\n                buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            }\n        }\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n    marked = new HashSet<ATNState>();\n\n    work = new ArrayList<ATNState>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n    ATNState s;\n\n    while (!work.isEmpty()) {\n        s = work.remove(0);\n        if (marked.contains(s)) continue;\n        marked.add(s);\n        int n = s.getNumberOfTransitions();\n        \n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            if (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n                if (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n                else work.add(t.target);\n            }\n\n            buf.append(getStateString(s));\n            if (t instanceof EpsilonTransition) {\n                buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof RuleTransition) {\n                buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof ActionTransition) {\n                ActionTransition a = (ActionTransition) t;\n                buf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else if (t instanceof SetTransition) {\n                SetTransition st = (SetTransition) t;\n                boolean not = st instanceof NotSetTransition;\n                if (g.isLexer()) {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                } else {\n                    buf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n                }\n            } else if (t instanceof AtomTransition) {\n                AtomTransition a = (AtomTransition) t;\n                String label = g.getTokenDisplayName(a.label);\n                buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            } else {\n                buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n            }\n        }\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String asString() {\n    if (start == null) return null;\n\n    marked = new HashSet<>();\n    work = new ArrayList<>();\n    work.add(start);\n\n    StringBuilder buf = new StringBuilder();\n\n    while (!work.isEmpty()) {\n        ATNState s = work.remove(0);\n        if (marked.contains(s)) continue;\n\n        marked.add(s);\n        int n = s.getNumberOfTransitions();\n\n        for (int i = 0; i < n; i++) {\n            Transition t = s.transition(i);\n            handleTransition(t, s, buf);\n            if (!(s instanceof RuleStopState)) {\n                work.add(t instanceof RuleTransition ? ((RuleTransition) t).followState : t.target);\n            }\n        }\n    }\n    return buf.toString();\n}",
                "private void handleTransition(Transition t, ATNState s, StringBuilder buf) {\n    buf.append(getStateString(s));\n    if (t instanceof EpsilonTransition) {\n        buf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof RuleTransition) {\n        buf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name)\n           .append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof ActionTransition) {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else if (t instanceof SetTransition) {\n        handleSetTransition((SetTransition) t, buf);\n    } else if (t instanceof AtomTransition) {\n        String label = g.getTokenDisplayName(((AtomTransition) t).label);\n        buf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    } else {\n        buf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n    }\n}",
                "private void handleSetTransition(SetTransition st, StringBuilder buf) {\n    boolean not = st instanceof NotSetTransition;\n    String label = g.isLexer() ? (not ? \"~\" : \"\") + st.toString() : \n                                  (not ? \"~\" : \"\") + st.label().toString(g.getTokenNames());\n    buf.append(\"-\").append(label).append(\"->\").append(getStateString(st.target)).append(\\'\\\n\\');\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String asString() {\n\t\tif (start == null) return null;\n\t\tmarked = new HashSet<ATNState>();\n\n\t\twork = new ArrayList<ATNState>();\n\t\twork.add(start);\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tATNState s;\n\n\t\twhile (!work.isEmpty()) {\n\t\t\ts = work.remove(0);\n\t\t\tif (marked.contains(s)) continue;\n\t\t\tint n = s.getNumberOfTransitions();\n\t\t\tmarked.add(s);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\tif (!(s instanceof RuleStopState)) { // don\\'t add follow states to work\n\t\t\t\t\tif (t instanceof RuleTransition) work.add(((RuleTransition) t).followState);\n\t\t\t\t\telse work.add(t.target);\n\t\t\t\t}\n\t\t\t\tbuf.append(getStateString(s));\n\t\t\t\tappendTransition(buf, t);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}",
                "private void appendTransition(StringBuilder buf, Transition t) {\n\t\tif (t instanceof EpsilonTransition) {\n\t\t\tbuf.append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t} else if (t instanceof RuleTransition) {\n\t\t\tbuf.append(\"-\").append(g.getRule(((RuleTransition) t).ruleIndex).name).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t} else if (t instanceof ActionTransition) {\n\t\t\tActionTransition a = (ActionTransition) t;\n\t\t\tbuf.append(\"-\").append(a.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t} else if (t instanceof SetTransition) {\n\t\t\tSetTransition st = (SetTransition) t;\n\t\t\tboolean not = st instanceof NotSetTransition;\n\t\t\tif (g.isLexer()) {\n\t\t\t\tbuf.append(\"-\").append(not ? \"~\" : \"\").append(st.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t\t} else {\n\t\t\t\tbuf.append(\"-\").append(not ? \"~\" : \"\").append(st.label().toString(g.getTokenNames())).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t\t}\n\t\t} else if (t instanceof AtomTransition) {\n\t\t\tAtomTransition a = (AtomTransition) t;\n\t\t\tString label = g.getTokenDisplayName(a.label);\n\t\t\tbuf.append(\"-\").append(label).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t} else {\n\t\t\tbuf.append(\"-\").append(t.toString()).append(\"->\").append(getStateString(t.target)).append(\\'\\\n\\');\n\t\t}\n\t}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n\t",
                "\n```"
            ]
        }
    },
    "L102630": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "AfterRefact": "String getStateString(ATNState s) {\n\t\tint n = s.stateNumber;\n\t\tString stateStr = \"s\"+n;\n\t\tif ( s instanceof StarBlockStartState ) stateStr = \"StarBlockStart_\"+n;\n\t\telse if ( s instanceof PlusBlockStartState ) stateStr = \"PlusBlockStart_\"+n;\n\t\telse if ( s instanceof BlockStartState) stateStr = \"BlockStart_\"+n;\n\t\telse if ( s instanceof BlockEndState ) stateStr = \"BlockEnd_\"+n;\n\t\telse if ( s instanceof RuleStartState) stateStr = \"RuleStart_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof RuleStopState ) stateStr = \"RuleStop_\"+g.getRule(s.ruleIndex).name+\"_\"+n;\n\t\telse if ( s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\"+n;\n\t\telse if ( s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\"+n;\n\t\treturn stateStr;\n\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr;\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    } else {\n        stateStr = \"s\" + n;\n    }\n\n    return stateStr;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr;\n    \n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    } else {\n        stateStr = \"s\" + n; // Default case\n    }\n    \n    return stateStr;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n    \n    if (s instanceof StarBlockStartState) {\n        stateStr = \"StarBlockStart_\" + n;\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = \"PlusBlockStart_\" + n;\n    } else if (s instanceof BlockStartState) {\n        stateStr = \"BlockStart_\" + n;\n    } else if (s instanceof BlockEndState) {\n        stateStr = \"BlockEnd_\" + n;\n    } else if (s instanceof RuleStartState) {\n        stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof RuleStopState) {\n        stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = \"PlusLoopBack_\" + n;\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = \"StarLoopBack_\" + n;\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = \"StarLoopEntry_\" + n;\n    }\n    \n    return stateStr;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    StringBuilder stateStr = new StringBuilder(\"s\" + n);\n\n    if (s instanceof StarBlockStartState) {\n        stateStr = new StringBuilder(\"StarBlockStart_\" + n);\n    } else if (s instanceof PlusBlockStartState) {\n        stateStr = new StringBuilder(\"PlusBlockStart_\" + n);\n    } else if (s instanceof BlockStartState) {\n        stateStr = new StringBuilder(\"BlockStart_\" + n);\n    } else if (s instanceof BlockEndState) {\n        stateStr = new StringBuilder(\"BlockEnd_\" + n);\n    } else if (s instanceof RuleStartState) {\n        stateStr = new StringBuilder(\"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n);\n    } else if (s instanceof RuleStopState) {\n        stateStr = new StringBuilder(\"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n);\n    } else if (s instanceof PlusLoopbackState) {\n        stateStr = new StringBuilder(\"PlusLoopBack_\" + n);\n    } else if (s instanceof StarLoopbackState) {\n        stateStr = new StringBuilder(\"StarLoopBack_\" + n);\n    } else if (s instanceof StarLoopEntryState) {\n        stateStr = new StringBuilder(\"StarLoopEntry_\" + n);\n    }\n\n    return stateStr.toString();\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\nString getStateString(ATNState s) {\n    int n = s.stateNumber;\n    String stateStr = \"s\" + n;\n\n    if (s instanceof BlockStartState || s instanceof BlockEndState || s instanceof RuleStartState || \n        s instanceof RuleStopState || s instanceof PlusLoopbackState || s instanceof StarLoopbackState || \n        s instanceof StarLoopEntryState || s instanceof StarBlockStartState || s instanceof PlusBlockStartState) {\n        \n        if (s instanceof StarBlockStartState) stateStr = \"StarBlockStart_\" + n;\n        else if (s instanceof PlusBlockStartState) stateStr = \"PlusBlockStart_\" + n;\n        else if (s instanceof BlockStartState) stateStr = \"BlockStart_\" + n;\n        else if (s instanceof BlockEndState) stateStr = \"BlockEnd_\" + n;\n        else if (s instanceof RuleStartState) stateStr = \"RuleStart_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n        else if (s instanceof RuleStopState) stateStr = \"RuleStop_\" + g.getRule(s.ruleIndex).name + \"_\" + n;\n        else if (s instanceof PlusLoopbackState) stateStr = \"PlusLoopBack_\" + n;\n        else if (s instanceof StarLoopbackState) stateStr = \"StarLoopBack_\" + n;\n        else if (s instanceof StarLoopEntryState) stateStr = \"StarLoopEntry_\" + n;\n    }\n\n    return stateStr;\n}\n```"
            ]
        }
    },
    "L15668": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addStopStates(dfa, dot);\n    addRegularStates(dfa, dot);\n    addEdges(dfa, isLexer, dot);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addStopStates(DFA dfa, ST dot) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addRegularStates(DFA dfa, ST dot) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState || d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n}",
                "private void addEdges(DFA dfa, boolean isLexer, ST dot) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // define stop states first; seems to be a bug in DOT where doublecircle\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState) continue;\n        ST st = stlib.getInstanceOf(\"stopstate\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) continue;\n        if (d.stateNumber == Integer.MAX_VALUE) continue;\n        ST st = stlib.getInstanceOf(\"state\");\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null) continue;\n                if (target.stateNumber == Integer.MAX_VALUE) continue;\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = String.valueOf(ttype);\n                if (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                else if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif (dfa.s0 == null) return null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\" + dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif (!d.isAcceptState) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\" + d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif (d.isAcceptState) continue;\n\t\t\tif (d.stateNumber == Integer.MAX_VALUE) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\" + d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif (d.edges != null) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif (target == null) continue;\n\t\t\t\t\tif (target.stateNumber == Integer.MAX_VALUE) continue;\n\t\t\t\t\tint ttype = i - 1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif (isLexer) label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n\t\t\t\t\telse if (grammar != null) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\" + d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\" + target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) {\n        return null;\n    }\n\n    ST dot = createDfaTemplate(dfa);\n    addAcceptStates(dot, dfa);\n    addRegularStates(dot, dfa);\n    addEdges(dot, dfa, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private ST createDfaTemplate(DFA dfa) {\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n    return dot;\n}",
                "private void addAcceptStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (!state.isAcceptState) {\n            continue;\n        }\n        ST stopState = stlib.getInstanceOf(\"stopstate\");\n        stopState.add(\"name\", \"s\" + state.stateNumber);\n        stopState.add(\"label\", getStateLabel(state));\n        dot.add(\"states\", stopState);\n    }\n}",
                "private void addRegularStates(ST dot, DFA dfa) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.isAcceptState || state.stateNumber == Integer.MAX_VALUE) {\n            continue;\n        }\n        ST regularState = stlib.getInstanceOf(\"state\");\n        regularState.add(\"name\", \"s\" + state.stateNumber);\n        regularState.add(\"label\", getStateLabel(state));\n        dot.add(\"states\", regularState);\n    }\n}",
                "private void addEdges(ST dot, DFA dfa, boolean isLexer) {\n    for (DFAState state : dfa.states.keySet()) {\n        if (state.edges != null) {\n            for (int i = 0; i < state.edges.length; i++) {\n                DFAState target = state.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) {\n                    continue;\n                }\n                String label = getEdgeLabelForState(i, isLexer);\n                ST edge = stlib.getInstanceOf(\"edge\");\n                edge.add(\"label\", label);\n                edge.add(\"src\", \"s\" + state.stateNumber);\n                edge.add(\"target\", \"s\" + target.stateNumber);\n                edge.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", edge);\n            }\n        }\n    }\n}",
                "private String getEdgeLabelForState(int index, boolean isLexer) {\n    int ttype = index - 1; // Shift for EOF as -1\n    if (isLexer) {\n        return \"\\'\" + getEdgeLabel(String.valueOf((char) index)) + \"\\'\";\n    } else if (grammar != null) {\n        return grammar.getTokenDisplayName(ttype);\n    }\n    return String.valueOf(ttype);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        ST st;\n        if (d.isAcceptState) {\n            st = stlib.getInstanceOf(\"stopstate\");\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            st = stlib.getInstanceOf(\"state\");\n        } else {\n            continue;\n        }\n        st.add(\"name\", \"s\" + d.stateNumber);\n        st.add(\"label\", getStateLabel(d));\n        dot.add(\"states\", st);\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target == null || target.stateNumber == Integer.MAX_VALUE) continue;\n\n                int ttype = i - 1; // we shift up for EOF as -1 for parser\n                String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" :\n                    (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n\n                ST st = stlib.getInstanceOf(\"edge\");\n                st.add(\"label\", label);\n                st.add(\"src\", \"s\" + d.stateNumber);\n                st.add(\"target\", \"s\" + target.stateNumber);\n                st.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", st);\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L156680": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "AfterRefact": "public String getDOT(DFA dfa, boolean isLexer) {\n\t\tif ( dfa.s0==null )\treturn null;\n\n\t\tST dot = stlib.getInstanceOf(\"dfa\");\n\t\tdot.add(\"name\", \"DFA\"+dfa.decision);\n\t\tdot.add(\"startState\", dfa.s0.stateNumber);\n//\t\tdot.add(\"useBox\", Tool.internalOption_ShowATNConfigsInDFA);\n\t\tdot.add(\"rankdir\", rankdir);\n\n\t\t// define stop states first; seems to be a bug in DOT where doublecircle\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( !d.isAcceptState ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"stopstate\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.isAcceptState ) continue;\n\t\t\tif ( d.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\tST st = stlib.getInstanceOf(\"state\");\n\t\t\tst.add(\"name\", \"s\"+d.stateNumber);\n\t\t\tst.add(\"label\", getStateLabel(d));\n\t\t\tdot.add(\"states\", st);\n\t\t}\n\n\t\tfor (DFAState d : dfa.states.keySet()) {\n\t\t\tif ( d.edges!=null ) {\n\t\t\t\tfor (int i = 0; i < d.edges.length; i++) {\n\t\t\t\t\tDFAState target = d.edges[i];\n\t\t\t\t\tif ( target==null) continue;\n\t\t\t\t\tif ( target.stateNumber == Integer.MAX_VALUE ) continue;\n\t\t\t\t\tint ttype = i-1; // we shift up for EOF as -1 for parser\n\t\t\t\t\tString label = String.valueOf(ttype);\n\t\t\t\t\tif ( isLexer ) label = \"'\"+getEdgeLabel(String.valueOf((char) i))+\"'\";\n\t\t\t\t\telse if ( grammar!=null ) label = grammar.getTokenDisplayName(ttype);\n\t\t\t\t\tST st = stlib.getInstanceOf(\"edge\");\n\t\t\t\t\tst.add(\"label\", label);\n\t\t\t\t\tst.add(\"src\", \"s\"+d.stateNumber);\n\t\t\t\t\tst.add(\"target\", \"s\"+target.stateNumber);\n\t\t\t\t\tst.add(\"arrowhead\", arrowhead);\n\t\t\t\t\tdot.add(\"edges\", st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString output = dot.render();\n\t\treturn Utils.sortLinesInString(output);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; \n                    String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    return Utils.sortLinesInString(dot.render());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = isLexer ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" : (grammar != null ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype));\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    // define stop states first; seems to be a bug in DOT where doublecircle\n    for (DFAState d : dfa.states.keySet()) {\n        if (isStopState(d)) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (!isStopState(d) && d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (isValidTarget(target, i)) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = (isLexer) ? \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\" :\n                                               (grammar != null) ? grammar.getTokenDisplayName(ttype) : String.valueOf(ttype);\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private boolean isStopState(DFAState d) {\n    return d.isAcceptState;\n}",
                "private boolean isValidTarget(DFAState target, int i) {\n    return target != null && target.stateNumber != Integer.MAX_VALUE;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    addStopStates(dfa, dot);\n    addRegularStates(dfa, dot);\n    addEdges(dfa, dot, isLexer);\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}",
                "private void addStopStates(DFA dfa, ST dot) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n}",
                "private void addRegularStates(DFA dfa, ST dot) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (!d.isAcceptState && d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n    }\n}",
                "private void addEdges(DFA dfa, ST dot, boolean isLexer) {\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    String label = getEdgeLabel(i, isLexer);\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n}",
                "private String getEdgeLabel(int index, boolean isLexer) {\n    if (isLexer) {\n        return \"\\'\" + getEdgeLabel(String.valueOf((char) index)) + \"\\'\";\n    } else if (grammar != null) {\n        return grammar.getTokenDisplayName(index - 1);\n    } else {\n        return String.valueOf(index - 1);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String getDOT(DFA dfa, boolean isLexer) {\n    if (dfa.s0 == null) return null;\n\n    ST dot = stlib.getInstanceOf(\"dfa\");\n    dot.add(\"name\", \"DFA\" + dfa.decision);\n    dot.add(\"startState\", dfa.s0.stateNumber);\n    dot.add(\"rankdir\", rankdir);\n\n    for (DFAState d : dfa.states.keySet()) {\n        if (d.isAcceptState) {\n            ST st = stlib.getInstanceOf(\"stopstate\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        } else if (d.stateNumber != Integer.MAX_VALUE) {\n            ST st = stlib.getInstanceOf(\"state\");\n            st.add(\"name\", \"s\" + d.stateNumber);\n            st.add(\"label\", getStateLabel(d));\n            dot.add(\"states\", st);\n        }\n        \n        if (d.edges != null) {\n            for (int i = 0; i < d.edges.length; i++) {\n                DFAState target = d.edges[i];\n                if (target != null && target.stateNumber != Integer.MAX_VALUE) {\n                    int ttype = i - 1; // we shift up for EOF as -1 for parser\n                    String label = String.valueOf(ttype);\n                    if (isLexer) {\n                        label = \"\\'\" + getEdgeLabel(String.valueOf((char) i)) + \"\\'\";\n                    } else if (grammar != null) {\n                        label = grammar.getTokenDisplayName(ttype);\n                    }\n                    ST st = stlib.getInstanceOf(\"edge\");\n                    st.add(\"label\", label);\n                    st.add(\"src\", \"s\" + d.stateNumber);\n                    st.add(\"target\", \"s\" + target.stateNumber);\n                    st.add(\"arrowhead\", arrowhead);\n                    dot.add(\"edges\", st);\n                }\n            }\n        }\n    }\n\n    String output = dot.render();\n    return Utils.sortLinesInString(output);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L3347": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(ATNConfig config,\n\t\t\t\t\t\t\tATNConfigSet configs,\n\t\t\t\t\t\t\tSet<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth,\n\t\t\t\t\t\t\tboolean treatEofAsEpsilon)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\t\tif ( c!=null ) {\n\t\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_dfa != null && _dfa.isPrecedenceDfa()) {\n\t\t\t\t\t\tint outermostPrecedenceReturn = ((EpsilonTransition)t).outermostPrecedenceReturn();\n\t\t\t\t\t\tif (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {\n\t\t\t\t\t\t\tc.setPrecedenceFilterSuppressed(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true; \n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\tint depth,\n\t\t\t\t\t\tboolean treatEofAsEpsilon)\n{\n\tATNState p = config.state;\n\tint newDepth = depth;\n\t\n\t// optimization\n\tif (!p.onlyHasEpsilonTransitions()) {\n\t\tconfigs.add(config, mergeCache);\n\t\t// make sure to not return here, because EOF transitions can act as\n\t\t// both epsilon transitions and non-epsilon transitions.\n\t\t// if ( debug ) System.out.println(\"added config \"+configs);\n\t}\n\n\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\tTransition t = p.transition(i);\n\t\tboolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx, treatEofAsEpsilon);\n\t\tif (c != null) {\n\t\t\tif (!t.isEpsilon() && !closureBusy.add(c)) {\n\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (config.state instanceof RuleStopState) {\n\t\t\t\tassert !fullCtx;\n\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t// We can\\'t get here if incoming config was rule stop and we had context\n\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t// preds if this is > 0.\n\n\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\tnewDepth--;\n\t\t\t\tif (debug) System.out.println(\"dips into outer ctx: \" + c);\n\t\t\t} else if (t instanceof RuleTransition) {\n\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can\\'t return\n\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\tnewDepth++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t fullCtx, newDepth, treatEofAsEpsilon);\n\t\t}\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState state = config.state;\n\n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean shouldCollectPredicates = !(transition instanceof ActionTransition) && collectPredicates;\n\n        ATNConfig newConfig = getEpsilonTarget(config, transition, shouldCollectPredicates,\n                                               depth == 0, fullCtx, treatEofAsEpsilon);\n        if (newConfig != null) {\n            if (!transition.isEpsilon() && !closureBusy.add(newConfig)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n\n                if (!closureBusy.add(newConfig)) {\n                    continue;\n                }\n\n                newConfig.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true; \n                newDepth = Math.max(newDepth - 1, Integer.MIN_VALUE);\n\n                if (debug) {\n                    System.out.println(\"dips into outer ctx: \" + newConfig);\n                }\n            } else if (transition instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(newConfig, configs, closureBusy, \n                                     shouldCollectPredicates, fullCtx, newDepth, \n                                     treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth,\n                        boolean treatEofAsEpsilon) {\n    ATNState p = config.state;\n    configs.add(config, mergeCache);\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx, treatEofAsEpsilon);\n        if (c != null) {\n            if (!t.isEpsilon() && !closureBusy.add(c)) {\n                continue;\n            }\n\n            int newDepth = depth;\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                if (!closureBusy.add(c)) {\n                    continue;\n                }\n\n                c.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert newDepth > Integer.MIN_VALUE;\n                newDepth--;\n                if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            } else if (t instanceof RuleTransition) {\n                if (newDepth >= 0) {\n                    newDepth++;\n                }\n            }\n\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2755": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": " protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof AbstractPredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        handleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, stopState, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        return;\n    }\n\n    processTransitions(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n}",
                "private void handleStopState(@Nullable PredictionContext ctx, @NotNull IntervalSet look, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n}",
                "private void handleRuleStopState(@Nullable PredictionContext ctx, @Nullable ATNState stopState,\n                                  @NotNull IntervalSet look, @NotNull Set<ATNConfig> lookBusy,\n                                  @NotNull BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    }\n\n    if (ctx != PredictionContext.EMPTY) {\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}",
                "private void processTransitions(ATNState s, @Nullable ATNState stopState, \n                                @Nullable PredictionContext ctx, @NotNull IntervalSet look, \n                                @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack, \n                                boolean seeThruPreds, boolean addEOF) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            processRuleTransition((RuleTransition) t, stopState, ctx, look, lookBusy, calledRuleStack, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            processPredicateTransition(t, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            processOtherTransitions(t, look);\n        }\n    }\n}",
                "private void processRuleTransition(RuleTransition t, @Nullable ATNState stopState, @Nullable PredictionContext ctx,\n                                    @NotNull IntervalSet look, @NotNull Set<ATNConfig> lookBusy,\n                                    @NotNull BitSet calledRuleStack, boolean addEOF) {\n    if (calledRuleStack.get(t.target.ruleIndex)) {\n        return;\n    }\n\n    PredictionContext newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n    try {\n        calledRuleStack.set(t.target.ruleIndex);\n        _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, addEOF);\n    } finally {\n        calledRuleStack.clear(t.target.ruleIndex);\n    }\n}",
                "private void processPredicateTransition(Transition t, @Nullable ATNState stopState, @Nullable PredictionContext ctx,\n                                        @NotNull IntervalSet look, @NotNull Set<ATNConfig> lookBusy,\n                                        @NotNull BitSet calledRuleStack, boolean seeThruPreds, boolean addEOF) {\n    if (seeThruPreds) {\n        _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } else {\n        look.add(HIT_PRED);\n    }\n}",
                "private void processOtherTransitions(Transition t, @NotNull IntervalSet look) {\n    IntervalSet set = t.label();\n    if (set != null) {\n        if (t instanceof NotSetTransition) {\n            set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        look.addAll(set);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n    }\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (int i = 0; i < ctx.size(); i++) {\n                ATNState returnState = atn.states.get(ctx.getReturnState(i));\n                boolean removed = calledRuleStack.get(returnState.ruleIndex);\n                try {\n                    calledRuleStack.clear(returnState.ruleIndex);\n                    _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    if (removed) {\n                        calledRuleStack.set(returnState.ruleIndex);\n                    }\n                }\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void lookAhead(@NotNull ATNState state,\n                         @Nullable ATNState stopState,\n                         @Nullable PredictionContext context,\n                         @NotNull IntervalSet lookahead,\n                         @NotNull Set<ATNConfig> lookBusy,\n                         @NotNull BitSet calledRuleStack,\n                         boolean seeThroughPredicates, boolean addEOF) {\n    ATNConfig config = new ATNConfig(state, 0, context);\n    if (!lookBusy.add(config)) return;\n\n    if (state == stopState) {\n        handleStopState(context, lookahead, addEOF);\n        return;\n    }\n\n    if (state instanceof RuleStopState) {\n        handleRuleStopState(context, lookahead, stopState, calledRuleStack, addEOF);\n        return;\n    }\n\n    processTransitions(state, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates);\n}",
                "private void handleStopState(@Nullable PredictionContext context, @NotNull IntervalSet lookahead, boolean addEOF) {\n    if (context == null) {\n        lookahead.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookahead.add(Token.EOF);\n    }\n}",
                "private void handleRuleStopState(@Nullable PredictionContext context, @NotNull IntervalSet lookahead,\n                                  @Nullable ATNState stopState, @NotNull BitSet calledRuleStack,\n                                  boolean addEOF) {\n    if (context == null) {\n        lookahead.add(Token.EPSILON);\n    } else if (context.isEmpty() && addEOF) {\n        lookahead.add(Token.EOF);\n    } else if (context != PredictionContext.EMPTY) {\n        for (int i = 0; i < context.size(); i++) {\n            ATNState returnState = atn.states.get(context.getReturnState(i));\n            boolean wasRemoved = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                lookAhead(returnState, stopState, context.getParent(i), lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n            } finally {\n                if (wasRemoved) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n    }\n}",
                "private void processTransitions(@NotNull ATNState state, @Nullable ATNState stopState,\n                                @Nullable PredictionContext context, @NotNull IntervalSet lookahead,\n                                @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                boolean seeThroughPredicates) {\n    int transitionCount = state.getNumberOfTransitions();\n    for (int i = 0; i < transitionCount; i++) {\n        Transition transition = state.transition(i);\n        if (transition instanceof RuleTransition) {\n            handleRuleTransition((RuleTransition) transition, stopState, context, lookahead, lookBusy, calledRuleStack);\n        } else if (transition instanceof PredicateTransition) {\n            handlePredicateTransition(transition, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates);\n        } else if (transition.isEpsilon()) {\n            lookAhead(transition.target, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n        } else if (transition instanceof WildcardTransition) {\n            lookahead.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            handleOtherTransitions(transition, lookahead);\n        }\n    }\n}",
                "private void handleRuleTransition(RuleTransition transition, @Nullable ATNState stopState,\n                                   @Nullable PredictionContext context, @NotNull IntervalSet lookahead,\n                                   @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack) {\n    if (calledRuleStack.get(transition.target.ruleIndex)) return;\n\n    PredictionContext newContext = SingletonPredictionContext.create(context, transition.followState.stateNumber);\n    try {\n        calledRuleStack.set(transition.target.ruleIndex);\n        lookAhead(transition.target, stopState, newContext, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } finally {\n        calledRuleStack.clear(transition.target.ruleIndex);\n    }\n}",
                "private void handlePredicateTransition(@NotNull Transition transition, @Nullable ATNState stopState,\n                                       @Nullable PredictionContext context, @NotNull IntervalSet lookahead,\n                                       @NotNull Set<ATNConfig> lookBusy, @NotNull BitSet calledRuleStack,\n                                       boolean seeThroughPredicates) {\n    if (seeThroughPredicates) {\n        lookAhead(transition.target, stopState, context, lookahead, lookBusy, calledRuleStack, seeThroughPredicates, addEOF);\n    } else {\n        lookahead.add(HIT_PRED);\n    }\n}",
                "private void handleOtherTransitions(@NotNull Transition transition, @NotNull IntervalSet lookahead) {\n    IntervalSet labels = transition.label();\n    if (labels != null) {\n        if (transition instanceof NotSetTransition) {\n            labels = labels.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        }\n        lookahead.addAll(labels);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s,\n                     @Nullable ATNState stopState,\n                     @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     @NotNull BitSet calledRuleStack,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s == stopState || (s instanceof RuleStopState && (ctx == null || (ctx.isEmpty() && addEOF)))) {\n        look.add(ctx == null ? Token.EPSILON : Token.EOF);\n        return;\n    }\n\n    if (s instanceof RuleStopState && ctx != PredictionContext.EMPTY) {\n        // run thru all possible stack tops in ctx\n        for (int i = 0; i < ctx.size(); i++) {\n            ATNState returnState = atn.states.get(ctx.getReturnState(i));\n            boolean removed = calledRuleStack.get(returnState.ruleIndex);\n            try {\n                calledRuleStack.clear(returnState.ruleIndex);\n                _LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                if (removed) {\n                    calledRuleStack.set(returnState.ruleIndex);\n                }\n            }\n        }\n        return;\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            if (calledRuleStack.get(((RuleTransition) t).target.ruleIndex)) {\n                continue;\n            }\n\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            try {\n                calledRuleStack.set(((RuleTransition) t).target.ruleIndex);\n                _LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } finally {\n                calledRuleStack.clear(((RuleTransition) t).target.ruleIndex);\n            }\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L13228": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tFileReader fr = new FileReader(fullFile);\n\t\t\tBufferedReader br = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  ioe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\treturn tokens;\n\t}",
        "AfterRefact": "public Map<String,Integer> load() {\n\t\tMap<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n\t\tint maxTokenType = -1;\n\t\tFile fullFile = getImportedVocabFile();\n\t\tFileReader fr = null;\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tPattern tokenDefPattern = Pattern.compile(\"([^\\n]+?)[ \\\\t]*?=[ \\\\t]*?([0-9]+)\");\n\t\t\tfr = new FileReader(fullFile);\n\t\t\tbr = new BufferedReader(fr);\n\t\t\tString tokenDef = br.readLine();\n\t\t\tint lineNum = 1;\n\t\t\twhile ( tokenDef!=null ) {\n\t\t\t\tMatcher matcher = tokenDefPattern.matcher(tokenDef);\n\t\t\t\tif ( matcher.find() ) {\n\t\t\t\t\tString tokenID = matcher.group(1);\n\t\t\t\t\tString tokenTypeS = matcher.group(2);\n\t\t\t\t\tint tokenType;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttokenType = Integer.valueOf(tokenTypeS);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NumberFormatException nfe) {\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token type: \"+tokenTypeS,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t\ttokenType = Token.INVALID_TOKEN_TYPE;\n\t\t\t\t\t}\n\t\t\t\t\ttool.log(\"grammar\", \"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\t\ttokens.put(tokenID, tokenType);\n\t\t\t\t\tmaxTokenType = Math.max(maxTokenType,tokenType);\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( tokenDef.length()>0 ) { // ignore blank lines\n\t\t\t\t\t\ttool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t  vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t\t\t  \" bad token def: \"+tokenDef,\n\t\t\t\t\t\t\t\t\t\t\t  lineNum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttokenDef = br.readLine();\n\t\t\t}\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\ttool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t  e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ( br!=null ) br.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\ttool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t\t\t  fullFile,\n\t\t\t\t\t\t\t\t\t  ioe);\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private void processTokenDefinition(String tokenDef, Map<String, Integer> tokens, Pattern tokenDefPattern, int lineNum) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (tokenDef.length() > 0) {\n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR, vocabName + CodeGenerator.VOCAB_FILE_EXTENSION, \" bad token def: \" + tokenDef, lineNum);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    \n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        String tokenDef;\n        int lineNum = 1;\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        \n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokenDef, tokens, tokenDefPattern, lineNum++);\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    \n    return tokens;\n}\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<String, Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n        int lineNum = 1;\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                int tokenType = Integer.valueOf(matcher.group(2));\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) { // ignore blank lines\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \" + tokenDef,\n                                          lineNum);\n                }\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    return tokens;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n    File fullFile = getImportedVocabFile();\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    int lineNum = 1;\n\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n\n        while (tokenDef != null) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if (matcher.find()) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else {\n                if (tokenDef.length() > 0) { // ignore blank lines\n                    tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                          vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                          \" bad token def: \" + tokenDef,\n                                          lineNum);\n                }\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE,\n                              fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE,\n                              fullFile,\n                              e);\n    }\n    \n    return tokens;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void processTokenDefinition(Map<String, Integer> tokens, String tokenDef, Pattern tokenDefPattern, int lineNum) {\n    Matcher matcher = tokenDefPattern.matcher(tokenDef);\n    if (matcher.find()) {\n        String tokenID = matcher.group(1);\n        int tokenType = Integer.parseInt(matcher.group(2));\n        tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n        tokens.put(tokenID, tokenType);\n    } else if (!tokenDef.isEmpty()) { // Ignore blank lines\n        tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                \" bad token def: \" + tokenDef,\n                lineNum);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Map<String, Integer> load() {\n    Map<String, Integer> tokens = new LinkedHashMap<>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n\n    try (BufferedReader br = new BufferedReader(new FileReader(fullFile))) {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        String tokenDef;\n        int lineNum = 1;\n\n        while ((tokenDef = br.readLine()) != null) {\n            processTokenDefinition(tokens, tokenDef, tokenDefPattern, lineNum);\n            lineNum++;\n        }\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    \n    return tokens;\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Map<String,Integer> load() {\n    Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();\n    int maxTokenType = -1;\n    File fullFile = getImportedVocabFile();\n    try {\n        Pattern tokenDefPattern = Pattern.compile(\"([^\\\n]+?)[ \\\\\\\t]*?=[ \\\\\\\t]*?([0-9]+)\");\n        FileReader fr = new FileReader(fullFile);\n        BufferedReader br = new BufferedReader(fr);\n        String tokenDef = br.readLine();\n        int lineNum = 1;\n        while ( tokenDef != null ) {\n            Matcher matcher = tokenDefPattern.matcher(tokenDef);\n            if ( matcher.find() ) {\n                String tokenID = matcher.group(1);\n                String tokenTypeS = matcher.group(2);\n                int tokenType = Integer.valueOf(tokenTypeS);\n                tool.log(\"grammar\", \"import \" + tokenID + \"=\" + tokenType);\n                tokens.put(tokenID, tokenType);\n                maxTokenType = Math.max(maxTokenType, tokenType);\n                lineNum++;\n            } else if ( tokenDef.length() > 0 ) { // ignore blank lines\n                tool.errMgr.toolError(ErrorType.TOKENS_FILE_SYNTAX_ERROR,\n                                      vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,\n                                      \" bad token def: \" + tokenDef,\n                                      lineNum);\n            }\n            tokenDef = br.readLine();\n        }\n        br.close();\n    } catch (FileNotFoundException fnfe) {\n        tool.errMgr.toolError(ErrorType.CANNOT_FIND_TOKENS_FILE, fullFile);\n    } catch (IOException ioe) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, ioe);\n    } catch (Exception e) {\n        tool.errMgr.toolError(ErrorType.ERROR_READING_TOKENS_FILE, fullFile, e);\n    }\n    return tokens;\n}\n```"
            ]
        }
    },
    "L8024": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i - 1).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\");\n\t\t\tfor (int j=1; j<=nintervals; j++) {\n\t\t\t\tif ( j>1 ) buf.append(\", \");\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=1; i<=ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i-1).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "AfterRefact": "public String decode(char[] data) {\n\t\tdata = data.clone();\n\t\t// don't adjust the first value since that's the version number\n\t\tfor (int i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (char)(data[i] - 2);\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint p = 0;\n\t\tint version = ATNSimulator.toInt(data[p++]);\n\t\tif (version != ATNSimulator.SERIALIZED_VERSION) {\n\t\t\tString reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tUUID uuid = ATNSimulator.toUUID(data, p);\n\t\tp += 8;\n\t\tif (!uuid.equals(ATNSimulator.SERIALIZED_UUID)) {\n\t\t\tString reason = String.format(Locale.getDefault(), \"Could not deserialize ATN with UUID %s (expected %s).\", uuid, ATNSimulator.SERIALIZED_UUID);\n\t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n\t\t}\n\n\t\tint grammarType = ATNSimulator.toInt(data[p++]);\n\t\tint maxType = ATNSimulator.toInt(data[p++]);\n\t\tbuf.append(\"max type \").append(maxType).append(\"\\n\");\n\t\tint nstates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nstates; i++) {\n\t\t\tint stype = ATNSimulator.toInt(data[p++]);\n            if ( stype==ATNState.INVALID_TYPE ) continue; // ignore bad type of states\n\t\t\tint ruleIndex = ATNSimulator.toInt(data[p++]);\n\t\t\tif (ruleIndex == Character.MAX_VALUE) {\n\t\t\t\truleIndex = -1;\n\t\t\t}\n\n\t\t\tString arg = \"\";\n\t\t\tif ( stype == ATNState.LOOP_END ) {\n\t\t\t\tint loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+loopBackStateNumber;\n\t\t\t}\n\t\t\telse if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {\n\t\t\t\tint endStateNumber = ATNSimulator.toInt(data[p++]);\n\t\t\t\targ = \" \"+endStateNumber;\n\t\t\t}\n\t\t\tbuf.append(i).append(\":\")\n\t\t\t\t.append(ATNState.serializationNames.get(stype)).append(\" \")\n\t\t\t\t.append(ruleIndex).append(arg).append(\"\\n\");\n\t\t}\n\t\tint numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i = 0; i < numNonGreedyStates; i++) {\n\t\t\tint stateNumber = ATNSimulator.toInt(data[p++]);\n\t\t}\n\t\tint nrules = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nrules; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n            if ( g.isLexer() ) {\n                int arg1 = ATNSimulator.toInt(data[p++]);\n                int arg2 = ATNSimulator.toInt(data[p++]);\n\t\t\t\tif (arg2 == Character.MAX_VALUE) {\n\t\t\t\t\targ2 = -1;\n\t\t\t\t}\n                buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append('\\n');\n            }\n            else {\n                buf.append(\"rule \").append(i).append(\":\").append(s).append('\\n');\n            }\n\t\t}\n\t\tint nmodes = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nmodes; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(\"mode \").append(i).append(\":\").append(s).append('\\n');\n\t\t}\n\t\tint nsets = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nsets; i++) {\n\t\t\tint nintervals = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\");\n\t\t\tboolean containsEof = data[p++] != 0;\n\t\t\tif (containsEof) {\n\t\t\t\tbuf.append(getTokenName(Token.EOF));\n\t\t\t}\n\n\t\t\tfor (int j=0; j<nintervals; j++) {\n\t\t\t\tif ( containsEof || j>0 ) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t}\n\n\t\t\t\tbuf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n\t\t\t\tp += 2;\n\t\t\t}\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\tint nedges = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<nedges; i++) {\n\t\t\tint src = ATNSimulator.toInt(data[p]);\n\t\t\tint trg = ATNSimulator.toInt(data[p + 1]);\n\t\t\tint ttype = ATNSimulator.toInt(data[p + 2]);\n\t\t\tint arg1 = ATNSimulator.toInt(data[p + 3]);\n\t\t\tint arg2 = ATNSimulator.toInt(data[p + 4]);\n\t\t\tint arg3 = ATNSimulator.toInt(data[p + 5]);\n\t\t\tbuf.append(src).append(\"->\").append(trg)\n\t\t\t\t.append(\" \").append(Transition.serializationNames.get(ttype))\n\t\t\t\t.append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n\t\t\t\t.append(\"\\n\");\n\t\t\tp += 6;\n\t\t}\n\t\tint ndecisions = ATNSimulator.toInt(data[p++]);\n\t\tfor (int i=0; i<ndecisions; i++) {\n\t\t\tint s = ATNSimulator.toInt(data[p++]);\n\t\t\tbuf.append(i).append(\":\").append(s).append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = decodeVersion(data, p);\n    p += 2; // Skip version bytes\n    validateVersion(version);\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    \n    int nstates = ATNSimulator.toInt(data[p++]);\n    decodeStates(data, p, nstates, buf);\n    p += nstates * 2; // Skip states bytes\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    p += numNonGreedyStates; // Skip non-greedy state bytes\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    decodeRules(data, p, nrules, buf);\n    p += nrules * 3; // Skip rule bytes\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    decodeModes(data, p, nmodes, buf);\n    p += nmodes; // Skip mode bytes\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    decodeSets(data, p, nsets, buf);\n    p += nsets; // Skip set bytes\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    decodeEdges(data, p, nedges, buf);\n    p += nedges * 6; // Skip edge bytes\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    decodeDecisions(data, p, ndecisions, buf);\n    \n    return buf.toString();\n}",
                "private void validateVersion(int version) {\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n}",
                "private void decodeStates(char[] data, int p, int nstates, StringBuilder buf) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n}",
                "private void decodeRules(char[] data, int p, int nrules, StringBuilder buf) {\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n}",
                "private void decodeModes(char[] data, int p, int nmodes, StringBuilder buf) {\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n}",
                "private void decodeSets(char[] data, int p, int nsets, StringBuilder buf) {\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n}",
                "private void decodeEdges(char[] data, int p, int nedges, StringBuilder buf) {\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n}",
                "private void decodeDecisions(char[] data, int p, int ndecisions, StringBuilder buf) {\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    // don\\'t adjust the first value since that\\'s the version number\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    // don\\'t adjust the first value since that\\'s the version number\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char) (data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    validateVersion(data, p);\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n\n    int nstates = ATNSimulator.toInt(data[p++]);\n    appendStateData(buf, data, nstates, p);\n    \n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    skipNonGreedyStates(data, numNonGreedyStates, p);\n\n    appendRuleData(buf, data, g, p);\n    appendModeData(buf, data, p);\n    appendSetData(buf, data, p);\n    appendEdgeData(buf, data, p);\n    appendDecisionData(buf, data, p);\n\n    return buf.toString();\n}",
                "private void validateVersion(char[] data, int p) {\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n}",
                "private void appendStateData(StringBuilder buf, char[] data, int nstates, int p) {\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue;\n\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = getStateArg(stype, data, p);\n        buf.append(i - 1).append(\":\")\n           .append(ATNState.serializationNames.get(stype)).append(\" \")\n           .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n}",
                "private String getStateArg(int stype, char[] data, int p) {\n    String arg = \"\";\n    if (stype == ATNState.LOOP_END) {\n        int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n        arg = \" \" + loopBackStateNumber;\n    } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n        int endStateNumber = ATNSimulator.toInt(data[p++]);\n        arg = \" \" + endStateNumber;\n    }\n    return arg;\n}",
                "private void skipNonGreedyStates(char[] data, int numNonGreedyStates, int p) {\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        ATNSimulator.toInt(data[p++]);\n    }\n}",
                "private void appendRuleData(StringBuilder buf, char[] data, Grammar g, int p) {\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n}",
                "private void appendModeData(StringBuilder buf, char[] data, int p) {\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n}",
                "private void appendSetData(StringBuilder buf, char[] data, int p) {\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n}",
                "private void appendEdgeData(StringBuilder buf, char[] data, int p) {\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n           .append(\" \").append(Transition.serializationNames.get(ttype))\n           .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n           .append(\"\\\n\");\n        p += 6;\n    }\n}",
                "private void appendDecisionData(StringBuilder buf, char[] data, int p) {\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public String decode(char[] data) {\n    data = data.clone();\n    // don\\'t adjust the first value since that\\'s the version number\n    for (int i = 1; i < data.length; i++) {\n        data[i] = (char)(data[i] - 2);\n    }\n\n    StringBuilder buf = new StringBuilder();\n    int p = 0;\n    int version = ATNSimulator.toInt(data[p++]);\n    if (version != ATNSimulator.SERIALIZED_VERSION) {\n        String reason = String.format(\"Could not deserialize ATN with version %d (expected %d).\", version, ATNSimulator.SERIALIZED_VERSION);\n        throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));\n    }\n\n    int grammarType = ATNSimulator.toInt(data[p++]);\n    int maxType = ATNSimulator.toInt(data[p++]);\n    buf.append(\"max type \").append(maxType).append(\"\\\n\");\n    int nstates = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nstates; i++) {\n        int stype = ATNSimulator.toInt(data[p++]);\n        if (stype == ATNState.INVALID_TYPE) continue; // ignore bad type of states\n        int ruleIndex = ATNSimulator.toInt(data[p++]);\n        String arg = \"\";\n        if (stype == ATNState.LOOP_END) {\n            int loopBackStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + loopBackStateNumber;\n        } else if (stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START) {\n            int endStateNumber = ATNSimulator.toInt(data[p++]);\n            arg = \" \" + endStateNumber;\n        }\n        buf.append(i - 1).append(\":\")\n            .append(ATNState.serializationNames.get(stype)).append(\" \")\n            .append(ruleIndex).append(arg).append(\"\\\n\");\n    }\n    int numNonGreedyStates = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < numNonGreedyStates; i++) {\n        int stateNumber = ATNSimulator.toInt(data[p++]);\n    }\n    int nrules = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nrules; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        if (g.isLexer()) {\n            int arg1 = ATNSimulator.toInt(data[p++]);\n            int arg2 = ATNSimulator.toInt(data[p++]);\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\" \").append(arg1).append(\",\").append(arg2).append(\\'\\\n\\');\n        } else {\n            buf.append(\"rule \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n        }\n    }\n    int nmodes = ATNSimulator.toInt(data[p++]);\n    for (int i = 0; i < nmodes; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(\"mode \").append(i).append(\":\").append(s).append(\\'\\\n\\');\n    }\n    int nsets = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nsets; i++) {\n        int nintervals = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\");\n        for (int j = 1; j <= nintervals; j++) {\n            if (j > 1) buf.append(\", \");\n            buf.append(getTokenName(ATNSimulator.toInt(data[p]))).append(\"..\").append(getTokenName(ATNSimulator.toInt(data[p + 1])));\n            p += 2;\n        }\n        buf.append(\"\\\n\");\n    }\n    int nedges = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= nedges; i++) {\n        int src = ATNSimulator.toInt(data[p]);\n        int trg = ATNSimulator.toInt(data[p + 1]);\n        int ttype = ATNSimulator.toInt(data[p + 2]);\n        int arg1 = ATNSimulator.toInt(data[p + 3]);\n        int arg2 = ATNSimulator.toInt(data[p + 4]);\n        int arg3 = ATNSimulator.toInt(data[p + 5]);\n        buf.append(src).append(\"->\").append(trg)\n            .append(\" \").append(Transition.serializationNames.get(ttype))\n            .append(\" \").append(arg1).append(\",\").append(arg2).append(\",\").append(arg3)\n            .append(\"\\\n\");\n        p += 6;\n    }\n    int ndecisions = ATNSimulator.toInt(data[p++]);\n    for (int i = 1; i <= ndecisions; i++) {\n        int s = ATNSimulator.toInt(data[p++]);\n        buf.append(i - 1).append(\":\").append(s).append(\"\\\n\");\n    }\n    return buf.toString();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L9806": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.target.getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "AfterRefact": "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n\t\tDecl d;\n\t\tif ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {\n\t\t\tString implLabel =\n\t\t\t\tgen.getTarget().getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\telse if ( ast.getType()==ANTLRParser.RULE_REF ) { // a rule reference?\n\t\t\tRule r = g.getRule(ast.getText());\n\t\t\tString implLabel = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tString ctxName =\n\t\t\t\tgen.getTarget().getRuleFunctionContextStructName(r);\n\t\t\td = new RuleContextDecl(this, implLabel, ctxName);\n\t\t\t((RuleContextDecl)d).isImplicit = true;\n\t\t}\n\t\telse {\n\t\t\tString implLabel = gen.getTarget().getImplicitTokenLabel(ast.getText());\n\t\t\td = getTokenLabelDecl(implLabel);\n\t\t\t((TokenDecl)d).isImplicit = true;\n\t\t}\n\t\top.getLabels().add(d);\n\t\t// all labels must be in scope struct in case we exec action out of context\n\t\tgetCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d = createImplicitDecl(ast);\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}",
                "private Decl createImplicitDecl(GrammarAST ast) {\n    Decl d;\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } else if (ast.getType() == ANTLRParser.RULE_REF) {\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n    markAsImplicit(d);\n    return d;\n}",
                "private void markAsImplicit(Decl d) {\n    if (d instanceof TokenDecl) {\n        ((TokenDecl) d).isImplicit = true;\n    } else if (d instanceof RuleContextDecl) {\n        ((RuleContextDecl) d).isImplicit = true;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    if ( ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD ) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl)d).isImplicit = true;\n    } else if ( ast.getType() == ANTLRParser.RULE_REF ) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl)d).isImplicit = true;\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl)d).isImplicit = true;\n    }\n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n    op.getLabels().add(d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n\n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        String implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        String implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n        ((RuleContextDecl) d).isImplicit = true;\n    } else {\n        String implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n        ((TokenDecl) d).isImplicit = true;\n    }\n\n    op.getLabels().add(d);\n    // all labels must be in scope struct in case we exec action out of context\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl decl;\n    String implLabel;\n    \n    switch (ast.getType()) {\n        case ANTLRParser.SET:\n        case ANTLRParser.WILDCARD:\n            implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n            decl = getTokenLabelDecl(implLabel);\n            ((TokenDecl) decl).isImplicit = true;\n            break;\n\n        case ANTLRParser.RULE_REF:\n            Rule rule = g.getRule(ast.getText());\n            implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n            String contextName = gen.target.getRuleFunctionContextStructName(rule);\n            decl = new RuleContextDecl(this, implLabel, contextName);\n            ((RuleContextDecl) decl).isImplicit = true;\n            break;\n\n        default:\n            implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n            decl = getTokenLabelDecl(implLabel);\n            ((TokenDecl) decl).isImplicit = true;\n            break;\n    }\n\n    op.getLabels().add(decl);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), decl);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {\n    Decl d;\n    String implLabel;\n    \n    if (ast.getType() == ANTLRParser.SET || ast.getType() == ANTLRParser.WILDCARD) {\n        implLabel = gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));\n        d = getTokenLabelDecl(implLabel);\n    } else if (ast.getType() == ANTLRParser.RULE_REF) { // a rule reference?\n        Rule r = g.getRule(ast.getText());\n        implLabel = gen.target.getImplicitRuleLabel(ast.getText());\n        String ctxName = gen.target.getRuleFunctionContextStructName(r);\n        d = new RuleContextDecl(this, implLabel, ctxName);\n    } else {\n        implLabel = gen.target.getImplicitTokenLabel(ast.getText());\n        d = getTokenLabelDecl(implLabel);\n    }\n    \n    ((TokenDecl)d).isImplicit = true;\n    op.getLabels().add(d);\n    getCurrentRuleFunction().addContextDecl(ast.getAltLabel(), d);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L1506": {
        "RefactMethod": "CONSOLIDATE CONDITIONAL EXPRESSION",
        "BeforeRefact": "public void addTransition(Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(e);\n\t}",
        "AfterRefact": "public void addTransition(Transition e) {\n\t\taddTransition(transitions.size(), e);\n\t}\n\n\tpublic void addTransition(int index, Transition e) {\n\t\tif (transitions.isEmpty()) {\n\t\t\tepsilonOnlyTransitions = e.isEpsilon();\n\t\t}\n\t\telse if (epsilonOnlyTransitions != e.isEpsilon()) {\n\t\t\tSystem.err.format(Locale.getDefault(), \"ATN state %d has both epsilon and non-epsilon transitions.\\n\", stateNumber);\n\t\t\tepsilonOnlyTransitions = false;\n\t\t}\n\n\t\ttransitions.add(index, e);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilon;\n    } else if (epsilonOnlyTransitions != isEpsilon) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    if (transitions.isEmpty() || epsilonOnlyTransitions == isEpsilon) {\n        if (transitions.isEmpty()) {\n            epsilonOnlyTransitions = isEpsilon;\n        }\n        transitions.add(e);\n    } else {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n        transitions.add(e);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    if (isInvalidTransition(e)) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    } else if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = e.isEpsilon();\n    }\n    \n    transitions.add(e);\n}",
                "private boolean isInvalidTransition(Transition e) {\n    return !transitions.isEmpty() && (epsilonOnlyTransitions != e.isEpsilon());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilonTransition = e.isEpsilon();\n\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilonTransition;\n    } else if (epsilonOnlyTransitions != isEpsilonTransition) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.%n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addTransition(Transition e) {\n    boolean isEpsilon = e.isEpsilon();\n    if (transitions.isEmpty()) {\n        epsilonOnlyTransitions = isEpsilon;\n    } else if (epsilonOnlyTransitions != isEpsilon) {\n        System.err.format(\"ATN state %d has both epsilon and non-epsilon transitions.\\\n\", stateNumber);\n        epsilonOnlyTransitions = false;\n    }\n\n    transitions.add(e);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L1991": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) {\n                            System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        }\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions() && (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            }\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n            return currentAltReachedAcceptState;\n        }\n\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                    if (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                    configs.add(c);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (config.state.onlyHasEpsilonTransitions() || !(currentAltReachedAcceptState && config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // we have no context info. Don\\'t pursue but\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        handleRuleStopState(config, configs);\n        return processContext(config, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState state = config.state;\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        LexerATNConfig nextConfig = getEpsilonTarget(input, config, transition, configs, speculative);\n        if (nextConfig != null) {\n            currentAltReachedAcceptState = closure(input, nextConfig, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}",
                "private void handleRuleStopState(LexerATNConfig config, ATNConfigSet configs) {\n    if (debug) {\n        String message = recog != null ? String.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config)\n                                         : String.format(\"closure at rule stop %s\\\n\", config);\n        System.out.println(message);\n    }\n\n    if (config.context == null || config.context.hasEmptyPath()) {\n        if (config.context == null || config.context.isEmpty()) {\n            configs.add(config);\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n        }\n    }\n}",
                "private boolean processContext(LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                currentAltReachedAcceptState = processSingletonContext(config, configs, currentAltReachedAcceptState, ctx);\n            }\n        }\n    }\n    return currentAltReachedAcceptState;\n}",
                "private boolean processSingletonContext(LexerATNConfig config, ATNConfigSet configs, boolean currentAltReachedAcceptState, SingletonPredictionContext ctx) {\n    PredictionContext newContext = ctx.parent; // \"pop\" return state\n\n    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n        if (debug) {\n            System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n        }\n        configs.add(c);\n        return currentAltReachedAcceptState;\n    }\n\n    ATNState returnState = atn.states.get(ctx.returnState);\n    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n    return closure(input, c, configs, currentAltReachedAcceptState, speculative);\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n    }\n\n    if (config.context != null && !config.context.isEmpty()) {\n        for (SingletonPredictionContext ctx : config.context) {\n            if (!ctx.isEmpty()) {\n                PredictionContext newContext = ctx.parent; // \"pop\" return state\n                if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                    if (debug) {\n                        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                    }\n                    configs.add(c);\n                    continue;\n                }\n                ATNState returnState = atn.states.get(ctx.returnState);\n                LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n            }\n        }\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions() && (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision())) {\n        configs.add(config);\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L19910": {
        "RefactMethod": "INTRODUCE SPECIAL CASE",
        "BeforeRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(\"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\t\t\tif ( !ctx.isEmpty() ) {\n\t\t\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\t\t\tif ( ctx.returnState==PredictionContext.EMPTY_RETURN_STATE ) {\n\t\t\t\t\t\t\t// we have no context info. Don't pursue but\n\t\t\t\t\t\t\t// record a config that indicates how we hit end\n\t\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\t\t\tif ( debug ) System.out.println(\"FALLING off token \"+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    recog.getRuleNames()[config.state.ruleIndex]+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \" record \"+c);\n\t\t\t\t\t\t\tconfigs.add(c);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "AfterRefact": "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+config.toString(recog, true)+\")\");\n\t\t}\n\n\t\tif ( config.state instanceof RuleStopState ) {\n\t\t\tif ( debug ) {\n\t\t\t\tif ( recog!=null ) {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at %s rule stop %s\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.format(Locale.getDefault(), \"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context == null || config.context.hasEmptyPath() ) {\n\t\t\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.context!=null && !config.context.isEmpty() ) {\n\t\t\t\tfor (int i = 0; i < config.context.size(); i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tPredictionContext newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tATNState returnState = atn.states.get(config.context.getReturnState(i));\n\t\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif ( !config.state.onlyHasEpsilonTransitions() ) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tATNState p = config.state;\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\t\tif ( c!=null ) {\n\t\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n\tif (debug) {\n\t\tSystem.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n\t}\n\n\tif (isRuleStopState(config.state)) {\n\t\thandleRuleStopState(input, config, configs);\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// optimization\n\tif (!config.state.onlyHasEpsilonTransitions()) {\n\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n\t\t\tconfigs.add(config);\n\t\t}\n\t}\n\n\tATNState p = config.state;\n\tfor (int i = 0; i < p.getNumberOfTransitions(); i++) {\n\t\tTransition t = p.transition(i);\n\t\tLexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n\t\tif (c != null) {\n\t\t\tcurrentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n\t\t}\n\t}\n\n\treturn currentAltReachedAcceptState;\n}",
                "private boolean isRuleStopState(ATNState state) {\n\treturn state instanceof RuleStopState;\n}",
                "private void handleRuleStopState(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs) {\n\tif (debug) {\n\t\tif (recog != null) {\n\t\t\tSystem.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n\t\t} else {\n\t\t\tSystem.out.format(\"closure at rule stop %s\\\n\", config);\n\t\t}\n\t}\n\n\tif (config.context == null || config.context.hasEmptyPath()) {\n\t\tif (config.context == null || config.context.isEmpty()) {\n\t\t\tconfigs.add(config);\n\t\t} else {\n\t\t\tconfigs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n\t\t}\n\t} else {\n\t\tfor (SingletonPredictionContext ctx : config.context) {\n\t\t\tif (!ctx.isEmpty()) {\n\t\t\t\tPredictionContext newContext = ctx.parent; // \"pop\" return state\n\t\t\t\tif (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n\t\t\t\t\tif (debug) {\n\t\t\t\t\t\tSystem.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n\t\t\t\t\t}\n\t\t\t\t\tconfigs.add(c);\n\t\t\t\t} else {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.returnState);\n\t\t\t\t\tLexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n\t\t\t\t\tclosure(input, c, configs, true, speculative);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (isRuleStopState(config.state)) {\n        if (debug) {\n            logRuleStopState(config);\n        }\n\n        if (isContextEmpty(config)) {\n            configs.add(config);\n            return true;\n        } else {\n            configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n            currentAltReachedAcceptState = true;\n        }\n\n        if (!isContextEmpty(config) && config.context != null) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        // record a config that indicates how we hit end\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}",
                "private boolean isRuleStopState(ATNState state) {\n    return state instanceof RuleStopState;\n}",
                "private void logRuleStopState(LexerATNConfig config) {\n    if (recog != null) {\n        System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n    } else {\n        System.out.format(\"closure at rule stop %s\\\n\", config);\n    }\n}",
                "private boolean isContextEmpty(LexerATNConfig config) {\n    return config.context == null || config.context.isEmpty();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; \n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                          @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                          boolean speculative) {\n    logDebugInfo(config);\n\n    if (isRuleStopState(config.state)) {\n        return handleRuleStopState(input, config, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        addConfigIfNeeded(config, currentAltReachedAcceptState, configs);\n    }\n\n    return processTransitions(input, config, configs, currentAltReachedAcceptState, speculative);\n}",
                "private void logDebugInfo(LexerATNConfig config) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n        if (recog != null) {\n            System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n        } else {\n            System.out.format(\"closure at rule stop %s\\\n\", config);\n        }\n    }\n}",
                "private boolean isRuleStopState(ATNState state) {\n    return state instanceof RuleStopState;\n}",
                "private boolean handleRuleStopState(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                                     @NotNull ATNConfigSet configs, \n                                     boolean currentAltReachedAcceptState, boolean speculative) {\n    if (isContextEmpty(config.context)) {\n        configs.add(config);\n        return true;\n    }\n\n    if (config.context != null) {\n        if (config.context.hasEmptyPath()) {\n            return handleEmptyPathContext(config, configs, currentAltReachedAcceptState);\n        }\n        return handleNonEmptyContext(input, config, configs, currentAltReachedAcceptState, speculative);\n    }\n\n    return currentAltReachedAcceptState;\n}",
                "private boolean isContextEmpty(PredictionContext context) {\n    return context == null || context.isEmpty();\n}",
                "private boolean handleEmptyPathContext(LexerATNConfig config, ATNConfigSet configs, \n                                        boolean currentAltReachedAcceptState) {\n    configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n    return true;\n}",
                "private boolean handleNonEmptyContext(@NotNull CharStream input, @NotNull LexerATNConfig config,\n                                       @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                                       boolean speculative) {\n    for (SingletonPredictionContext ctx : config.context) {\n        if (!ctx.isEmpty()) {\n            currentAltReachedAcceptState = processContext(input, config, configs, currentAltReachedAcceptState, speculative, ctx);\n        }\n    }\n    return currentAltReachedAcceptState;\n}",
                "private boolean processContext(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                               @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                               boolean speculative, SingletonPredictionContext ctx) {\n    PredictionContext newContext = ctx.parent; // \"pop\" return state\n    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n        recordEndState(config, ctx, configs);\n    } else {\n        ATNState returnState = atn.states.get(ctx.returnState);\n        LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n        currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n    }\n    return currentAltReachedAcceptState;\n}",
                "private void recordEndState(LexerATNConfig config, SingletonPredictionContext ctx, \n                            ATNConfigSet configs) {\n    LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n    if (debug) {\n        System.out.println(\"FALLING off token \" + recog.getRuleNames()[config.state.ruleIndex] + \n                           \" record \" + c);\n    }\n    configs.add(c);\n}",
                "private void addConfigIfNeeded(LexerATNConfig config, boolean currentAltReachedAcceptState, \n                              ATNConfigSet configs) {\n    if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n        configs.add(config);\n    }\n}",
                "private boolean processTransitions(@NotNull CharStream input, @NotNull LexerATNConfig config, \n                                   @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, \n                                   boolean speculative) {\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig config, @NotNull ATNConfigSet configs, boolean currentAltReachedAcceptState, boolean speculative) {\n    if (debug) {\n        System.out.println(\"closure(\" + config.toString(recog, true) + \")\");\n    }\n\n    if (config.state instanceof RuleStopState) {\n        if (debug) {\n            if (recog != null) {\n                System.out.format(\"closure at %s rule stop %s\\\n\", recog.getRuleNames()[config.state.ruleIndex], config);\n            } else {\n                System.out.format(\"closure at rule stop %s\\\n\", config);\n            }\n        }\n\n        if (config.context == null || config.context.hasEmptyPath()) {\n            if (config.context == null || config.context.isEmpty()) {\n                configs.add(config);\n                return true;\n            } else {\n                configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));\n                currentAltReachedAcceptState = true;\n            }\n        }\n\n        if (config.context != null && !config.context.isEmpty()) {\n            for (SingletonPredictionContext ctx : config.context) {\n                if (!ctx.isEmpty()) {\n                    PredictionContext newContext = ctx.parent; // \"pop\" return state\n                    if (ctx.returnState == PredictionContext.EMPTY_RETURN_STATE) {\n                        LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);\n                        if (debug) System.out.println(\"FALLING off token \" +\n                                recog.getRuleNames()[config.state.ruleIndex] +\n                                \" record \" + c);\n                        configs.add(c);\n                        continue;\n                    }\n                    ATNState returnState = atn.states.get(ctx.returnState);\n                    LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);\n                    currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n                }\n            }\n        }\n\n        return currentAltReachedAcceptState;\n    }\n\n    // optimization\n    if (!config.state.onlyHasEpsilonTransitions()) {\n        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision()) {\n            configs.add(config);\n        }\n    }\n\n    ATNState p = config.state;\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        LexerATNConfig c = getEpsilonTarget(input, config, t, configs, speculative);\n        if (c != null) {\n            currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);\n        }\n    }\n\n    return currentAltReachedAcceptState;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2113": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (SingletonPredictionContext p : ctx) {\n\t\t\t\t\tATNState returnState = atn.states.get(p.returnState);\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\t\t\t\t\t_LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\t\t\t\t_LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void _LOOK(@NotNull ATNState s,\n\t\t\t\t\t\t @Nullable ATNState stopState,\n\t\t\t\t\t\t @Nullable PredictionContext ctx,\n\t\t\t\t\t\t @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n\t\t\t\t\t\t @NotNull BitSet calledRuleStack,\n\t\t\t\t\t\t boolean seeThruPreds, boolean addEOF)\n\t{\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        ATNConfig c = new ATNConfig(s, 0, ctx);\n        if ( !lookBusy.add(c) ) return;\n\n\t\tif (s == stopState) {\n\t\t\tif (ctx == null) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n        if ( s instanceof RuleStopState ) {\n            if ( ctx==null ) {\n                look.add(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n\t\t\t\tlook.add(Token.EOF);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ctx != PredictionContext.EMPTY ) {\n\t\t\t\t// run thru all possible stack tops in ctx\n\t\t\t\tfor (int i = 0; i < ctx.size(); i++) {\n\t\t\t\t\tATNState returnState = atn.states.get(ctx.getReturnState(i));\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\n\t\t\t\t\tboolean removed = calledRuleStack.get(returnState.ruleIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcalledRuleStack.clear(returnState.ruleIndex);\n\t\t\t\t\t\t_LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tcalledRuleStack.set(returnState.ruleIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n        }\n\n        int n = s.getNumberOfTransitions();\n        for (int i=0; i<n; i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tif ( t.getClass() == RuleTransition.class ) {\n\t\t\t\tif (calledRuleStack.get(((RuleTransition)t).target.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPredictionContext newContext =\n\t\t\t\t\tSingletonPredictionContext.create(ctx, ((RuleTransition)t).followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t\t_LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(((RuleTransition)t).target.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t instanceof PredicateTransition ) {\n\t\t\t\tif ( seeThruPreds ) {\n\t\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( t.isEpsilon() ) {\n\t\t\t\t_LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if ( t.getClass() == WildcardTransition.class ) {\n\t\t\t\tlook.addAll( IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType) );\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tIntervalSet set = t.label();\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t instanceof RuleTransition) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof WildcardTransition) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void lookAhead(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                         @NotNull IntervalSet look,\n                         @NotNull Set<ATNConfig> lookBusy,\n                         boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty() && addEOF) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                lookAhead(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            lookAhead(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                lookAhead(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            lookAhead(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds, boolean addEOF) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        handleRuleStopState(ctx, look, addEOF);\n        return;\n    }\n\n    processTransitions(s, ctx, look, lookBusy, seeThruPreds, addEOF);\n}",
                "private void handleRuleStopState(@Nullable PredictionContext ctx, \n                                  @NotNull IntervalSet look,\n                                  boolean addEOF) {\n    if (ctx == null) {\n        look.add(Token.EPSILON);\n    } else if (ctx.isEmpty() && addEOF) {\n        look.add(Token.EOF);\n    } else if (ctx != PredictionContext.EMPTY) {\n        for (SingletonPredictionContext p : ctx) {\n            ATNState returnState = atn.states.get(p.returnState);\n            _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds, addEOF);\n        }\n    }\n}",
                "private void processTransitions(@NotNull ATNState s,\n                                 @Nullable PredictionContext ctx,\n                                 @NotNull IntervalSet look,\n                                 @NotNull Set<ATNConfig> lookBusy,\n                                 boolean seeThruPreds, \n                                 boolean addEOF) {\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        processTransition(t, ctx, look, lookBusy, seeThruPreds, addEOF);\n    }\n}",
                "private void processTransition(Transition t, \n                               @Nullable PredictionContext ctx,\n                               @NotNull IntervalSet look,\n                               @NotNull Set<ATNConfig> lookBusy,\n                               boolean seeThruPreds,\n                               boolean addEOF) {\n    if (t instanceof RuleTransition) {\n        PredictionContext newContext = SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n        _LOOK(t.target, newContext, look, lookBusy, seeThruPreds, addEOF);\n    } else if (t instanceof PredicateTransition) {\n        if (seeThruPreds) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n        } else {\n            look.add(HIT_PRED);\n        }\n    } else if (t.isEpsilon()) {\n        _LOOK(t.target, ctx, look, lookBusy, seeThruPreds, addEOF);\n    } else if (t instanceof WildcardTransition) {\n        look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n    } else {\n        IntervalSet set = t.label();\n        if (set != null) {\n            if (t instanceof NotSetTransition) {\n                set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n            }\n            look.addAll(set);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,\n                     @NotNull IntervalSet look,\n                     @NotNull Set<ATNConfig> lookBusy,\n                     boolean seeThruPreds) {\n    ATNConfig c = new ATNConfig(s, 0, ctx);\n    if (!lookBusy.add(c)) return;\n\n    if (s instanceof RuleStopState) {\n        if (ctx == null) {\n            look.add(Token.EPSILON);\n            return;\n        } else if (ctx.isEmpty()) {\n            look.add(Token.EOF);\n            return;\n        }\n\n        if (ctx != PredictionContext.EMPTY) {\n            for (SingletonPredictionContext p : ctx) {\n                ATNState returnState = atn.states.get(p.returnState);\n                _LOOK(returnState, p.parent, look, lookBusy, seeThruPreds);\n            }\n            return;\n        }\n    }\n\n    int n = s.getNumberOfTransitions();\n    for (int i = 0; i < n; i++) {\n        Transition t = s.transition(i);\n        if (t.getClass() == RuleTransition.class) {\n            PredictionContext newContext =\n                SingletonPredictionContext.create(ctx, ((RuleTransition) t).followState.stateNumber);\n            _LOOK(t.target, newContext, look, lookBusy, seeThruPreds);\n        } else if (t instanceof PredicateTransition) {\n            if (seeThruPreds) {\n                _LOOK(t.target, ctx, look, lookBusy, seeThruPreds);\n            } else {\n                look.add(HIT_PRED);\n            }\n        } else if (t.isEpsilon()) {\n            _LOOK(t.target, ctx, look, lookBusy, seeThruPreds);\n        } else if (t.getClass() == WildcardTransition.class) {\n            look.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n        } else {\n            IntervalSet set = t.label();\n            if (set != null) {\n                if (t instanceof NotSetTransition) {\n                    set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));\n                }\n                look.addAll(set);\n            }\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2427": {
        "RefactMethod": "REPLACE NESTED CONDITIONAL WITH GUARD CLAUSES",
        "BeforeRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "AfterRefact": "protected void closure_(@NotNull ATNConfig config,\n\t\t\t\t\t\t\t@NotNull ATNConfigSet configs,\n\t\t\t\t\t\t\t@NotNull Set<ATNConfig> closureBusy,\n\t\t\t\t\t\t\tboolean collectPredicates,\n\t\t\t\t\t\t\tboolean fullCtx,\n\t\t\t\t\t\t\tint depth)\n\t{\n\t\tATNState p = config.state;\n\t\t// optimization\n\t\tif ( !p.onlyHasEpsilonTransitions() ) {\n            configs.add(config, mergeCache);\n//            if ( debug ) System.out.println(\"added config \"+configs);\n        }\n\n\t\tfor (int i=0; i<p.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = p.transition(i);\n\t\t\tboolean continueCollecting =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tATNConfig c = getEpsilonTarget(config, t, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t   depth == 0, fullCtx);\n\t\t\tif ( c!=null ) {\n\t\t\t\tint newDepth = depth;\n\t\t\t\tif ( config.state instanceof RuleStopState) {\n\t\t\t\t\tassert !fullCtx;\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tc.reachesIntoOuterContext++;\n\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\t\t\t\t\tassert newDepth > Integer.MIN_VALUE;\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif ( debug ) System.out.println(\"dips into outer ctx: \"+c);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclosureCheckingStopState(c, configs, closureBusy, continueCollecting,\n\t\t\t\t\t\t\t\t\t\t fullCtx, newDepth);\n\t\t\t}\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    if (p.onlyHasEpsilonTransitions()) {\n        return; // Early exit if there are only epsilon transitions\n    }\n\n    configs.add(config, mergeCache);\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c == null) {\n            continue; // Skip to the next transition if no config is returned\n        }\n\n        int newDepth = depth;\n\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n\n            if (debug) {\n                System.out.println(\"dips into outer ctx: \" + c);\n            }\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    // optimization\n    if (!p.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        \n        if (c == null) {\n            continue; // Guard clause for null c\n        }\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n\n    // optimization\n    if (p.onlyHasEpsilonTransitions()) return;\n\n    configs.add(config, mergeCache);\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        if (c == null) continue;\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n        } else if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState state = config.state;\n\n    if (!state.onlyHasEpsilonTransitions()) {\n        configs.add(config, mergeCache);\n    }\n\n    for (int i = 0; i < state.getNumberOfTransitions(); i++) {\n        Transition transition = state.transition(i);\n        boolean shouldCollect = !(transition instanceof ActionTransition) && collectPredicates;\n        ATNConfig targetConfig = getEpsilonTarget(config, transition, shouldCollect, depth == 0, fullCtx);\n\n        if (targetConfig != null) {\n            int currentDepth = depth;\n\n            if (config.state instanceof RuleStopState) {\n                assert !fullCtx;\n                targetConfig.reachesIntoOuterContext++;\n                configs.dipsIntoOuterContext = true;\n                assert currentDepth > Integer.MIN_VALUE;\n                currentDepth--;\n\n                if (debug) {\n                    System.out.println(\"dips into outer ctx: \" + targetConfig);\n                }\n            } else if (transition instanceof RuleTransition) {\n                if (currentDepth >= 0) {\n                    currentDepth++;\n                }\n            }\n\n            closureCheckingStopState(targetConfig, configs, closureBusy, shouldCollect, fullCtx, currentDepth);\n        }\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void closure_(@NotNull ATNConfig config,\n                        @NotNull ATNConfigSet configs,\n                        @NotNull Set<ATNConfig> closureBusy,\n                        boolean collectPredicates,\n                        boolean fullCtx,\n                        int depth) {\n    ATNState p = config.state;\n    \n    // optimization\n    if (p.onlyHasEpsilonTransitions()) {\n        return;\n    }\n    configs.add(config, mergeCache);\n\n    for (int i = 0; i < p.getNumberOfTransitions(); i++) {\n        Transition t = p.transition(i);\n        boolean continueCollecting = !(t instanceof ActionTransition) && collectPredicates;\n        ATNConfig c = getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);\n        if (c == null) {\n            continue;\n        }\n\n        int newDepth = depth;\n        if (config.state instanceof RuleStopState) {\n            assert !fullCtx;\n            c.reachesIntoOuterContext++;\n            configs.dipsIntoOuterContext = true;\n            assert newDepth > Integer.MIN_VALUE;\n            newDepth--;\n            if (debug) System.out.println(\"dips into outer ctx: \" + c);\n            closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n            continue;\n        }\n\n        if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n                newDepth++;\n            }\n        }\n\n        closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L9795": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.target.getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.target.getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.target.getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "AfterRefact": "public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n\t\tsuper(factory, ast);\n\t\tif ( ast.atnState!=null ) {\n\t\t\tRuleTransition ruleTrans = (RuleTransition)ast.atnState.transition(0);\n\t\t\tstateNumber = ast.atnState.stateNumber;\n\t\t}\n\n\t\tthis.name = ast.getText();\n\t\tCodeGenerator gen = factory.getGenerator();\n\t\tRule r = factory.getGrammar().getRule(name);\n\t\tctxName = gen.getTarget().getRuleFunctionContextStructName(r);\n\n\t\t// TODO: move to factory\n\t\tRuleFunction rf = factory.getCurrentRuleFunction();\n\t\tif ( labelAST!=null ) {\n\t\t\t// for x=r, define <rule-context-type> x and list_x\n\t\t\tString label = labelAST.getText();\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN  ) {\n\t\t\t\tfactory.defineImplicitLabel(ast, this);\n\t\t\t\tString listLabel = gen.getTarget().getListLabel(label);\n\t\t\t\tRuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\t\tlabels.add(d);\n\t\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t\t}\n\t\t}\n\t\tif ( ast.getChildCount()>0 ) {\n\t\t\tActionAST arg = (ActionAST)ast.getChild(0);\n\t\t\targExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n\t\t}\n\n\t\t// If action refs rule as rulename not label, we need to define implicit label\n\t\tif ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {\n\t\t\tString label = gen.getTarget().getImplicitRuleLabel(ast.getText());\n\t\t\tRuleContextDecl d = new RuleContextDecl(factory,label,ctxName);\n\t\t\tlabels.add(d);\n\t\t\trf.addContextDecl(ast.getAltLabel(), d);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private void handleLabelAST(ParserFactory factory, GrammarAST labelAST, GrammarAST ast, CodeGenerator gen, RuleFunction rf) {\n    if (labelAST != null) {\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n}",
                "private void processChildActions(ParserFactory factory, RuleFunction rf, GrammarAST ast) {\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast, CodeGenerator gen, RuleFunction rf) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    handleLabelAST(factory, labelAST, ast, gen, rf);\n    processChildActions(factory, rf, ast);\n    defineImplicitLabelIfNeeded(factory, ast, gen, rf);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    \n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    \n    if (labelAST != null) {\n        // for x=r, define <rule-context-type> x and list_x\n        String label = labelAST.getText();\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    \n    if (labelAST != null) {\n        // for x=r, define <rule-context-type> x and list_x\n        String label = labelAST.getText();\n        \n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    }\n\n    if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void initializeStateNumber(GrammarAST ast) {\n    if (ast.atnState != null) {\n        RuleTransition ruleTransition = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n}",
                "private void initializeContextName(ParserFactory factory) {\n    CodeGenerator generator = factory.getGenerator();\n    Rule rule = factory.getGrammar().getRule(name);\n    ctxName = generator.target.getRuleFunctionContextStructName(rule);\n}",
                "private void processLabelAST(ParserFactory factory, GrammarAST labelAST, RuleFunction ruleFunction) {\n    String label = labelAST.getText();\n    \n    if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n        factory.defineImplicitLabel(ast, this);\n        String listLabel = factory.getGenerator().target.getListLabel(label);\n        RuleContextListDecl listDecl = new RuleContextListDecl(factory, listLabel, ctxName);\n        ruleFunction.addContextDecl(ast.getAltLabel(), listDecl);\n    } else {\n        RuleContextDecl contextDecl = new RuleContextDecl(factory, label, ctxName);\n        labels.add(contextDecl);\n        ruleFunction.addContextDecl(ast.getAltLabel(), contextDecl);\n    }\n}",
                "private void defineImplicitLabelIfNeeded(ParserFactory factory, GrammarAST ast, RuleFunction ruleFunction) {\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String implicitLabel = factory.getGenerator().target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl contextDecl = new RuleContextDecl(factory, implicitLabel, ctxName);\n        labels.add(contextDecl);\n        ruleFunction.addContextDecl(ast.getAltLabel(), contextDecl);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    initializeStateNumber(ast);\n    this.name = ast.getText();\n    initializeContextName(factory);\n    RuleFunction ruleFunction = factory.getCurrentRuleFunction();\n    \n    if (labelAST != null) {\n        processLabelAST(factory, labelAST, ruleFunction);\n    }\n    \n    if (ast.getChildCount() > 0) {\n        ActionAST argument = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, ruleFunction, argument.token, argument);\n    }\n    \n    defineImplicitLabelIfNeeded(factory, ast, ruleFunction);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {\n    super(factory, ast);\n    if (ast.atnState != null) {\n        RuleTransition ruleTrans = (RuleTransition) ast.atnState.transition(0);\n        stateNumber = ast.atnState.stateNumber;\n    }\n\n    this.name = ast.getText();\n    CodeGenerator gen = factory.getGenerator();\n    Rule r = factory.getGrammar().getRule(name);\n    ctxName = gen.target.getRuleFunctionContextStructName(r);\n\n    // TODO: move to factory\n    RuleFunction rf = factory.getCurrentRuleFunction();\n    if (labelAST != null) {\n        // for x=r, define <rule-context-type> x and list_x\n        String label = labelAST.getText();\n        if (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n            factory.defineImplicitLabel(ast, this);\n            String listLabel = gen.target.getListLabel(label);\n            RuleContextListDecl l = new RuleContextListDecl(factory, listLabel, ctxName);\n            rf.addContextDecl(ast.getAltLabel(), l);\n        } else {\n            RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n            labels.add(d);\n            rf.addContextDecl(ast.getAltLabel(), d);\n        }\n    } else if (ast.getChildCount() > 0) {\n        ActionAST arg = (ActionAST) ast.getChild(0);\n        argExprsChunks = ActionTranslator.translateAction(factory, rf, arg.token, arg);\n    }\n\n    // If action refs rule as rulename not label, we need to define implicit label\n    if (factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText())) {\n        String label = gen.target.getImplicitRuleLabel(ast.getText());\n        RuleContextDecl d = new RuleContextDecl(factory, label, ctxName);\n        labels.add(d);\n        rf.addContextDecl(ast.getAltLabel(), d);\n    }\n}\n```"
            ]
        }
    },
    "L9861": {
        "RefactMethod": "SLIDE STATEMENTS",
        "BeforeRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.target.getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "AfterRefact": "public Lexer(OutputModelFactory factory, LexerFile file) {\n\t\tthis.factory = factory;\n\t\tthis.file = file; // who contains us?\n\t\tGrammar g = factory.getGrammar();\n\t\tgrammarFileName = new File(g.fileName).getName();\n\t\tname = g.getRecognizerName();\n\t\ttokens = new LinkedHashMap<String,Integer>();\n\t\tLexerGrammar lg = (LexerGrammar)g;\n\t\tatn = new SerializedATN(factory, lg.atn);\n\t\tmodes = lg.modes.keySet();\n\n\t\tfor (String t : g.tokenNameToTypeMap.keySet()) {\n\t\t\tInteger ttype = g.tokenNameToTypeMap.get(t);\n\t\t\tif ( ttype>0 ) tokens.put(t, ttype);\n\t\t}\n\n\t\ttokenNames = g.getTokenDisplayNames();\n        for (int i = 0; i < tokenNames.length; i++) {\n            if ( tokenNames[i]==null ) continue;\n            CodeGenerator gen = factory.getGenerator();\n            if ( tokenNames[i].charAt(0)=='\\'' ) {\n\t\t\t\tboolean addQuotes = false;\n\t\t\t\ttokenNames[i] =\n\t\t\t\t\tgen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttokenNames[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddQuotes);\n\t\t\t\ttokenNames[i] = \"\\\"'\"+tokenNames[i]+\"'\\\"\";\n            }\n            else {\n                tokenNames[i] = gen.getTarget().getTargetStringLiteralFromString(tokenNames[i], true);\n            }\n        }\n\t\truleNames = g.rules.keySet();\n\n\t\tif (g.getOptionString(\"superClass\") != null) {\n\t\t\tsuperClass = new ActionText(null, g.getOptionString(\"superClass\"));\n\t\t}\n\t\telse {\n\t\t\tsuperClass = new DefaultLexerSuperClass();\n\t\t}\n\t}\n\n}",
        "ZeroShotCode": {
            "methods": [
                "private void initializeGrammar(OutputModelFactory factory) {\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n    ruleNames = g.rules.keySet();\n}",
                "private void initializeTokens() {\n    tokens = new LinkedHashMap<>();\n    Grammar g = factory.getGrammar();\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n}",
                "private void initializeTokenNames(OutputModelFactory factory) {\n    CodeGenerator gen = factory.getGenerator();\n    tokenNames = factory.getGrammar().getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            tokenNames[i] = formatTokenNameWithQuotes(gen, tokenNames[i]);\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n}",
                "private String formatTokenNameWithQuotes(CodeGenerator gen, String tokenName) {\n    boolean addQuotes = false;\n    tokenName = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, addQuotes);\n    return \"\\\\\"\\'\" + tokenName + \"\\'\\\\\"\";\n}",
                "private void initializeSuperClass(Grammar g) {\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; \n    initializeGrammar(factory);\n    initializeTokens();\n    initializeTokenNames(factory);\n    initializeSuperClass(factory.getGrammar());\n}\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    tokenNames = g.getTokenDisplayNames();\n    CodeGenerator gen = factory.getGenerator(); // Moved up\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n    \n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    tokenNames = g.getTokenDisplayNames();\n    \n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String, Integer>();\n    LexerGrammar lg = (LexerGrammar) g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n        CodeGenerator gen = factory.getGenerator();\n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            boolean addQuotes = false;\n            tokenNames[i] = gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], addQuotes);\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        } else {\n            tokenNames[i] = gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        }\n    }\n\n    ruleNames = g.rules.keySet();\n\n    if (g.getOptionString(\"superClass\") != null) {\n        superClass = new ActionText(null, g.getOptionString(\"superClass\"));\n    } else {\n        superClass = new DefaultLexerSuperClass();\n    }\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private void initializeTokens(Grammar grammar) {\n    for (Map.Entry<String, Integer> entry : grammar.tokenNameToTypeMap.entrySet()) {\n        Integer tokenType = entry.getValue();\n        if (tokenType > 0) {\n            tokens.put(entry.getKey(), tokenType);\n        }\n    }\n}",
                "private void initializeTokenNames(OutputModelFactory factory) {\n    CodeGenerator generator = factory.getGenerator();\n    this.tokenNames = generator.getTargetTokenNames(grammar);\n\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] != null) {\n            tokenNames[i] = formatTokenName(tokenNames[i], generator);\n        }\n    }\n}",
                "private String formatTokenName(String tokenName, CodeGenerator generator) {\n    if (tokenName.charAt(0) == \\'\\\\\\'\\') {\n        return \"\\\\\"\\'\" + generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator, tokenName, false) + \"\\'\\\\\"\";\n    } else {\n        return generator.target.getTargetStringLiteralFromString(tokenName, true);\n    }\n}",
                "private ActionText determineSuperClass(Grammar grammar) {\n    String superClassName = grammar.getOptionString(\"superClass\");\n    return (superClassName != null) ? new ActionText(null, superClassName) : new DefaultLexerSuperClass();\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file;\n    \n    Grammar grammar = factory.getGrammar();\n    this.grammarFileName = new File(grammar.fileName).getName();\n    this.name = grammar.getRecognizerName();\n    this.tokens = new LinkedHashMap<>();\n    LexerGrammar lexerGrammar = (LexerGrammar) grammar;\n    this.atn = new SerializedATN(factory, lexerGrammar.atn);\n    this.modes = lexerGrammar.modes.keySet();\n\n    initializeTokens(grammar);\n    initializeTokenNames(factory);\n    this.ruleNames = grammar.rules.keySet();\n    this.superClass = determineSuperClass(grammar);\n}\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic Lexer(OutputModelFactory factory, LexerFile file) {\n    this.factory = factory;\n    this.file = file; // who contains us?\n    Grammar g = factory.getGrammar();\n    grammarFileName = new File(g.fileName).getName();\n    name = g.getRecognizerName();\n    tokens = new LinkedHashMap<String,Integer>();\n    LexerGrammar lg = (LexerGrammar)g;\n    atn = new SerializedATN(factory, lg.atn);\n    modes = lg.modes.keySet();\n\n    for (String t : g.tokenNameToTypeMap.keySet()) {\n        Integer ttype = g.tokenNameToTypeMap.get(t);\n        if (ttype > 0) tokens.put(t, ttype);\n    }\n\n    tokenNames = g.getTokenDisplayNames();\n    for (int i = 0; i < tokenNames.length; i++) {\n        if (tokenNames[i] == null) continue;\n\n        CodeGenerator gen = factory.getGenerator();\n        tokenNames[i] = (tokenNames[i].charAt(0) == \\'\\\\\\'\\') \n            ? gen.target.getTargetStringLiteralFromANTLRStringLiteral(gen, tokenNames[i], false) \n            : gen.target.getTargetStringLiteralFromString(tokenNames[i], true);\n        \n        if (tokenNames[i].charAt(0) == \\'\\\\\\'\\') {\n            tokenNames[i] = \"\\\\\"\\'\" + tokenNames[i] + \"\\'\\\\\"\";\n        }\n    }\n\n    ruleNames = g.rules.keySet();\n\n    superClass = (g.getOptionString(\"superClass\") != null) \n        ? new ActionText(null, g.getOptionString(\"superClass\")) \n        : new DefaultLexerSuperClass();\n}\n```"
            ]
        }
    },
    "L2093": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\tATNState s;\n\t\tswitch (type) {\n\t\t\tcase ATNState.INVALID_TYPE: return null;\n\t\t\tcase ATNState.BASIC : s = new BasicState(); break;\n\t\t\tcase ATNState.RULE_START : s = new RuleStartState(); break;\n\t\t\tcase ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n\t\t\tcase ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n\t\t\tcase ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n\t\t\tcase ATNState.TOKEN_START : s = new TokensStartState(); break;\n\t\t\tcase ATNState.RULE_STOP : s = new RuleStopState(); break;\n\t\t\tcase ATNState.BLOCK_END : s = new BlockEndState(); break;\n\t\t\tcase ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n\t\t\tcase ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n\t\t\tcase ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n\t\t\tcase ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n\t\t\t\tString message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n\t\t\t\tthrow new IllegalArgumentException(message);\n\t\t}\n\n\t\ts.ruleIndex = ruleIndex;\n\t\treturn s;\n\t}",
        "AfterRefact": "public static ATNState stateFactory(int type, int ruleIndex) {\n\t\treturn new ATNDeserializer().stateFactory(type, ruleIndex);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState s = createState(type);\n    if (s == null) {\n        String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n        throw new IllegalArgumentException(message);\n    }\n    s.ruleIndex = ruleIndex;\n    return s;\n}",
                "static ATNState createState(int type) {\n    switch (type) {\n        case ATNState.INVALID_TYPE: return null;\n        case ATNState.BASIC: return new BasicState();\n        case ATNState.RULE_START: return new RuleStartState();\n        case ATNState.BLOCK_START: return new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n        case ATNState.TOKEN_START: return new TokensStartState();\n        case ATNState.RULE_STOP: return new RuleStopState();\n        case ATNState.BLOCK_END: return new BlockEndState();\n        case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n        case ATNState.LOOP_END: return new LoopEndState();\n        default: return null;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }"
            ],
            "classes": [
                "class StateFactoryCommand {\n    private final int type;\n    private final int ruleIndex;\n\n    public StateFactoryCommand(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC: s = new BasicState(); break;\n            case ATNState.RULE_START: s = new RuleStartState(); break;\n            case ATNState.BLOCK_START: s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START: s = new TokensStartState(); break;\n            case ATNState.RULE_STOP: s = new RuleStopState(); break;\n            case ATNState.BLOCK_END: s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END: s = new LoopEndState(); break;\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC : s = new BasicState(); break;\n            case ATNState.RULE_START : s = new RuleStartState(); break;\n            case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START : s = new TokensStartState(); break;\n            case ATNState.RULE_STOP : s = new RuleStopState(); break;\n            case ATNState.BLOCK_END : s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }",
                "static ATNState stateFactory(int type, int ruleIndex) {\n    return new StateFactory(type, ruleIndex).execute();\n}"
            ],
            "classes": [
                "class StateFactory {\n    private int type;\n    private int ruleIndex;\n\n    public StateFactory(int type, int ruleIndex) {\n        this.type = type;\n        this.ruleIndex = ruleIndex;\n    }\n\n    public ATNState execute() {\n        ATNState s;\n        switch (type) {\n            case ATNState.INVALID_TYPE: return null;\n            case ATNState.BASIC : s = new BasicState(); break;\n            case ATNState.RULE_START : s = new RuleStartState(); break;\n            case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;\n            case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;\n            case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;\n            case ATNState.TOKEN_START : s = new TokensStartState(); break;\n            case ATNState.RULE_STOP : s = new RuleStopState(); break;\n            case ATNState.BLOCK_END : s = new BlockEndState(); break;\n            case ATNState.STAR_LOOP_BACK : s = new StarLoopbackState(); break;\n            case ATNState.STAR_LOOP_ENTRY : s = new StarLoopEntryState(); break;\n            case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;\n            case ATNState.LOOP_END : s = new LoopEndState(); break;\n            default :\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Usage\npublic ",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState state = createState(type);\n    if (state == null) {\n        String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n        throw new IllegalArgumentException(message);\n    }\n    state.ruleIndex = ruleIndex;\n    return state;\n}",
                "static ATNState createState(int type) {\n    switch (type) {\n        case ATNState.INVALID_TYPE: return null;\n        case ATNState.BASIC: return new BasicState();\n        case ATNState.RULE_START: return new RuleStartState();\n        case ATNState.BLOCK_START: return new BasicBlockStartState();\n        case ATNState.PLUS_BLOCK_START: return new PlusBlockStartState();\n        case ATNState.STAR_BLOCK_START: return new StarBlockStartState();\n        case ATNState.TOKEN_START: return new TokensStartState();\n        case ATNState.RULE_STOP: return new RuleStopState();\n        case ATNState.BLOCK_END: return new BlockEndState();\n        case ATNState.STAR_LOOP_BACK: return new StarLoopbackState();\n        case ATNState.STAR_LOOP_ENTRY: return new StarLoopEntryState();\n        case ATNState.PLUS_LOOP_BACK: return new PlusLoopbackState();\n        case ATNState.LOOP_END: return new LoopEndState();\n        default: return null;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static ATNState stateFactory(int type, int ruleIndex) {\n    ATNState s = StateFactory.createState(type);\n    s.ruleIndex = ruleIndex;\n    return s;\n}",
                "static ATNState createState(int type) {\n        switch (type) {\n            case ATNState.INVALID_TYPE:\n                return null;\n            case ATNState.BASIC:\n                return new BasicState();\n            case ATNState.RULE_START:\n                return new RuleStartState();\n            case ATNState.BLOCK_START:\n                return new BasicBlockStartState();\n            case ATNState.PLUS_BLOCK_START:\n                return new PlusBlockStartState();\n            case ATNState.STAR_BLOCK_START:\n                return new StarBlockStartState();\n            case ATNState.TOKEN_START:\n                return new TokensStartState();\n            case ATNState.RULE_STOP:\n                return new RuleStopState();\n            case ATNState.BLOCK_END:\n                return new BlockEndState();\n            case ATNState.STAR_LOOP_BACK:\n                return new StarLoopbackState();\n            case ATNState.STAR_LOOP_ENTRY:\n                return new StarLoopEntryState();\n            case ATNState.PLUS_LOOP_BACK:\n                return new PlusLoopbackState();\n            case ATNState.LOOP_END:\n                return new LoopEndState();\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n    }"
            ],
            "classes": [
                "class StateFactory {\n    public static ATNState createState(int type) {\n        switch (type) {\n            case ATNState.INVALID_TYPE:\n                return null;\n            case ATNState.BASIC:\n                return new BasicState();\n            case ATNState.RULE_START:\n                return new RuleStartState();\n            case ATNState.BLOCK_START:\n                return new BasicBlockStartState();\n            case ATNState.PLUS_BLOCK_START:\n                return new PlusBlockStartState();\n            case ATNState.STAR_BLOCK_START:\n                return new StarBlockStartState();\n            case ATNState.TOKEN_START:\n                return new TokensStartState();\n            case ATNState.RULE_STOP:\n                return new RuleStopState();\n            case ATNState.BLOCK_END:\n                return new BlockEndState();\n            case ATNState.STAR_LOOP_BACK:\n                return new StarLoopbackState();\n            case ATNState.STAR_LOOP_ENTRY:\n                return new StarLoopEntryState();\n            case ATNState.PLUS_LOOP_BACK:\n                return new PlusLoopbackState();\n            case ATNState.LOOP_END:\n                return new LoopEndState();\n            default:\n                String message = String.format(Locale.getDefault(), \"The specified state type %d is not valid.\", type);\n                throw new IllegalArgumentException(message);\n        }\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L2083": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\tATNState target = atn.states.get(trg);\n\t\tswitch (type) {\n\t\t\tcase Transition.EPSILON : return new EpsilonTransition(target);\n\t\t\tcase Transition.RANGE :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase Transition.RULE :\n\t\t\t\tRuleTransition rt = new RuleTransition((RuleStartState)atn.states.get(arg1), arg2, target);\n\t\t\t\treturn rt;\n\t\t\tcase Transition.PREDICATE :\n\t\t\t\tPredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn pt;\n\t\t\tcase Transition.ATOM :\n\t\t\t\tif (arg3 != 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase Transition.ACTION :\n\t\t\t\tActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n\t\t\t\treturn a;\n\t\t\tcase Transition.SET : return new SetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.NOT_SET : return new NotSetTransition(target, sets.get(arg1));\n\t\t\tcase Transition.WILDCARD : return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\"The specified transition type is not valid.\");\n\t}",
        "AfterRefact": "public static Transition edgeFactory(@NotNull ATN atn,\n\t\t\t\t\t\t\t\t\t\t int type, int src, int trg,\n\t\t\t\t\t\t\t\t\t\t int arg1, int arg2, int arg3,\n\t\t\t\t\t\t\t\t\t\t List<IntervalSet> sets)\n\t{\n\t\treturn new ATNDeserializer().edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n                                     int type, int src, int trg,\n                                     int arg1, int arg2, int arg3,\n                                     List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    Transition transition;\n\n    switch (type) {\n        case Transition.EPSILON:\n            transition = new EpsilonTransition(target);\n            break;\n        case Transition.RANGE:\n            transition = (arg3 != 0) ? new RangeTransition(target, Token.EOF, arg2) :\n                new RangeTransition(target, arg1, arg2);\n            break;\n        case Transition.RULE:\n            transition = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n            break;\n        case Transition.PREDICATE:\n            transition = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.ATOM:\n            transition = (arg3 != 0) ? new AtomTransition(target, Token.EOF) :\n                new AtomTransition(target, arg1);\n            break;\n        case Transition.ACTION:\n            transition = new ActionTransition(target, arg1, arg2, arg3 != 0);\n            break;\n        case Transition.SET:\n            transition = new SetTransition(target, sets.get(arg1));\n            break;\n        case Transition.NOT_SET:\n            transition = new NotSetTransition(target, sets.get(arg1));\n            break;\n        case Transition.WILDCARD:\n            transition = new WildcardTransition(target);\n            break;\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n\n    return transition;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }",
                "static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    return new EdgeFactoryCommand(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n}"
            ],
            "classes": [
                "class EdgeFactoryCommand {\n    private final ATN atn;\n    private final int type;\n    private final int src;\n    private final int trg;\n    private final int arg1;\n    private final int arg2;\n    private final int arg3;\n    private final List<IntervalSet> sets;\n\n    public EdgeFactoryCommand(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Original forwarding function\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    return new EdgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets).execute();\n}",
                "public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }"
            ],
            "classes": [
                "class EdgeFactory {\n    private ATN atn;\n    private int type;\n    private int src;\n    private int trg;\n    private int arg1;\n    private int arg2;\n    private int arg3;\n    private List<IntervalSet> sets;\n\n    public EdgeFactory(@NotNull ATN atn, int type, int src, int trg, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n        this.atn = atn;\n        this.type = type;\n        this.src = src;\n        this.trg = trg;\n        this.arg1 = arg1;\n        this.arg2 = arg2;\n        this.arg3 = arg3;\n        this.sets = sets;\n    }\n\n    public Transition execute() {\n        ATNState target = atn.states.get(trg);\n        switch (type) {\n            case Transition.EPSILON: return new EpsilonTransition(target);\n            case Transition.RANGE:\n                if (arg3 != 0) {\n                    return new RangeTransition(target, Token.EOF, arg2);\n                } else {\n                    return new RangeTransition(target, arg1, arg2);\n                }\n            case Transition.RULE:\n                RuleTransition rt = new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n                return rt;\n            case Transition.PREDICATE:\n                PredicateTransition pt = new PredicateTransition(target, arg1, arg2, arg3 != 0);\n                return pt;\n            case Transition.ATOM:\n                if (arg3 != 0) {\n                    return new AtomTransition(target, Token.EOF);\n                } else {\n                    return new AtomTransition(target, arg1);\n                }\n            case Transition.ACTION:\n                ActionTransition a = new ActionTransition(target, arg1, arg2, arg3 != 0);\n                return a;\n            case Transition.SET: return new SetTransition(target, sets.get(arg1));\n            case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n            case Transition.WILDCARD: return new WildcardTransition(target);\n        }\n        throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn, int type, int src, int trg, \n                                      int arg1, int arg2, int arg3, \n                                      List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    \n    switch (type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 != 0 ? new RangeTransition(target, Token.EOF, arg2) \n                             : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.ATOM:\n            return arg3 != 0 ? new AtomTransition(target, Token.EOF) \n                             : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.SET:\n            return new SetTransition(target, sets.get(arg1));\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets.get(arg1));\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static Transition edgeFactory(@NotNull ATN atn,\n                                      int type, int src, int trg,\n                                      int arg1, int arg2, int arg3,\n                                      List<IntervalSet> sets) {\n    ATNState target = atn.states.get(trg);\n    Transition transition = createTransition(type, target, arg1, arg2, arg3, sets);\n    if (transition != null) {\n        return transition;\n    }\n    throw new IllegalArgumentException(\"The specified transition type is not valid.\");\n}",
                "static Transition createTransition(int type, ATNState target, int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n    switch (type) {\n        case Transition.EPSILON: return new EpsilonTransition(target);\n        case Transition.RANGE:\n            if (arg3 != 0) {\n                return new RangeTransition(target, Token.EOF, arg2);\n            } else {\n                return new RangeTransition(target, arg1, arg2);\n            }\n        case Transition.RULE:\n            return new RuleTransition((RuleStartState) atn.states.get(arg1), arg2, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.ATOM:\n            if (arg3 != 0) {\n                return new AtomTransition(target, Token.EOF);\n            } else {\n                return new AtomTransition(target, arg1);\n            }\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 != 0);\n        case Transition.SET: return new SetTransition(target, sets.get(arg1));\n        case Transition.NOT_SET: return new NotSetTransition(target, sets.get(arg1));\n        case Transition.WILDCARD: return new WildcardTransition(target);\n        default: return null;\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        }
    },
    "L2079": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\tlong leastSigBits = toLong(data, offset);\n\t\tlong mostSigBits = toLong(data, offset + 4);\n\t\treturn new UUID(mostSigBits, leastSigBits);\n\t}",
        "AfterRefact": "public static UUID toUUID(char[] data, int offset) {\n\t\treturn ATNDeserializer.toUUID(data, offset);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    return new UUID(toLong(data, offset + 4), toLong(data, offset));\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }",
                "private long toLong(char[] data, int offset) {\n        // Implementation of toLong...\n    }",
                "static UUID toUUID(char[] data, int offset) {\n    return new UUIDConverter(data, offset).execute();\n}"
            ],
            "classes": [
                "class UUIDConverter {\n    private char[] data;\n    private int offset;\n\n    public UUIDConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public UUID execute() {\n        long leastSigBits = toLong(data, offset);\n        long mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implementation of toLong...\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Original function kept for forwarding\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n        return new UUIDConverter(data, offset).execute();\n    }",
                "private UUID execute() {\n        this.leastSigBits = toLong(data, offset);\n        this.mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }",
                "private long toLong(char[] data, int offset) {\n        // Implementation of toLong method as needed\n    }"
            ],
            "classes": [
                "class UUIDConverter {\n    private char[] data;\n    private int offset;\n    private long leastSigBits;\n    private long mostSigBits;\n\n    public static UUID toUUID(char[] data, int offset) {\n        return new UUIDConverter(data, offset).execute();\n    }\n\n    private UUIDConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    private UUID execute() {\n        this.leastSigBits = toLong(data, offset);\n        this.mostSigBits = toLong(data, offset + 4);\n        return new UUID(mostSigBits, leastSigBits);\n    }\n\n    private long toLong(char[] data, int offset) {\n        // Implementation of toLong method as needed\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    long leastSigBits = toLong(data, offset);\n    long mostSigBits = toLong(data, offset + 4);\n    return new UUID(mostSigBits, leastSigBits);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static UUID toUUID(char[] data, int offset) {\n    long leastSigBits = new ToLongMethod().execute(data, offset);\n    long mostSigBits = new ToLongMethod().execute(data, offset + 4);\n    return new UUID(mostSigBits, leastSigBits);\n}",
                "public long execute(char[] data, int offset) {\n        // method body for converting char[] to long\n    }"
            ],
            "classes": [
                "class ToLongMethod {\n    public long execute(char[] data, int offset) {\n        // method body for converting char[] to long\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L2075": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static long toLong(char[] data, int offset) {\n\t\tlong lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n\t\treturn lowOrder | ((long)toInt32(data, offset + 2) << 32);\n\t}",
        "AfterRefact": "public static long toLong(char[] data, int offset) {\n\t\treturn ATNDeserializer.toLong(data, offset);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    return ((long) toInt32(data, offset + 2) << 32) | (toInt32(data, offset) & 0x00000000FFFFFFFFL);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long)toInt32(data, offset + 2) << 32);\n    }",
                "private int toInt32(char[] data, int offset) {\n        // Assume implementation of toInt32 is defined here\n        return 0; // Placeholder\n    }",
                "static long toLong(char[] data, int offset) {\n    return new ToLongCommand(data, offset).execute();\n}"
            ],
            "classes": [
                "class ToLongCommand {\n    private char[] data;\n    private int offset;\n\n    public ToLongCommand(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long execute() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long)toInt32(data, offset + 2) << 32);\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Assume implementation of toInt32 is defined here\n        return 0; // Placeholder\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Forwarding function\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public long execute() {\n        this.result = 0;\n        this.lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        this.result |= this.lowOrder | ((long) toInt32(data, offset + 2) << 32);\n        return this.result;\n    }",
                "private int toInt32(char[] data, int offset) {\n        // Implementation of toInt32 would go here\n        return 0; // Placeholder return value\n    }"
            ],
            "classes": [
                "class LongConverter {\n    private char[] data;\n    private int offset;\n    private long result;\n    private int lowOrder;\n\n    public LongConverter(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long execute() {\n        this.result = 0;\n        this.lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        this.result |= this.lowOrder | ((long) toInt32(data, offset + 2) << 32);\n        return this.result;\n    }\n\n    private int toInt32(char[] data, int offset) {\n        // Implementation of toInt32 would go here\n        return 0; // Placeholder return value\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    int lowerPart = toInt32(data, offset) & 0xFFFFFFFF;\n    int upperPart = toInt32(data, offset + 2);\n    return ((long) upperPart << 32) | lowerPart;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static long toLong(char[] data, int offset) {\n    return new ToLongCalculator(data, offset).calculate();\n}",
                "public long calculate() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }"
            ],
            "classes": [
                "class ToLongCalculator {\n    private char[] data;\n    private int offset;\n\n    public ToLongCalculator(char[] data, int offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n\n    public long calculate() {\n        long lowOrder = toInt32(data, offset) & 0x00000000FFFFFFFFL;\n        return lowOrder | ((long) toInt32(data, offset + 2) << 32);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\nprivate static ",
                "\n```"
            ]
        }
    },
    "L1276": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\t// share same graph if both same\n\t\tif ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "AfterRefact": "public static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n\t{\n\t\tassert a!=null && b!=null; // must be empty context, never null\n\n\t\t// share same graph if both same\n\t\tif ( a==b || a.equals(b) ) return a;\n\n\t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\t\treturn mergeSingletons((SingletonPredictionContext)a,\n\t\t\t\t\t\t\t\t   (SingletonPredictionContext)b,\n\t\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t\t}\n\n\t\t// At least one of a or b is array\n\t\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\t\tif ( rootIsWildcard ) {\n\t\t\tif ( a instanceof EmptyPredictionContext ) return a;\n\t\t\tif ( b instanceof EmptyPredictionContext ) return b;\n\t\t}\n\n\t\t// convert singleton so both are arrays to normalize\n\t\tif ( a instanceof SingletonPredictionContext ) {\n\t\t\ta = new ArrayPredictionContext((SingletonPredictionContext)a);\n\t\t}\n\t\tif ( b instanceof SingletonPredictionContext) {\n\t\t\tb = new ArrayPredictionContext((SingletonPredictionContext)b);\n\t\t}\n\t\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static PredictionContext merge(\n    PredictionContext a, PredictionContext b,\n    boolean rootIsWildcard,\n    DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    \n    if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons((SingletonPredictionContext) a,\n                               (SingletonPredictionContext) b,\n                               rootIsWildcard, mergeCache);\n    }\n\n    if (rootIsWildcard) {\n        if (a instanceof EmptyPredictionContext) return a;\n        if (b instanceof EmptyPredictionContext) return b;\n    }\n\n    a = convertToArrayIfNeeded(a);\n    b = convertToArrayIfNeeded(b);\n    \n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n                       rootIsWildcard, mergeCache);\n}",
                "static PredictionContext convertToArrayIfNeeded(PredictionContext context) {\n    if (context instanceof SingletonPredictionContext) {\n        return new ArrayPredictionContext((SingletonPredictionContext) context);\n    }\n    return context;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }",
                "static PredictionContext merge(\n        PredictionContext a,\n        PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    return new MergePredictionContextCommand(a, b, rootIsWildcard, mergeCache).execute();\n}"
            ],
            "classes": [
                "class MergePredictionContextCommand {\n    private final PredictionContext a;\n    private final PredictionContext b;\n    private final boolean rootIsWildcard;\n    private final DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n\n    public MergePredictionContextCommand(PredictionContext a, PredictionContext b, boolean rootIsWildcard,\n                                          DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Forwarding function\npublic ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static PredictionContext merge(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n    return new Merger(a, b, rootIsWildcard, mergeCache).execute();\n}",
                "public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }"
            ],
            "classes": [
                "class Merger {\n    private PredictionContext a;\n    private PredictionContext b;\n    private boolean rootIsWildcard;\n    private DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache;\n    private PredictionContext result;\n\n    public Merger(PredictionContext a, PredictionContext b, boolean rootIsWildcard, DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n        this.a = a;\n        this.b = b;\n        this.rootIsWildcard = rootIsWildcard;\n        this.mergeCache = mergeCache;\n    }\n\n    public PredictionContext execute() {\n        // share same graph if both same\n        if ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n        if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n            return mergeSingletons((SingletonPredictionContext) a, (SingletonPredictionContext) b, rootIsWildcard, mergeCache);\n        }\n\n        // At least one of a or b is array\n        // If one is $ and rootIsWildcard, return $ as * wildcard\n        if (rootIsWildcard) {\n            if (a instanceof EmptyPredictionContext) return a;\n            if (b instanceof EmptyPredictionContext) return b;\n        }\n\n        // convert singleton so both are arrays to normalize\n        if (a instanceof SingletonPredictionContext) {\n            a = new ArrayPredictionContext((SingletonPredictionContext) a);\n        }\n        if (b instanceof SingletonPredictionContext) {\n            b = new ArrayPredictionContext((SingletonPredictionContext) b);\n        }\n\n        return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b, rootIsWildcard, mergeCache);\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static PredictionContext merge(\n        PredictionContext a, PredictionContext b,\n        boolean rootIsWildcard,\n        DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\n    if (areContextsEqual(a, b)) {\n        return a;\n    }\n\n    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n        return mergeSingletons(\n                (SingletonPredictionContext) a,\n                (SingletonPredictionContext) b,\n                rootIsWildcard, \n                mergeCache\n        );\n    }\n\n    if (rootIsWildcard && (isEmptyContext(a) || isEmptyContext(b))) {\n        return a != null ? a : b;\n    }\n\n    a = convertToArrayIfSingleton(a);\n    b = convertToArrayIfSingleton(b);\n\n    return mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n            rootIsWildcard, mergeCache);\n}",
                "static boolean areContextsEqual(PredictionContext a, PredictionContext b) {\n    return (a == null && b == null) || a == b || (a != null && a.equals(b));\n}",
                "static boolean isEmptyContext(PredictionContext context) {\n    return context instanceof EmptyPredictionContext;\n}",
                "static PredictionContext convertToArrayIfSingleton(PredictionContext context) {\n    return context instanceof SingletonPredictionContext\n            ? new ArrayPredictionContext((SingletonPredictionContext) context)\n            : context;\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n\nprivate ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static PredictionContext merge(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\treturn mergeContext(a, b, rootIsWildcard, mergeCache);\n}",
                "static PredictionContext mergeContext(\n\t\tPredictionContext a, PredictionContext b,\n\t\tboolean rootIsWildcard,\n\t\tDoubleKeyMap<PredictionContext, PredictionContext, PredictionContext> mergeCache) {\n\t// share same graph if both same\n\tif ((a == null && b == null) || a == b || (a != null && a.equals(b))) return a;\n\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons((SingletonPredictionContext) a,\n\t\t\t\t\t\t\t   (SingletonPredictionContext) b,\n\t\t\t\t\t\t\t   rootIsWildcard, mergeCache);\n\t}\n\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as * wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) return a;\n\t\tif (b instanceof EmptyPredictionContext) return b;\n\t}\n\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext((SingletonPredictionContext) a);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext((SingletonPredictionContext) b);\n\t}\n\treturn mergeArrays((ArrayPredictionContext) a, (ArrayPredictionContext) b,\n\t\t\t\t\t   rootIsWildcard, mergeCache);\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic ",
                "\n\nprivate ",
                "\n```"
            ]
        }
    },
    "L7856": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n        boolean useIdentity = true; // compare node identity\n\t\tthis.treeLayout =\n\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(tree),\n\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n                                 useIdentity);\n\t\tupdatePreferredSize();\n\t\tsetFont(font);\n\t}",
        "AfterRefact": "public TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n\t\tsetRuleNames(ruleNames);\n\t\tif ( tree!=null ) {\n\t\t\tsetTree(tree);\n\t\t}\n\t\tsetFont(font);\n\t}\n\npublic void setTree(Tree root) {\n\t\tif ( root!=null ) {\n\t\t\tboolean useIdentity = true; // compare node identity\n\t\t\tthis.treeLayout =\n\t\t\t\tnew TreeLayout<Tree>(new TreeLayoutAdaptor(root),\n\t\t\t\t\t\t\t\t\t new TreeViewer.VariableExtentProvide(this),\n\t\t\t\t\t\t\t\t\t new DefaultConfiguration<Tree>(gapBetweenLevels,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgapBetweenNodes),\n\t\t\t\t\t\t\t\t\t useIdentity);\n\t\t\t// Let the UI display this new AST.\n\t\t\tupdatePreferredSize();\n\t\t}\n\t\telse {\n\t\t\tthis.treeLayout = null;\n\t\t\trepaint();\n\t\t}\n\t}\npublic void setRuleNames(List<String> ruleNames) {\n\t\tsetTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n\t}",
        "ZeroShotCode": {
            "methods": [
                "private DefaultTreeTextProvider createTreeTextProvider(@Nullable List<String> ruleNames) {\n    return new DefaultTreeTextProvider(ruleNames);\n}",
                "private TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(createTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "private void initializeTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    initializeTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    return new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    this.treeLayout = createTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private TreeLayout<Tree> createTreeLayout(Tree tree, boolean useIdentity) {\n    return new TreeLayout<>(\n        new TreeLayoutAdaptor(tree),\n        new VariableExtentProvider(),\n        new DefaultConfiguration<>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    \n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = createTreeLayout(tree, useIdentity);\n    \n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "private void initializeTreeLayout(Tree tree) {\n    boolean useIdentity = true; // compare node identity\n    this.treeLayout = new TreeLayout<Tree>(\n        new TreeLayoutAdaptor(tree),\n        new TreeViewer.VariableExtentProvide(this),\n        new DefaultConfiguration<Tree>(gapBetweenLevels, gapBetweenNodes),\n        useIdentity\n    );\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TreeViewer(@Nullable List<String> ruleNames, Tree tree) {\n    setTreeTextProvider(new DefaultTreeTextProvider(ruleNames));\n    initializeTreeLayout(tree);\n    updatePreferredSize();\n    setFont(font);\n}\n\n",
                "\n```"
            ]
        }
    },
    "L3524": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tsuper(ruleStart);\n\n\t\tthis.ruleIndex = ruleIndex;\n\n\t\tthis.followState = followState;\n\n\t}",
        "AfterRefact": "public RuleTransition(@NotNull RuleStartState ruleStart,\n\n\t\t\t\t\t\t  int ruleIndex,\n\n\t\t\t\t\t\t  @NotNull ATNState followState)\n\n\t{\n\n\t\tthis(ruleStart, ruleIndex, 0, followState);\n\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public RuleStartState getRuleStart() {\n        return ruleStart;\n    }",
                "public int getRuleIndex() {\n        return ruleIndex;\n    }",
                "public ATNState getFollowState() {\n        return followState;\n    }"
            ],
            "classes": [
                "class RuleTransition {\n    private RuleStartState ruleStart;\n    private int ruleIndex;\n    private ATNState followState;\n\n    public RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n        super(ruleStart);\n        this.ruleStart = ruleStart;\n        this.ruleIndex = ruleIndex;\n        this.followState = followState;\n    }\n\n    public RuleStartState getRuleStart() {\n        return ruleStart;\n    }\n\n    public int getRuleIndex() {\n        return ruleIndex;\n    }\n\n    public ATNState getFollowState() {\n        return followState;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n\n                      int initialRuleIndex,\n\n                      @NotNull ATNState followState)\n\n{\n    super(ruleStart);\n    this.ruleIndex = initialRuleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart, int ruleIndex, @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic RuleTransition(@NotNull RuleStartState ruleStart,\n                      int ruleIndex,\n                      @NotNull ATNState followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.followState = followState;\n}\n```"
            ]
        }
    },
    "L2447": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n\n    if (isValidAction(actionIndex)) {\n        executeAction(ruleIndex, actionIndex);\n    }\n\n    updateInputPosition(input, index, line, charPos);\n}",
                "private void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n}",
                "private boolean isValidAction(int actionIndex) {\n    return actionIndex >= 0 && recog != null;\n}",
                "private void executeAction(int ruleIndex, int actionIndex) {\n    recog.action(null, ruleIndex, actionIndex);\n}",
                "private void updateInputPosition(CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    // Existing parameters removed for cleaner declaration\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // Parameters moved to method implementation as needed\n    input.seek(index); // \\'index\\', \\'line\\', and \\'charPos\\' need proper management here.\n    this.line = line;\n    this.charPositionInLine = charPos;\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void acceptInput(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t   int index, int line, int charPos) \n{\n\tif (debug) {\n\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t}\n\n\tif (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n\t// seek to after last char in token\n\tinput.seek(index);\n\tthis.line = line;\n\tthis.charPositionInLine = charPos;\n\tif (input.LA(1) != IntStream.EOF) {\n\t\tconsume(input);\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n    executeActionIfNeeded(ruleIndex, actionIndex);\n    \n    input.seek(index);\n    updatePosition(line, charPos);\n    \n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}",
                "private void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", \n            recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n}",
                "private void executeActionIfNeeded(int ruleIndex, int actionIndex) {\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n}",
                "private void updatePosition(int line, int charPos) {\n    this.line = line;\n    this.charPositionInLine = charPos;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) recog.action(null, ruleIndex, actionIndex);\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L24470": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t  int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t\t}\n\n\t\tif ( actionIndex>=0 && recog!=null ) recog.action(null, ruleIndex, actionIndex);\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\t}",
        "AfterRefact": "protected void accept(@NotNull CharStream input, LexerActionExecutor lexerActionExecutor,\n\t\t\t\t\t\t  int startIndex, int index, int line, int charPos)\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s\\n\", lexerActionExecutor);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis.line = line;\n\t\tthis.charPositionInLine = charPos;\n\t\tif (input.LA(1) != IntStream.EOF) {\n\t\t\tconsume(input);\n\t\t}\n\n\t\tif (lexerActionExecutor != null && recog != null) {\n\t\t\tlexerActionExecutor.execute(recog, input, startIndex);\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = input.getLine();\n    this.charPositionInLine = input.getCharPositionInLine();\n\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void acceptInput(@NotNull CharStream input, int ruleIndex, int actionIndex,\n\t\t\t\t\t\t   int index, int line, int charPos)\n{\n\tif ( debug ) {\n\t\tSystem.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n\t}\n\n\tif ( actionIndex >= 0 && recog != null ) recog.action(null, ruleIndex, actionIndex);\n\n\t// seek to after last char in token\n\tinput.seek(index);\n\tthis.line = line;\n\tthis.charPositionInLine = charPos;\n\tif (input.LA(1) != IntStream.EOF) {\n\t\tconsume(input);\n\t}\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index, int line, int charPos) {\n    logAction(ruleIndex, actionIndex);\n    performAction(ruleIndex, actionIndex);\n\n    updatePosition(input, index, line, charPos);\n}",
                "private void logAction(int ruleIndex, int actionIndex) {\n    if (debug) {\n        String ruleName = recog != null ? recog.getRuleNames()[ruleIndex] : String.valueOf(ruleIndex);\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", ruleName, actionIndex);\n    }\n}",
                "private void performAction(int ruleIndex, int actionIndex) {\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n}",
                "private void updatePosition(CharStream input, int index, int line, int charPos) {\n    input.seek(index);\n    this.line = line;\n    this.charPositionInLine = charPos;\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void accept(@NotNull CharStream input, int ruleIndex, int actionIndex, int index) {\n    if (debug) {\n        System.out.format(Locale.getDefault(), \"ACTION %s:%d\\\n\", recog != null ? recog.getRuleNames()[ruleIndex] : ruleIndex, actionIndex);\n    }\n\n    if (actionIndex >= 0 && recog != null) {\n        recog.action(null, ruleIndex, actionIndex);\n    }\n\n    // seek to after last char in token\n    input.seek(index);\n    if (input.LA(1) != IntStream.EOF) {\n        consume(input);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2288": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t  DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t  @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t  @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t  ParserRuleContext outerContext,\n\t\t\t\t\t\t\t\t\t  int SLL_min_alt) // todo: is this in D as min ambig alts?\n\t{\n\t\t// caller must have write lock on dfa\n\t\tretry_with_context++;\n\t\treportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\tretry_with_context_indicates_no_conflict++;\n\t\t\treportContextSensitivity(dfa, reach, startIndex, input.index());\n\t\t\tif ( predictedAlt == SLL_min_alt ) {\n\t\t\t\tretry_with_context_predicts_same_alt++;\n\t\t\t}\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\tif ( foundExactAmbig ) {\n\t\t\treportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n\t\t}\n\n\t\treturn predictedAlt;\n\t}",
        "AfterRefact": "protected int execATNWithFullContext(DFA dfa,\n\t\t\t\t\t\t\t\t\t\t DFAState D, // how far we got before failing over\n\t\t\t\t\t\t\t\t\t\t @NotNull ATNConfigSet s0,\n\t\t\t\t\t\t\t\t\t\t @NotNull TokenStream input, int startIndex,\n\t\t\t\t\t\t\t\t\t\t ParserRuleContext outerContext)\n\t{\n\t\tif ( debug || debug_list_atn_decisions ) {\n\t\t\tSystem.out.println(\"execATNWithFullContext \"+s0);\n\t\t}\n\t\tboolean fullCtx = true;\n\t\tboolean foundExactAmbig = false;\n\t\tATNConfigSet reach = null;\n\t\tATNConfigSet previous = s0;\n\t\tinput.seek(startIndex);\n\t\tint t = input.LA(1);\n\t\tint predictedAlt;\n\t\twhile (true) { // while more work\n//\t\t\tSystem.out.println(\"LL REACH \"+getLookaheadName(input)+\n//\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n//\t\t\t\t\t\t\t   \" line \"+input.LT(1).getLine()+\":\"+input.LT(1).getCharPositionInLine());\n\t\t\treach = computeReachSet(previous, t, fullCtx);\n\t\t\tif ( reach==null ) {\n\t\t\t\t// if any configs in previous dipped into outer context, that\n\t\t\t\t// means that input up to t actually finished entry rule\n\t\t\t\t// at least for LL decision. Full LL doesn't dip into outer\n\t\t\t\t// so don't need special case.\n\t\t\t\t// We will get an error no matter what so delay until after\n\t\t\t\t// decision; better error message. Also, no reachable target\n\t\t\t\t// ATN states in SLL implies LL will also get nowhere.\n\t\t\t\t// If conflict in states that dip out, choose min since we\n\t\t\t\t// will get error no matter what.\n\t\t\t\tint alt = getAltThatFinishedDecisionEntryRule(previous);\n\t\t\t\tif ( alt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n\t\t\t}\n\n\t\t\tCollection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"LL altSubSets=\"+altSubSets+\n\t\t\t\t\t\t\t\t   \", predict=\"+PredictionMode.getUniqueAlt(altSubSets)+\n\t\t\t\t\t\t\t\t   \", resolvesToJustOneViableAlt=\"+\n\t\t\t\t\t\t\t\t\t   PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n\t\t\t}\n\n//\t\t\tSystem.out.println(\"altSubSets: \"+altSubSets);\n\t\t\treach.uniqueAlt = getUniqueAlt(reach);\n\t\t\t// unique prediction?\n\t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\tpredictedAlt = reach.uniqueAlt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( mode != PredictionMode.LL_EXACT_AMBIG_DETECTION ) {\n\t\t\t\tpredictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\t\t\t\tif ( predictedAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// In exact ambiguity mode, we never try to terminate early.\n\t\t\t\t// Just keeps scarfing until we know what the conflict is\n\t\t\t\tif ( PredictionMode.allSubsetsConflict(altSubSets) &&\n\t\t\t\t\t PredictionMode.allSubsetsEqual(altSubSets) )\n\t\t\t\t{\n\t\t\t\t\tfoundExactAmbig = true;\n\t\t\t\t\tpredictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else there are multiple non-conflicting subsets or\n\t\t\t\t// we're not sure what the ambiguity is yet.\n\t\t\t\t// So, keep going.\n\t\t\t}\n\n\t\t\tprevious = reach;\n\t\t\tif (t != IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\n\t\t// If the configuration set uniquely predicts an alternative,\n\t\t// without conflict, then we know that it's a full LL decision\n\t\t// not SLL.\n\t\tif ( reach.uniqueAlt != ATN.INVALID_ALT_NUMBER ) {\n\t\t\treportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index());\n\t\t\treturn predictedAlt;\n\t\t}\n\n\t\t// We do not check predicates here because we have checked them\n\t\t// on-the-fly when doing full context prediction.\n\n\t\t/*\n\t\tIn non-exact ambiguity detection mode, we might\tactually be able to\n\t\tdetect an exact ambiguity, but I'm not going to spend the cycles\n\t\tneeded to check. We only emit ambiguity warnings in exact ambiguity\n\t\tmode.\n\n\t\tFor example, we might know that we have conflicting configurations.\n\t\tBut, that does not mean that there is no way forward without a\n\t\tconflict. It's possible to have nonconflicting alt subsets as in:\n\n\t\t   LL altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n\t\tfrom\n\n\t\t   [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n\t\t\t(13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n\n\t\tIn this case, (17,1,[5 $]) indicates there is some next sequence that\n\t\twould resolve this without conflict to alternative 1. Any other viable\n\t\tnext sequence, however, is associated with a conflict.  We stop\n\t\tlooking for input because no amount of further lookahead will alter\n\t\tthe fact that we should predict alternative 1.  We just can't say for\n\t\tsure that there is an ambiguity without looking further.\n\t\t*/\n\t\treportAmbiguity(dfa, D, startIndex, input.index(), foundExactAmbig, null, reach);\n\n\t\treturn predictedAlt;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    \n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D, // how far we got before failing over\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, \n                                   int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    // caller must have write lock on dfa\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n\n    while (true) { // while more work\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public int executeFullContextDFA(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) \n{\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"executeFullContextDFA \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) \n            {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa, \n                                   DFAState D, \n                                   @NotNull ATNConfigSet initialConfigSet, \n                                   @NotNull TokenStream input, \n                                   int startIndex, \n                                   ParserRuleContext outerContext, \n                                   int SLLMinAlt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, initialConfigSet, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + initialConfigSet);\n    }\n\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach;\n    ATNConfigSet previous = initialConfigSet;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) && \n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLLMinAlt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public int execATNWithFullContext(DFA dfa,\n                                   DFAState D,\n                                   @NotNull ATNConfigSet s0,\n                                   @NotNull TokenStream input, int startIndex,\n                                   ParserRuleContext outerContext,\n                                   int SLL_min_alt) {\n    retry_with_context++;\n    reportAttemptingFullContext(dfa, s0, startIndex, input.index());\n\n    if (debug || debug_list_atn_decisions) {\n        System.out.println(\"execATNWithFullContext \" + s0);\n    }\n    boolean fullCtx = true;\n    boolean foundExactAmbig = false;\n    ATNConfigSet reach = null;\n    ATNConfigSet previous = s0;\n    input.seek(startIndex);\n    int t = input.LA(1);\n    int predictedAlt;\n    while (true) {\n        reach = computeReachSet(previous, t, fullCtx);\n        if (reach == null) {\n            int alt = getAltThatFinishedDecisionEntryRule(previous);\n            if (alt != ATN.INVALID_ALT_NUMBER) {\n                return alt;\n            }\n            throw noViableAlt(input, outerContext, previous, startIndex);\n        }\n\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n        if (debug) {\n            System.out.println(\"LL altSubSets=\" + altSubSets +\n                               \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) +\n                               \", resolvesToJustOneViableAlt=\" +\n                               PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n        }\n        reach.uniqueAlt = getUniqueAlt(reach);\n        if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n            predictedAlt = reach.uniqueAlt;\n            break;\n        }\n        if (mode != PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n            if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n                break;\n            }\n        } else {\n            if (PredictionMode.allSubsetsConflict(altSubSets) &&\n                PredictionMode.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                break;\n            }\n        }\n\n        previous = reach;\n        if (t != IntStream.EOF) {\n            input.consume();\n            t = input.LA(1);\n        }\n    }\n\n    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n        retry_with_context_indicates_no_conflict++;\n        reportContextSensitivity(dfa, reach, startIndex, input.index());\n        if (predictedAlt == SLL_min_alt) {\n            retry_with_context_predicts_same_alt++;\n        }\n        return predictedAlt;\n    }\n\n    if (foundExactAmbig) {\n        reportAmbiguity(dfa, D, startIndex, input.index(), getConflictingAlts(reach), reach);\n    }\n\n    return predictedAlt;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L2588": {
        "RefactMethod": "REPLACE FUNCTION WITH COMMAND",
        "BeforeRefact": "protected static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n\t\treturn 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n\t}",
        "AfterRefact": "protected static int calculateHashCode(PredictionContext parent, int returnState) {\n\t\tint hash = MurmurHash.initialize(INITIAL_HASH);\n\t\thash = MurmurHash.update(hash, parent);\n\t\thash = MurmurHash.update(hash, returnState);\n\t\thash = MurmurHash.finish(hash, 2);\n\t\treturn hash;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return 175 + 5 * parentHashCode + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }",
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return new CalculateHashCodeCommand(parentHashCode, returnStateHashCode).execute();\n}"
            ],
            "classes": [
                "class CalculateHashCodeCommand {\n    private final int parentHashCode;\n    private final int returnStateHashCode;\n\n    public CalculateHashCodeCommand(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}"
            ],
            "others": [
                "```java\npublic ",
                "\n\n// Forwarding function\nprotected ",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return new HashCodeCalculator(parentHashCode, returnStateHashCode).execute();\n}",
                "public int execute() {\n        result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n        return result;\n    }"
            ],
            "classes": [
                "class HashCodeCalculator {\n    private int parentHashCode;\n    private int returnStateHashCode;\n    private int result;\n\n    public HashCodeCalculator(int parentHashCode, int returnStateHashCode) {\n        this.parentHashCode = parentHashCode;\n        this.returnStateHashCode = returnStateHashCode;\n    }\n\n    public int execute() {\n        result = 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n        return result;\n    }\n}"
            ],
            "others": [
                "```java\nprotected ",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    final int prime1 = 5;\n    final int prime2 = 7;\n    return (prime1 * prime1 * prime2) + (prime1 * parentHashCode) + returnStateHashCode;\n}"
            ],
            "classes": [],
            "others": [
                "```java\nprotected ",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "static int calculateHashCode(int parentHashCode, int returnStateHashCode) {\n    return HashCodeCalculator.calculate(parentHashCode, returnStateHashCode);\n}",
                "static int calculate(int parentHashCode, int returnStateHashCode) {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }"
            ],
            "classes": [
                "class HashCodeCalculator {\n    public static int calculate(int parentHashCode, int returnStateHashCode) {\n        return 5 * 5 * 7 + 5 * parentHashCode + returnStateHashCode;\n    }\n}"
            ],
            "others": [
                "```java\nprotected ",
                "\n```\n\n```java\npublic ",
                "\n```"
            ]
        }
    },
    "L3072": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "AfterRefact": "public void reportContextSensitivity(Parser recognizer,\n\t\t\t\t\t\t\t\t\t\t DFA dfa,\n\t\t\t\t\t\t\t\t\t\t int startIndex,\n\t\t\t\t\t\t\t\t\t\t int stopIndex,\n\t\t\t\t\t\t\t\t\t\t int prediction,\n\t\t\t\t\t\t\t\t\t\t ATNConfigSet configs)\n\t{\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, Interval interval, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer,\n                                      DFA dfa,\n                                      int startIndex,\n                                      int stopIndex,\n                                      ATNConfigSet configurations)\n{\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void reportContextSensitivity(Parser recognizer, int startIndex, ATNConfigSet configs) {\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5418": {
        "RefactMethod": "SPLIT VARIABLE",
        "BeforeRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t\t_ctx.altNum = altNum;\n\t}",
        "AfterRefact": "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif ( _buildParseTrees && _ctx != localctx ) {\n\t\t\tParserRuleContext parent = (ParserRuleContext)_ctx.parent;\n\t\t\tif ( parent!=null )\t{\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\t_ctx = localctx;\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    updateParseTree(localctx);\n    setAltNum(localctx, altNum);\n}",
                "private void updateParseTree(ParserRuleContext localctx) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n}",
                "private void setAltNum(ParserRuleContext localctx, int altNum) {\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    ParserRuleContext updatedCtx = localctx;\n    updatedCtx.altNum = altNum;\n    _ctx = updatedCtx;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    final int newAltNum = altNum;\n    _ctx.altNum = newAltNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    _ctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void enterOuterAlt(ParserRuleContext localctx, int altNum) {\n    // if we have new localctx, make sure we replace existing ctx\n    // that is previous child of parse tree\n    if (_buildParseTrees && _ctx != localctx) {\n        ParserRuleContext parent = (ParserRuleContext) _ctx.parent;\n        if (parent != null) {\n            parent.removeLastChild();\n            parent.addChild(localctx);\n        }\n    }\n    _ctx = localctx;\n    setAltNum(localctx, altNum);\n}",
                "private void setAltNum(ParserRuleContext localctx, int altNum) {\n    localctx.altNum = altNum;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L3446": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "AfterRefact": "protected Token singleTokenDeletion(@NotNull Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\treportMatch(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}\npublic void reportMatch(Parser recognizer) {\n\t\tendErrorCondition(recognizer);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // simply delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        Token matchedSymbol = deleteExtraToken(recognizer);\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private Token deleteExtraToken(Parser recognizer) {\n    recognizer.consume(); // simply delete extra token\n    Token matchedSymbol = recognizer.getCurrentToken();\n    endErrorCondition(recognizer);  // we know current token is correct\n    return matchedSymbol;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        Token matchedSymbol = deleteExtraToken(recognizer);\n        endErrorCondition(recognizer); // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}",
                "private Token deleteExtraToken(Parser recognizer) {\n    recognizer.consume(); // simply delete extra token\n    return recognizer.getCurrentToken();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    \n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // Delete extra token\n        \n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); // Current token is correct\n        return matchedSymbol;\n    }\n    \n    return null;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        handleUnwantedToken(recognizer);\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer); \n        return matchedSymbol;\n    }\n    return null;\n}",
                "private void handleUnwantedToken(Parser recognizer) {\n    reportUnwantedToken(recognizer);\n    recognizer.consume(); // simply delete extra token\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L3949": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public TheoryAnchor(FrameworkMethod method) {\n\t\t\tfTestMethod= method;\n\t\t}",
        "AfterRefact": "public TheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tfTestMethod= method;\n            fTestClass= testClass;\n\t\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod fTestMethod) {\n    this.fTestMethod = fTestMethod;\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod testMethod) {\n    fTestMethod = testMethod;\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod method) {\n    this.fTestMethod = method;\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic TheoryAnchor(FrameworkMethod fTestMethod) {\n    this.fTestMethod = fTestMethod;\n}\n```"
            ]
        }
    },
    "L8052": {
        "RefactMethod": "CHANGE FUNCTION DECLARATION",
        "BeforeRefact": "public StubbedTheoryAnchor(FrameworkMethod method) {\n\t\t\tsuper(method);\n\t\t}",
        "AfterRefact": "public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {\n\t\t\tsuper(method, testClass);\n\t\t}",
        "ZeroShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "InstrucCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, AdditionalParameterType additionalParameter) {\n    super(method, additionalParameter);\n}\n```"
            ]
        },
        "FewShotCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod frameworkMethod) {\n    super(frameworkMethod);\n}\n```"
            ]
        },
        "ContextCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method) {\n    super(method);\n}\n```"
            ]
        },
        "RulesCode": {
            "methods": [],
            "classes": [],
            "others": [
                "```java\npublic StubbedTheoryAnchor(FrameworkMethod method, Object addedParam) {\n    super(method);\n}\n```"
            ]
        }
    },
    "L4884": {
        "RefactMethod": "INLINE VARIABLE",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(each);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable each : ((MultipleFailureException) targetException).getFailures())\n            addFailure(each);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L5882": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeMethodBlock(method, eachNotifier);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}",
                "private void executeMethodBlock(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    runTest(method, eachNotifier);\n}",
                "private void runTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeTestMethod(method);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private void executeTestMethod(FrameworkMethod method) throws Throwable {\n    methodBlock(method).evaluate();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L5880": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
        "AfterRefact": "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\n\tprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\n\n\tprivate void runIgnored(EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestIgnored();\n\t}",
        "ZeroShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        executeMethodBlock(method, eachNotifier);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}",
                "private void executeMethodBlock(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (isIgnored(method, eachNotifier)) {\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return true;\n    }\n    return false;\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    \n    if (isIgnored(method)) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    eachNotifier.fireTestStarted();\n    try {\n        evaluateMethodBlock(method);\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}",
                "private boolean isIgnored(FrameworkMethod method) {\n    return method.getAnnotation(Ignore.class) != null;\n}",
                "private void evaluateMethodBlock(FrameworkMethod method) throws Throwable {\n    methodBlock(method).evaluate();\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "protected void runChild(FrameworkMethod method, RunNotifier notifier) {\n    EachTestNotifier eachNotifier = makeNotifier(method, notifier);\n    if (method.getAnnotation(Ignore.class) != null) {\n        eachNotifier.fireTestIgnored();\n        return;\n    }\n\n    executeTest(method, eachNotifier);\n}",
                "private void executeTest(FrameworkMethod method, EachTestNotifier eachNotifier) {\n    eachNotifier.fireTestStarted();\n    try {\n        methodBlock(method).evaluate();\n    } catch (AssumptionViolatedException e) {\n        eachNotifier.addFailedAssumption(e);\n    } catch (Throwable e) {\n        eachNotifier.addFailure(e);\n    } finally {\n        eachNotifier.fireTestFinished();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L4889": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
        "AfterRefact": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}\n\n\tprivate void addMultipleFailureException(MultipleFailureException mfe) {\n\t\tfor (Throwable each : mfe.getFailures())\n\t\t\taddFailure(each);\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n    } else {\n        fireTestFailure(targetException);\n    }\n}",
                "private void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}",
                "private void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}",
                "private void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailureException((MultipleFailureException) targetException);\n        return;\n    }\n    fireTestFailure(targetException);\n}",
                "private void handleMultipleFailureException(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}",
                "private void fireTestFailure(Throwable targetException) {\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        for (Throwable failure : ((MultipleFailureException) targetException).getFailures()) {\n            addFailure(failure);\n        }\n    } else {\n        fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void addFailure(Throwable targetException) {\n    if (targetException instanceof MultipleFailureException) {\n        handleMultipleFailures((MultipleFailureException) targetException);\n        return;\n    }\n    fNotifier.fireTestFailure(new Failure(fDescription, targetException));\n}",
                "private void handleMultipleFailures(MultipleFailureException mfe) {\n    for (Throwable each : mfe.getFailures()) {\n        addFailure(each);\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n\n",
                "\n```"
            ]
        }
    },
    "L7126": {
        "RefactMethod": "INTRODUCE ASSERTION",
        "BeforeRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t}",
        "AfterRefact": "public void testCountWithExplicitFilter() throws Throwable {\n\t\tCategoryFilter include= CategoryFilter.include(SlowTests.class);\n\t\tRequest baseRequest= Request.aClass(TestSuiteWithNoCategories.class);\n\t\tResult result= new JUnitCore().run(baseRequest.filterWith(include));\n\t\tassertTrue(result.wasSuccessful());\n\t\tassertEquals(2, result.getRunCount());\n\t}",
        "ZeroShotCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertThat(result.wasSuccessful(), is(true));\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    // Adding assertion to ensure that the include filter is not null\n    assert include != null : \"The include filter should not be null\";\n\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    \n    assert(include != null); // Assertion for include filter must not be null\n\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public void testCountWithExplicitFilter() throws Throwable {\n    CategoryFilter include = CategoryFilter.include(SlowTests.class);\n    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);\n    Result result = new JUnitCore().run(baseRequest.filterWith(include));\n    assertTrue(result.wasSuccessful());\n    assertNotNull(result); // Introduced assertion\n}"
            ],
            "classes": [],
            "others": [
                "```java\n",
                "\n```"
            ]
        }
    },
    "L126": {
        "RefactMethod": "EXTRACT FUNCTION",
        "BeforeRefact": "public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
        "AfterRefact": "public TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}\n\n\tprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}\n\t",
        "ZeroShotCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void validateTestConstructor(Class<? extends TestCase> theClass) throws NoSuchMethodException {\n    getTestConstructor(theClass); // Avoid generating multiple error messages\n}",
                "private void extractTestMethods(Class<?> superClass, List<String> names) {\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, superClass);\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        validateTestConstructor(theClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    List<String> names = new ArrayList<String>();\n    extractTestMethods(theClass, names);\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}\n\n",
                "\n\n",
                "\n```"
            ]
        },
        "InstrucCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void extractTestMethodNames(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractTestMethodNames(theClass);\n}\n\n",
                "\n```"
            ]
        },
        "FewShotCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void processTestClass(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    \n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods()) {\n            addTestMethod(each, names, theClass);\n        }\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    processTestClass(theClass);\n    if (fTests.size() == 0) {\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n    }\n}\n\n",
                "\n```"
            ]
        },
        "ContextCode": {
            "methods": [
                "private boolean isValidTestClass(Class<? extends TestCase> testClass) {\n    try {\n        getTestConstructor(testClass);\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + testClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n\n    if (!Modifier.isPublic(testClass.getModifiers())) {\n        addTest(warning(\"Class \" + testClass.getName() + \" is not public\"));\n        return false;\n    }\n\n    return true;\n}",
                "public constructor TestCase(String name) or TestCase()\"));\n        return false;\n    }\n\n    if (!Modifier.isPublic(testClass.getModifiers())) {"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> testClass) {\n    fName = testClass.getName();\n    \n    if (!isValidTestClass(testClass)) {\n        return;\n    }\n\n    List<String> testNames = new ArrayList<>();\n    Class<?> currentClass = testClass;\n\n    while (Test.class.isAssignableFrom(currentClass)) {\n        for (Method method : currentClass.getDeclaredMethods()) {\n            addTestMethod(method, testNames, testClass);\n        }\n        currentClass = currentClass.getSuperclass();\n    }\n\n    if (fTests.isEmpty()) {\n        addTest(warning(\"No tests found in \" + testClass.getName()));\n    }\n}\n\n",
                "\n```"
            ]
        },
        "RulesCode": {
            "methods": [
                "public constructor TestCase(String name) or TestCase()\"));\n        return;\n    }\n\n    if (!Modifier.isPublic(theClass.getModifiers())) {",
                "private void extractTestMethods(Class<?> theClass) {\n    Class<?> superClass = theClass;\n    List<String> names = new ArrayList<String>();\n    while (Test.class.isAssignableFrom(superClass)) {\n        for (Method each : superClass.getDeclaredMethods())\n            addTestMethod(each, names, theClass);\n        superClass = superClass.getSuperclass();\n    }\n}"
            ],
            "classes": [],
            "others": [
                "```java\npublic TestSuite(final Class<? extends TestCase> theClass) {\n    fName = theClass.getName();\n    try {\n        getTestConstructor(theClass); // Avoid generating multiple error messages\n    } catch (NoSuchMethodException e) {\n        addTest(warning(\"Class \" + theClass.getName() + \" has no ",
                "\n        addTest(warning(\"Class \" + theClass.getName() + \" is not public\"));\n        return;\n    }\n\n    extractTestMethods(theClass);\n    if (fTests.size() == 0)\n        addTest(warning(\"No tests found in \" + theClass.getName()));\n}\n\n",
                "\n```"
            ]
        }
    }
}