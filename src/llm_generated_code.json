{
    "EXTRACT VARIABLE": {
        "ID": "L10937",
        "BeforeRefact": "\n\tpublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "ZeroShotCode": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\tMatchSet matchOp;\n\tif (invert) matchOp = new MatchNotSet(this, setAST);\n\telse matchOp = new MatchSet(this, setAST);\n\tif (labelAST != null) {\n\t\tString label = labelAST.getText();\n\t\tDecl d = getTokenLabelDecl(label);\n\t\tmatchOp.labels.add(d);\n\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\tif (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t}\n\t}\n\tif (controller.needsImplicitLabel(setAST, matchOp)) defineImplicitLabel(setAST, matchOp);\n\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\treturn list(matchOp, listLabelOp);\n}",
        "InstrucCode": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\tMatchSet matchOp;\n\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\telse matchOp = new MatchSet(this, setAST);\n\tif ( labelAST!=null ) {\n\t\tString label = labelAST.getText();\n\t\tDecl d = getTokenLabelDecl(label);\n\t\tmatchOp.labels.add(d);\n\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t}\n\t}\n\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\treturn list(matchOp, listLabelOp);\n}",
        "FewShotCode": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif (invert) {\n\t\t\tmatchOp = new MatchNotSet(this, setAST);\n\t\t} else {\n\t\t\tmatchOp = new MatchSet(this, setAST);\n\t\t}\n\t\tif (labelAST != null) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif (controller.needsImplicitLabel(setAST, matchOp)) {\n\t\t\tdefineImplicitLabel(setAST, matchOp);\n\t\t}\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}"
    },
    "INTRODUCE ASSERTION": {
        "ID": "L7413",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t}\n\t}",
        "InstrucCode": "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n    for (DecisionState s : g.atn.decisionToState) {\n        assert s != null : \"DecisionState must not be null\";\n\n        g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions()+1];\n        }\n        else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision+1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}\n",
        "FewShotCode": "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions()+1];\n        }\n        else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision+1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
    },
    "EXTRACT FUNCTION": {
        "ID": "L3446",
        "BeforeRefact": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "ZeroShotCode": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "InstrucCode": "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        getTokenToDelete(recognizer);\n        recognizer.consume(); \n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  \n        return matchedSymbol;\n    }\n    return null;\n}\n\n",
        "FewShotCode": "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // simply delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}"
    }
}