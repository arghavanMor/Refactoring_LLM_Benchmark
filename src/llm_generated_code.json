{
    "EXTRACT VARIABLE": {
        "ID": "L10937",
        "BeforeRefact": "\n\tpublic List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\t\telse matchOp = new MatchSet(this, setAST);\n\t\tif ( labelAST!=null ) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}",
        "ZeroShotCode": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\tMatchSet matchOp;\n\tif (invert) matchOp = new MatchNotSet(this, setAST);\n\telse matchOp = new MatchSet(this, setAST);\n\tif (labelAST != null) {\n\t\tString label = labelAST.getText();\n\t\tDecl d = getTokenLabelDecl(label);\n\t\tmatchOp.labels.add(d);\n\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\tif (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t}\n\t}\n\tif (controller.needsImplicitLabel(setAST, matchOp)) defineImplicitLabel(setAST, matchOp);\n\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\treturn list(matchOp, listLabelOp);\n}",
        "InstrucCode": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\tMatchSet matchOp;\n\tif ( invert ) matchOp = new MatchNotSet(this, setAST);\n\telse matchOp = new MatchSet(this, setAST);\n\tif ( labelAST!=null ) {\n\t\tString label = labelAST.getText();\n\t\tDecl d = getTokenLabelDecl(label);\n\t\tmatchOp.labels.add(d);\n\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\tif ( labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN ) {\n\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t}\n\t}\n\tif ( controller.needsImplicitLabel(setAST, matchOp) ) defineImplicitLabel(setAST, matchOp);\n\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\treturn list(matchOp, listLabelOp);\n}",
        "FewShotCode": "public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {\n\t\tMatchSet matchOp;\n\t\tif (invert) {\n\t\t\tmatchOp = new MatchNotSet(this, setAST);\n\t\t} else {\n\t\t\tmatchOp = new MatchSet(this, setAST);\n\t\t}\n\t\tif (labelAST != null) {\n\t\t\tString label = labelAST.getText();\n\t\t\tDecl d = getTokenLabelDecl(label);\n\t\t\tmatchOp.labels.add(d);\n\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), d);\n\t\t\tif (labelAST.parent.getType() == ANTLRParser.PLUS_ASSIGN) {\n\t\t\t\tTokenListDecl l = getTokenListLabelDecl(label);\n\t\t\t\tgetCurrentRuleFunction().addContextDecl(setAST.getAltLabel(), l);\n\t\t\t}\n\t\t}\n\t\tif (controller.needsImplicitLabel(setAST, matchOp)) {\n\t\t\tdefineImplicitLabel(setAST, matchOp);\n\t\t}\n\t\tAddToLabelList listLabelOp = getAddToListOpIfListLabelPresent(matchOp, labelAST);\n\t\treturn list(matchOp, listLabelOp);\n\t}"
    },
    "INTRODUCE ASSERTION": {
        "ID": "L7413",
        "BeforeRefact": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n            g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t\tg.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t\tg.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n\t\t}\n\t}",
        "ZeroShotCode": "protected void processParser() {\n\t\tg.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n\t\tfor (DecisionState s : g.atn.decisionToState) {\n\t\t\tIntervalSet[] look;\n\t\t\tif ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n\t\t\t\tlook = new IntervalSet[s.getNumberOfTransitions()+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL1Analyzer anal = new LL1Analyzer(g.atn);\n\t\t\t\tlook = anal.getDecisionLookahead(s);\n\t\t\t}\n\t\t\tUtils.setSize(g.decisionLOOK, s.decision+1);\n\t\t\tg.decisionLOOK.set(s.decision, look);\n\t\t}\n\t}",
        "InstrucCode": "```java\nprotected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n    for (DecisionState s : g.atn.decisionToState) {\n        assert s != null : \"DecisionState must not be null\";\n\n        g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions()+1];\n        }\n        else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision+1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}\n```",
        "FewShotCode": "protected void processParser() {\n    g.decisionLOOK = new ArrayList<IntervalSet[]>(g.atn.getNumberOfDecisions()+1);\n    for (DecisionState s : g.atn.decisionToState) {\n        g.tool.log(\"LL1\", \"\\nDECISION \"+s.decision+\" in rule \"+g.getRule(s.ruleIndex).name);\n        IntervalSet[] look;\n        if ( s.nonGreedy ) { // nongreedy decisions can't be LL(1)\n            look = new IntervalSet[s.getNumberOfTransitions()+1];\n        }\n        else {\n            LL1Analyzer anal = new LL1Analyzer(g.atn);\n            look = anal.getDecisionLookahead(s);\n            g.tool.log(\"LL1\", \"look=\" + Arrays.toString(look));\n        }\n        Utils.setSize(g.decisionLOOK, s.decision+1);\n        g.decisionLOOK.set(s.decision, look);\n        g.tool.log(\"LL1\", \"LL(1)? \" + disjoint(look));\n    }\n}"
    },
    "EXTRACT FUNCTION": {
        "ID": "L3446",
        "BeforeRefact": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "ZeroShotCode": "public Token singleTokenDeletion(Parser recognizer) {\n\t\tint nextTokenType = recognizer.getInputStream().LA(2);\n\t\tIntervalSet expecting = getExpectedTokens(recognizer);\n\t\tif ( expecting.contains(nextTokenType) ) {\n\t\t\treportUnwantedToken(recognizer);\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\tToken matchedSymbol = recognizer.getCurrentToken();\n\t\t\tendErrorCondition(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn null;\n\t}",
        "InstrucCode": "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        getTokenToDelete(recognizer);\n        recognizer.consume(); \n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  \n        return matchedSymbol;\n    }\n    return null;\n}\n\nprivate void getTokenToDelete(Parser recognizer) {\n\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t   ((TokenStream)recognizer.getInputStream()).LT(1)+\n\t\t\t\t\t   \" since \"+((TokenStream)recognizer.getInputStream()).LT(2)+\n\t\t\t\t\t   \" is what we want\");\n}",
        "FewShotCode": "public Token singleTokenDeletion(Parser recognizer) {\n    int nextTokenType = recognizer.getInputStream().LA(2);\n    IntervalSet expecting = getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n        reportUnwantedToken(recognizer);\n        recognizer.consume(); // simply delete extra token\n        Token matchedSymbol = recognizer.getCurrentToken();\n        endErrorCondition(recognizer);  // we know current token is correct\n        return matchedSymbol;\n    }\n    return null;\n}"
    },
    "INTRODUCE PARAMETER OBJECT": {
        "ID": "L540",
        "BeforeRefact": "void reportAmbiguity(@NotNull Parser recognizer,\n\t\t\t\t\t\t DFA dfa, int startIndex, int stopIndex,\n\t\t\t\t\t\t @NotNull BitSet ambigAlts,\n\t\t\t\t\t\t @NotNull ATNConfigSet configs);",
        "ZeroShotCode": "void reportAmbiguity(ReportAmbiguityParams params) {\n    @NotNull Parser recognizer = params.getRecognizer();\n    DFA dfa = params.getDfa();\n    int startIndex = params.getStartIndex();\n    int stopIndex = params.getStopIndex();\n    @NotNull BitSet ambigAlts = params.getAmbigAlts();\n    @NotNull ATNConfigSet configs = params.getConfigs();\n}",
        "InstrucCode": "void reportAmbiguity(@NotNull AmbiguityReportParams params);\n...\nclass AmbiguityReportParams {\n\t@NotNull Parser recognizer;\n\tDFA dfa;\n\tint startIndex;\n\tint stopIndex;\n\t@NotNull BitSet ambigAlts;\n\t@NotNull ATNConfigSet configs;\n}",
        "FewShotCode": "void reportAmbiguity(@NotNull Parser recognizer, \n                          AmbiguityReport ambiguityReport);\n\n// Introduce Parameter Object\nclass AmbiguityReport {\n    private final DFA dfa;\n    private final int startIndex;\n    private final int stopIndex;\n    private final BitSet ambigAlts;\n    private final ATNConfigSet configs;\n\n    public AmbiguityReport(DFA dfa, int startIndex, int stopIndex, BitSet ambigAlts, ATNConfigSet configs) {\n        this.dfa = dfa;\n        this.startIndex = startIndex;\n        this.stopIndex = stopIndex;\n        this.ambigAlts = ambigAlts;\n        this.configs = configs;\n    }\n\n    public DFA getDfa() {\n        return dfa;\n    }\n\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    public int getStopIndex() {\n        return stopIndex;\n    }\n\n    public BitSet getAmbigAlts() {\n        return ambigAlts;\n    }\n\n    public ATNConfigSet getConfigs() {\n        return configs;\n    }\n}"
    }
}